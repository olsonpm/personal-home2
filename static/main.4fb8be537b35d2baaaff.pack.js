/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./client/fonts/open-sans.italic.woff":
/*!********************************************!*\
  !*** ./client/fonts/open-sans.italic.woff ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"4b52a816817a711e6971955c835ecfbb.woff\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jbGllbnQvZm9udHMvb3Blbi1zYW5zLml0YWxpYy53b2ZmLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vY2xpZW50L2ZvbnRzL29wZW4tc2Fucy5pdGFsaWMud29mZj9lZWY2Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjRiNTJhODE2ODE3YTcxMWU2OTcxOTU1YzgzNWVjZmJiLndvZmZcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./client/fonts/open-sans.italic.woff\n");

/***/ }),

/***/ "./client/fonts/open-sans.regular.woff":
/*!*********************************************!*\
  !*** ./client/fonts/open-sans.regular.woff ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"d0bad741aefb909e4be56d188b6f02b9.woff\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jbGllbnQvZm9udHMvb3Blbi1zYW5zLnJlZ3VsYXIud29mZi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2NsaWVudC9mb250cy9vcGVuLXNhbnMucmVndWxhci53b2ZmPzJlMTciXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiZDBiYWQ3NDFhZWZiOTA5ZTRiZTU2ZDE4OGI2ZjAyYjkud29mZlwiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./client/fonts/open-sans.regular.woff\n");

/***/ }),

/***/ "./client/fonts/scope-one.regular.woff":
/*!*********************************************!*\
  !*** ./client/fonts/scope-one.regular.woff ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"c7fda34e17130319b02eb27af0c04cc2.woff\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jbGllbnQvZm9udHMvc2NvcGUtb25lLnJlZ3VsYXIud29mZi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2NsaWVudC9mb250cy9zY29wZS1vbmUucmVndWxhci53b2ZmP2IxZWQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiYzdmZGEzNGUxNzEzMDMxOWIwMmViMjdhZjBjMDRjYzIud29mZlwiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./client/fonts/scope-one.regular.woff\n");

/***/ }),

/***/ "./client/images/favicon.16.png":
/*!**************************************!*\
  !*** ./client/images/favicon.16.png ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"images/favicon.16.png\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jbGllbnQvaW1hZ2VzL2Zhdmljb24uMTYucG5nLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vY2xpZW50L2ltYWdlcy9mYXZpY29uLjE2LnBuZz8xMjY0Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltYWdlcy9mYXZpY29uLjE2LnBuZ1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./client/images/favicon.16.png\n");

/***/ }),

/***/ "./client/images/favicon.32.png":
/*!**************************************!*\
  !*** ./client/images/favicon.32.png ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"images/favicon.32.png\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jbGllbnQvaW1hZ2VzL2Zhdmljb24uMzIucG5nLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vY2xpZW50L2ltYWdlcy9mYXZpY29uLjMyLnBuZz84N2MwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltYWdlcy9mYXZpY29uLjMyLnBuZ1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./client/images/favicon.32.png\n");

/***/ }),

/***/ "./client/images/favicon.ico":
/*!***********************************!*\
  !*** ./client/images/favicon.ico ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"/favicon.ico\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jbGllbnQvaW1hZ2VzL2Zhdmljb24uaWNvLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vY2xpZW50L2ltYWdlcy9mYXZpY29uLmljbz82NWYzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIi9mYXZpY29uLmljb1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./client/images/favicon.ico\n");

/***/ }),

/***/ "./client/images/favicon.png":
/*!***********************************!*\
  !*** ./client/images/favicon.png ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"/favicon.png\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jbGllbnQvaW1hZ2VzL2Zhdmljb24ucG5nLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vY2xpZW50L2ltYWdlcy9mYXZpY29uLnBuZz8xNjVlIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIi9mYXZpY29uLnBuZ1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./client/images/favicon.png\n");

/***/ }),

/***/ "./client/images/profile.png":
/*!***********************************!*\
  !*** ./client/images/profile.png ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"images/profile.png\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jbGllbnQvaW1hZ2VzL3Byb2ZpbGUucG5nLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vY2xpZW50L2ltYWdlcy9wcm9maWxlLnBuZz82NTk1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltYWdlcy9wcm9maWxlLnBuZ1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./client/images/profile.png\n");

/***/ }),

/***/ "./client/js/index.js":
/*!****************************!*\
  !*** ./client/js/index.js ***!
  \****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var domtastic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! domtastic */ \"./node_modules/domtastic/src/index.js\");\n/* harmony import */ var smoothscroll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! smoothscroll */ \"./node_modules/smoothscroll/smoothscroll.js\");\n/* harmony import */ var smoothscroll__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(smoothscroll__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var velocity_animate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! velocity-animate */ \"./node_modules/velocity-animate/velocity.js\");\n/* harmony import */ var velocity_animate__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(velocity_animate__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _scss_screen_size_breakpoints_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../scss/screen-size-breakpoints.scss */ \"./client/scss/screen-size-breakpoints.scss\");\n/* harmony import */ var _scss_screen_size_breakpoints_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_scss_screen_size_breakpoints_scss__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _images_profile_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../images/profile.png */ \"./client/images/profile.png\");\n/* harmony import */ var _images_profile_png__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_images_profile_png__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _images_favicon_16_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../images/favicon.16.png */ \"./client/images/favicon.16.png\");\n/* harmony import */ var _images_favicon_16_png__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_images_favicon_16_png__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _images_favicon_32_png__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../images/favicon.32.png */ \"./client/images/favicon.32.png\");\n/* harmony import */ var _images_favicon_32_png__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_images_favicon_32_png__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _images_favicon_png__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../images/favicon.png */ \"./client/images/favicon.png\");\n/* harmony import */ var _images_favicon_png__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_images_favicon_png__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _images_favicon_ico__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../images/favicon.ico */ \"./client/images/favicon.ico\");\n/* harmony import */ var _images_favicon_ico__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_images_favicon_ico__WEBPACK_IMPORTED_MODULE_8__);\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n//---------//\n// Imports //\n//---------//\n\n\n\n //\n// and because nunjucks-loader doesn't work in a node environment, it's easiest\n//   to declare image dependencies here\n//\n\n\n\n\n\n //\n//------//\n// Init //\n//------//\n\nvar delay = 600,\n    setOfAnimatingElements = new Set(),\n    xsMax = _scss_screen_size_breakpoints_scss__WEBPACK_IMPORTED_MODULE_3__[\"locals\"].xsMax; //\n//------//\n// Main //\n//------//\n\nObject(domtastic__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('button.expander').on('click', expanderClicked);\nwindow.scrollTo = scrollTo; //\n//-------------//\n// Helper Fxns //\n//-------------//\n\nfunction scrollTo() {\n  var link = Object(domtastic__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this),\n      id = link.attr('href').slice(1),\n      scrollToEl = document.getElementById(id),\n      y = scrollToEl.getBoundingClientRect().top;\n  smoothscroll__WEBPACK_IMPORTED_MODULE_1___default()(scrollToEl, calculateDuration(y));\n  return false;\n}\n\nfunction calculateDuration(y) {\n  return (y - scrollY) / 600;\n}\n\nfunction expanderClicked() {\n  var _this = this;\n\n  if (setOfAnimatingElements.has(this)) return;\n  setOfAnimatingElements.add(this, true);\n  var button = Object(domtastic__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this);\n\n  if (isExtraSmallScreen() && !button.hasClass('expanded')) {\n    smoothscroll__WEBPACK_IMPORTED_MODULE_1___default()(this, delay);\n  }\n\n  return Promise.all([rotateButton(button), toggleContentState(button)]).then(function () {\n    button.toggleClass('expanded');\n    setOfAnimatingElements.delete(_this);\n  });\n}\n\nfunction rotateButton(button) {\n  var _ref = button.hasClass('expanded') ? ['0deg', '180deg'] : ['180deg', '0deg'],\n      _ref2 = _slicedToArray(_ref, 2),\n      to = _ref2[0],\n      from = _ref2[1];\n\n  return velocity_animate__WEBPACK_IMPORTED_MODULE_2___default()(button.find('svg')[0], {\n    transform: [\"rotate(\".concat(to, \")\"), \"rotate(\".concat(from, \")\")]\n  });\n}\n\nfunction isExtraSmallScreen() {\n  return window.matchMedia(\"(max-width: \".concat(xsMax, \")\")).matches;\n}\n\nfunction toggleContentState(button) {\n  var content = button.siblings('.content')[0],\n      isExpanded = button.hasClass('expanded'),\n      closedHeight = 0;\n  var openHeight = content.clientHeight;\n\n  if (!isExpanded) {\n    Object(domtastic__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(content).css('height', 'auto');\n    openHeight = content.clientHeight;\n    Object(domtastic__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(content).css('height', '0');\n  }\n\n  var _ref3 = isExpanded ? [closedHeight, openHeight] : [openHeight, closedHeight],\n      _ref4 = _slicedToArray(_ref3, 2),\n      to = _ref4[0],\n      from = _ref4[1];\n\n  return velocity_animate__WEBPACK_IMPORTED_MODULE_2___default()(content, {\n    height: [\"\".concat(to, \"px\"), \"\".concat(from, \"px\")]\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jbGllbnQvanMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vY2xpZW50L2pzL2luZGV4LmpzPzU0YmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8tLS0tLS0tLS0vL1xuLy8gSW1wb3J0cyAvL1xuLy8tLS0tLS0tLS0vL1xuXG5pbXBvcnQgJCBmcm9tICdkb210YXN0aWMnXG5pbXBvcnQgc21vb3Roc2Nyb2xsIGZyb20gJ3Ntb290aHNjcm9sbCdcbmltcG9ydCBhbmltYXRlIGZyb20gJ3ZlbG9jaXR5LWFuaW1hdGUnXG5cbmltcG9ydCB7IGxvY2FscyB9IGZyb20gJy4uL3Njc3Mvc2NyZWVuLXNpemUtYnJlYWtwb2ludHMuc2NzcydcblxuLy9cbi8vIGFuZCBiZWNhdXNlIG51bmp1Y2tzLWxvYWRlciBkb2Vzbid0IHdvcmsgaW4gYSBub2RlIGVudmlyb25tZW50LCBpdCdzIGVhc2llc3Rcbi8vICAgdG8gZGVjbGFyZSBpbWFnZSBkZXBlbmRlbmNpZXMgaGVyZVxuLy9cbmltcG9ydCAnLi4vaW1hZ2VzL3Byb2ZpbGUucG5nJ1xuaW1wb3J0ICcuLi9pbWFnZXMvZmF2aWNvbi4xNi5wbmcnXG5pbXBvcnQgJy4uL2ltYWdlcy9mYXZpY29uLjMyLnBuZydcbmltcG9ydCAnLi4vaW1hZ2VzL2Zhdmljb24ucG5nJ1xuaW1wb3J0ICcuLi9pbWFnZXMvZmF2aWNvbi5pY28nXG5cbi8vXG4vLy0tLS0tLS8vXG4vLyBJbml0IC8vXG4vLy0tLS0tLS8vXG5cbmNvbnN0IGRlbGF5ID0gNjAwLFxuICBzZXRPZkFuaW1hdGluZ0VsZW1lbnRzID0gbmV3IFNldCgpLFxuICB7IHhzTWF4IH0gPSBsb2NhbHNcblxuLy9cbi8vLS0tLS0tLy9cbi8vIE1haW4gLy9cbi8vLS0tLS0tLy9cblxuJCgnYnV0dG9uLmV4cGFuZGVyJykub24oJ2NsaWNrJywgZXhwYW5kZXJDbGlja2VkKVxud2luZG93LnNjcm9sbFRvID0gc2Nyb2xsVG9cblxuLy9cbi8vLS0tLS0tLS0tLS0tLS8vXG4vLyBIZWxwZXIgRnhucyAvL1xuLy8tLS0tLS0tLS0tLS0tLy9cblxuZnVuY3Rpb24gc2Nyb2xsVG8oKSB7XG4gIGNvbnN0IGxpbmsgPSAkKHRoaXMpLFxuICAgIGlkID0gbGluay5hdHRyKCdocmVmJykuc2xpY2UoMSksXG4gICAgc2Nyb2xsVG9FbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSxcbiAgICB5ID0gc2Nyb2xsVG9FbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcblxuICBzbW9vdGhzY3JvbGwoc2Nyb2xsVG9FbCwgY2FsY3VsYXRlRHVyYXRpb24oeSkpXG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUR1cmF0aW9uKHkpIHtcbiAgcmV0dXJuICh5IC0gc2Nyb2xsWSkgLyA2MDBcbn1cblxuZnVuY3Rpb24gZXhwYW5kZXJDbGlja2VkKCkge1xuICBpZiAoc2V0T2ZBbmltYXRpbmdFbGVtZW50cy5oYXModGhpcykpIHJldHVyblxuXG4gIHNldE9mQW5pbWF0aW5nRWxlbWVudHMuYWRkKHRoaXMsIHRydWUpXG5cbiAgY29uc3QgYnV0dG9uID0gJCh0aGlzKVxuXG4gIGlmIChpc0V4dHJhU21hbGxTY3JlZW4oKSAmJiAhYnV0dG9uLmhhc0NsYXNzKCdleHBhbmRlZCcpKSB7XG4gICAgc21vb3Roc2Nyb2xsKHRoaXMsIGRlbGF5KVxuICB9XG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKFtyb3RhdGVCdXR0b24oYnV0dG9uKSwgdG9nZ2xlQ29udGVudFN0YXRlKGJ1dHRvbildKS50aGVuKFxuICAgICgpID0+IHtcbiAgICAgIGJ1dHRvbi50b2dnbGVDbGFzcygnZXhwYW5kZWQnKVxuICAgICAgc2V0T2ZBbmltYXRpbmdFbGVtZW50cy5kZWxldGUodGhpcylcbiAgICB9XG4gIClcbn1cblxuZnVuY3Rpb24gcm90YXRlQnV0dG9uKGJ1dHRvbikge1xuICBjb25zdCBbdG8sIGZyb21dID0gYnV0dG9uLmhhc0NsYXNzKCdleHBhbmRlZCcpXG4gICAgPyBbJzBkZWcnLCAnMTgwZGVnJ11cbiAgICA6IFsnMTgwZGVnJywgJzBkZWcnXVxuXG4gIHJldHVybiBhbmltYXRlKGJ1dHRvbi5maW5kKCdzdmcnKVswXSwge1xuICAgIHRyYW5zZm9ybTogW2Byb3RhdGUoJHt0b30pYCwgYHJvdGF0ZSgke2Zyb219KWBdLFxuICB9KVxufVxuXG5mdW5jdGlvbiBpc0V4dHJhU21hbGxTY3JlZW4oKSB7XG4gIHJldHVybiB3aW5kb3cubWF0Y2hNZWRpYShgKG1heC13aWR0aDogJHt4c01heH0pYCkubWF0Y2hlc1xufVxuXG5mdW5jdGlvbiB0b2dnbGVDb250ZW50U3RhdGUoYnV0dG9uKSB7XG4gIGNvbnN0IGNvbnRlbnQgPSBidXR0b24uc2libGluZ3MoJy5jb250ZW50JylbMF0sXG4gICAgaXNFeHBhbmRlZCA9IGJ1dHRvbi5oYXNDbGFzcygnZXhwYW5kZWQnKSxcbiAgICBjbG9zZWRIZWlnaHQgPSAwXG5cbiAgbGV0IG9wZW5IZWlnaHQgPSBjb250ZW50LmNsaWVudEhlaWdodFxuXG4gIGlmICghaXNFeHBhbmRlZCkge1xuICAgICQoY29udGVudCkuY3NzKCdoZWlnaHQnLCAnYXV0bycpXG4gICAgb3BlbkhlaWdodCA9IGNvbnRlbnQuY2xpZW50SGVpZ2h0XG4gICAgJChjb250ZW50KS5jc3MoJ2hlaWdodCcsICcwJylcbiAgfVxuXG4gIGNvbnN0IFt0bywgZnJvbV0gPSBpc0V4cGFuZGVkXG4gICAgPyBbY2xvc2VkSGVpZ2h0LCBvcGVuSGVpZ2h0XVxuICAgIDogW29wZW5IZWlnaHQsIGNsb3NlZEhlaWdodF1cblxuICByZXR1cm4gYW5pbWF0ZShjb250ZW50LCB7IGhlaWdodDogW2Ake3RvfXB4YCwgYCR7ZnJvbX1weGBdIH0pXG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWdCQTtBQUFBO0FBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./client/js/index.js\n");

/***/ }),

/***/ "./client/scss/index.scss":
/*!********************************!*\
  !*** ./client/scss/index.scss ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader??ref--8-1!../../node_modules/sass-loader/lib/loader.js??ref--8-2!./index.scss */ \"./node_modules/css-loader/index.js??ref--8-1!./node_modules/sass-loader/lib/loader.js??ref--8-2!./client/scss/index.scss\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jbGllbnQvc2Nzcy9pbmRleC5zY3NzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vY2xpZW50L3Njc3MvaW5kZXguc2Nzcz9hZjc5Il0sInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS04LTEhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tOC0yIS4vaW5kZXguc2Nzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tOC0xIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTgtMiEuL2luZGV4LnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS04LTEhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tOC0yIS4vaW5kZXguc2Nzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./client/scss/index.scss\n");

/***/ }),

/***/ "./client/scss/screen-size-breakpoints.scss":
/*!**************************************************!*\
  !*** ./client/scss/screen-size-breakpoints.scss ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"xsMin\": \"480px\",\n\t\"smMin\": \"768px\",\n\t\"mdMin\": \"992px\",\n\t\"lgMin\": \"1200px\",\n\t\"xxsMax\": \"479px\",\n\t\"xsMax\": \"767px\",\n\t\"smMax\": \"991px\",\n\t\"mdMax\": \"1199px\"\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jbGllbnQvc2Nzcy9zY3JlZW4tc2l6ZS1icmVha3BvaW50cy5zY3NzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vY2xpZW50L3Njc3Mvc2NyZWVuLXNpemUtYnJlYWtwb2ludHMuc2Nzcz8zODRiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwieHNNaW5cIjogXCI0ODBweFwiLFxuXHRcInNtTWluXCI6IFwiNzY4cHhcIixcblx0XCJtZE1pblwiOiBcIjk5MnB4XCIsXG5cdFwibGdNaW5cIjogXCIxMjAwcHhcIixcblx0XCJ4eHNNYXhcIjogXCI0NzlweFwiLFxuXHRcInhzTWF4XCI6IFwiNzY3cHhcIixcblx0XCJzbU1heFwiOiBcIjk5MXB4XCIsXG5cdFwibWRNYXhcIjogXCIxMTk5cHhcIlxufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./client/scss/screen-size-breakpoints.scss\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js??ref--8-1!./node_modules/sass-loader/lib/loader.js??ref--8-2!./client/scss/index.scss":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--8-1!./node_modules/sass-loader/lib/loader.js??ref--8-2!./client/scss/index.scss ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var escape = __webpack_require__(/*! ../../node_modules/css-loader/lib/url/escape.js */ \"./node_modules/css-loader/lib/url/escape.js\");\nexports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(true);\n// imports\nexports.push([module.i, \"@import url(/node_modules/normalize.css/normalize.css);\", \"\"]);\n\n// module\nexports.push([module.i, \"@font-face {\\n  font-family: ScopeOne;\\n  font-weight: 400;\\n  src: url(\" + escape(__webpack_require__(/*! ../fonts/scope-one.regular.woff */ \"./client/fonts/scope-one.regular.woff\")) + \") format(\\\"woff\\\"); }\\n\\n@font-face {\\n  font-family: 'Open Sans';\\n  font-weight: 400;\\n  src: url(\" + escape(__webpack_require__(/*! ../fonts/open-sans.regular.woff */ \"./client/fonts/open-sans.regular.woff\")) + \") format(\\\"woff\\\"); }\\n\\n@font-face {\\n  font-family: 'Open Sans';\\n  font-weight: 400;\\n  font-style: italic;\\n  src: url(\" + escape(__webpack_require__(/*! ../fonts/open-sans.italic.woff */ \"./client/fonts/open-sans.italic.woff\")) + \") format(\\\"woff\\\"); }\\n\\nhtml,\\nbody {\\n  background: white;\\n  color: #131313;\\n  font-family: 'Open Sans', sans-serif;\\n  font-size: 18px; }\\n\\nbody {\\n  display: flex;\\n  flex-direction: column;\\n  min-height: 100vh; }\\n  body > .site-container {\\n    flex-grow: 1; }\\n\\nh1,\\nh2,\\nh3,\\nh4 {\\n  font-family: ScopeOne, serif; }\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  font-weight: 400; }\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\np,\\nul,\\nol,\\nli,\\nbutton {\\n  margin: 0;\\n  padding: 0; }\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\nli {\\n  line-height: 1; }\\n\\nbutton {\\n  border: 0;\\n  outline: none !important;\\n  background: none;\\n  border-image-width: 0;\\n  font-size: 0; }\\n\\np {\\n  line-height: 1.3; }\\n\\nh1 {\\n  font-size: 48px; }\\n\\nh2 {\\n  font-size: 32px; }\\n\\nh3 {\\n  font-size: 26px; }\\n\\nh4 {\\n  font-size: 23px; }\\n\\nh5 {\\n  font-size: 20px;\\n  margin-bottom: 9px; }\\n\\na {\\n  color: #2457b0;\\n  text-decoration: none; }\\n\\np.note {\\n  font-style: italic; }\\n\\n@media (max-width: 479px) {\\n  p,\\n  dd,\\n  dt {\\n    font-size: 16px; } }\\n\\n@media (min-width: 480px) and (max-width: 767px) {\\n  p,\\n  dd,\\n  dt {\\n    font-size: 16px; } }\\n\\n@media (min-width: 768px) and (max-width: 991px) {\\n  p,\\n  dd,\\n  dt {\\n    font-size: 18px; } }\\n\\n@media (min-width: 992px) and (max-width: 1199px) {\\n  p,\\n  dd,\\n  dt {\\n    font-size: 18px; } }\\n\\n@media (min-width: 1200px) {\\n  p,\\n  dd,\\n  dt {\\n    font-size: 18px; } }\\n\\nul:not(.normal-list),\\nol:not(.normal-list) {\\n  list-style: none; }\\n\\n.site-container {\\n  margin: 0 auto;\\n  max-width: 1100px; }\\n  @media (max-width: 479px) {\\n    .site-container {\\n      padding-left: 18px;\\n      padding-right: 18px; } }\\n  @media (min-width: 480px) and (max-width: 767px) {\\n    .site-container {\\n      padding-left: 18px;\\n      padding-right: 18px; } }\\n  @media (min-width: 768px) and (max-width: 991px) {\\n    .site-container {\\n      padding-left: 27px;\\n      padding-right: 27px; } }\\n  @media (min-width: 992px) and (max-width: 1199px) {\\n    .site-container {\\n      padding-left: 36px;\\n      padding-right: 36px; } }\\n  @media (min-width: 1200px) {\\n    .site-container {\\n      padding-left: 54px;\\n      padding-right: 54px; } }\\n\\n@media (max-width: 479px) {\\n  main > section {\\n    margin-top: 36px; } }\\n\\n@media (min-width: 480px) and (max-width: 767px) {\\n  main > section {\\n    margin-top: 36px; } }\\n\\n@media (min-width: 768px) and (max-width: 991px) {\\n  main > section {\\n    margin-top: 54px; } }\\n\\n@media (min-width: 992px) and (max-width: 1199px) {\\n  main > section {\\n    margin-top: 54px; } }\\n\\n@media (min-width: 1200px) {\\n  main > section {\\n    margin-top: 54px; } }\\n\\nmain > section h3 {\\n  color: #a32500;\\n  margin-bottom: 18px; }\\n  @media (max-width: 479px) {\\n    main > section h3 {\\n      font-size: 26px; } }\\n  @media (min-width: 480px) and (max-width: 767px) {\\n    main > section h3 {\\n      font-size: 26px; } }\\n  @media (min-width: 768px) and (max-width: 991px) {\\n    main > section h3 {\\n      font-size: 32px; } }\\n  @media (min-width: 992px) and (max-width: 1199px) {\\n    main > section h3 {\\n      font-size: 32px; } }\\n  @media (min-width: 1200px) {\\n    main > section h3 {\\n      font-size: 32px; } }\\n\\nmain > section h4 {\\n  margin-top: 27px; }\\n\\nmain > section h5 {\\n  margin-top: 18px; }\\n\\nmain > section p + p {\\n  margin-top: 9px; }\\n\\nmain > section p + ul {\\n  margin-top: 18px; }\\n\\nmain > section h4 {\\n  margin-bottom: 9px; }\\n  main > section h4:before {\\n    content: ' - '; }\\n\\nbutton.expander > svg {\\n  height: 41px;\\n  width: 41px; }\\n\\n.sidenote {\\n  font-style: italic; }\\n\\nbutton {\\n  -webkit-tap-highlight-color: transparent; }\\n\\nfooter {\\n  background-color: #303030;\\n  color: white;\\n  text-align: center; }\\n  @media (max-width: 479px) {\\n    footer {\\n      height: 80px;\\n      line-height: 80px; } }\\n  @media (min-width: 480px) and (max-width: 767px) {\\n    footer {\\n      height: 80px;\\n      line-height: 80px; } }\\n  @media (min-width: 768px) and (max-width: 991px) {\\n    footer {\\n      height: 110px;\\n      line-height: 110px; } }\\n  @media (min-width: 992px) and (max-width: 1199px) {\\n    footer {\\n      height: 110px;\\n      line-height: 110px; } }\\n  @media (min-width: 1200px) {\\n    footer {\\n      height: 110px;\\n      line-height: 110px; } }\\n  @media (max-width: 479px) {\\n    footer {\\n      margin-top: 36px; } }\\n  @media (min-width: 480px) and (max-width: 767px) {\\n    footer {\\n      margin-top: 36px; } }\\n  @media (min-width: 768px) and (max-width: 991px) {\\n    footer {\\n      margin-top: 54px; } }\\n  @media (min-width: 992px) and (max-width: 1199px) {\\n    footer {\\n      margin-top: 54px; } }\\n  @media (min-width: 1200px) {\\n    footer {\\n      margin-top: 54px; } }\\n  footer .email {\\n    vertical-align: middle; }\\n    @media (max-width: 479px) {\\n      footer .email {\\n        margin-right: 20px; } }\\n    @media (min-width: 480px) and (max-width: 767px) {\\n      footer .email {\\n        margin-right: 20px; } }\\n    @media (min-width: 768px) and (max-width: 991px) {\\n      footer .email {\\n        margin-right: 30px; } }\\n    @media (min-width: 992px) and (max-width: 1199px) {\\n      footer .email {\\n        margin-right: 30px; } }\\n    @media (min-width: 1200px) {\\n      footer .email {\\n        margin-right: 30px; } }\\n    @media (max-width: 479px) {\\n      footer .email {\\n        font-size: 15px; } }\\n    @media (min-width: 480px) and (max-width: 767px) {\\n      footer .email {\\n        font-size: 15px; } }\\n    @media (min-width: 768px) and (max-width: 991px) {\\n      footer .email {\\n        font-size: 16px; } }\\n    @media (min-width: 992px) and (max-width: 1199px) {\\n      footer .email {\\n        font-size: 16px; } }\\n    @media (min-width: 1200px) {\\n      footer .email {\\n        font-size: 16px; } }\\n  footer .octicon {\\n    vertical-align: middle; }\\n    @media (max-width: 479px) {\\n      footer .octicon {\\n        height: 50px; } }\\n    @media (min-width: 480px) and (max-width: 767px) {\\n      footer .octicon {\\n        height: 50px; } }\\n    @media (min-width: 768px) and (max-width: 991px) {\\n      footer .octicon {\\n        height: 70px; } }\\n    @media (min-width: 992px) and (max-width: 1199px) {\\n      footer .octicon {\\n        height: 70px; } }\\n    @media (min-width: 1200px) {\\n      footer .octicon {\\n        height: 70px; } }\\n    @media (max-width: 479px) {\\n      footer .octicon {\\n        margin-top: 10px;\\n        margin-bottom: 10px; } }\\n    @media (min-width: 480px) and (max-width: 767px) {\\n      footer .octicon {\\n        margin-top: 10px;\\n        margin-bottom: 10px; } }\\n    @media (min-width: 768px) and (max-width: 991px) {\\n      footer .octicon {\\n        margin-top: 15px;\\n        margin-bottom: 15px; } }\\n    @media (min-width: 992px) and (max-width: 1199px) {\\n      footer .octicon {\\n        margin-top: 15px;\\n        margin-bottom: 15px; } }\\n    @media (min-width: 1200px) {\\n      footer .octicon {\\n        margin-top: 15px;\\n        margin-bottom: 15px; } }\\n    footer .octicon path {\\n      fill: white; }\\n\\nheader {\\n  text-align: center; }\\n  @media (max-width: 479px) {\\n    header {\\n      margin-top: 27px; } }\\n  @media (min-width: 480px) and (max-width: 767px) {\\n    header {\\n      margin-top: 27px; } }\\n  @media (min-width: 768px) and (max-width: 991px) {\\n    header {\\n      margin-top: 36px; } }\\n  @media (min-width: 992px) and (max-width: 1199px) {\\n    header {\\n      margin-top: 54px; } }\\n  @media (min-width: 1200px) {\\n    header {\\n      margin-top: 63px; } }\\n  header h1 {\\n    margin-bottom: 18px; }\\n  header img {\\n    margin-bottom: 18px; }\\n    @media (max-width: 479px) {\\n      header img {\\n        height: 180px; } }\\n    @media (min-width: 480px) and (max-width: 767px) {\\n      header img {\\n        height: 180px; } }\\n    @media (min-width: 768px) and (max-width: 991px) {\\n      header img {\\n        height: 180px; } }\\n    @media (min-width: 992px) and (max-width: 1199px) {\\n      header img {\\n        height: 220px; } }\\n    @media (min-width: 1200px) {\\n      header img {\\n        height: 220px; } }\\n  @media (max-width: 479px) {\\n    header h3 {\\n      margin-bottom: 27px; } }\\n  @media (min-width: 480px) and (max-width: 767px) {\\n    header h3 {\\n      margin-bottom: 27px; } }\\n  @media (min-width: 768px) and (max-width: 991px) {\\n    header h3 {\\n      margin-bottom: 36px; } }\\n  @media (min-width: 992px) and (max-width: 1199px) {\\n    header h3 {\\n      margin-bottom: 36px; } }\\n  @media (min-width: 1200px) {\\n    header h3 {\\n      margin-bottom: 36px; } }\\n  header p {\\n    font-style: italic; }\\n    @media (max-width: 479px) {\\n      header p {\\n        margin-bottom: 27px; } }\\n    @media (min-width: 480px) and (max-width: 767px) {\\n      header p {\\n        margin-bottom: 27px; } }\\n    @media (min-width: 768px) and (max-width: 991px) {\\n      header p {\\n        margin-bottom: 36px; } }\\n    @media (min-width: 992px) and (max-width: 1199px) {\\n      header p {\\n        margin-bottom: 36px; } }\\n    @media (min-width: 1200px) {\\n      header p {\\n        margin-bottom: 36px; } }\\n    @media (max-width: 479px) {\\n      header p {\\n        font-size: 15px; } }\\n    @media (min-width: 480px) and (max-width: 767px) {\\n      header p {\\n        font-size: 16px; } }\\n    @media (min-width: 768px) and (max-width: 991px) {\\n      header p {\\n        font-size: 18px; } }\\n    @media (min-width: 992px) and (max-width: 1199px) {\\n      header p {\\n        font-size: 18px; } }\\n    @media (min-width: 1200px) {\\n      header p {\\n        font-size: 18px; } }\\n  header nav {\\n    font-family: ScopeOne, serif; }\\n    @media (max-width: 479px) {\\n      header nav {\\n        font-size: 26px; } }\\n    @media (min-width: 480px) and (max-width: 767px) {\\n      header nav {\\n        font-size: 26px; } }\\n    @media (min-width: 768px) and (max-width: 991px) {\\n      header nav {\\n        font-size: 32px; } }\\n    @media (min-width: 992px) and (max-width: 1199px) {\\n      header nav {\\n        font-size: 32px; } }\\n    @media (min-width: 1200px) {\\n      header nav {\\n        font-size: 32px; } }\\n    @media (max-width: 991px) {\\n      header nav li + li {\\n        margin-top: 18px; } }\\n    @media (min-width: 992px) {\\n      header nav li {\\n        display: inline-block; }\\n      header nav li + li:before {\\n        content: \\\"/\\\"; } }\\n  @media (min-width: 992px) and (max-width: 479px) {\\n    header nav li + li:before {\\n      margin-left: 9px;\\n      margin-right: 9px; } }\\n  @media (min-width: 992px) and (min-width: 480px) and (max-width: 767px) {\\n    header nav li + li:before {\\n      margin-left: 18px;\\n      margin-right: 18px; } }\\n  @media (min-width: 992px) and (min-width: 768px) and (max-width: 991px) {\\n    header nav li + li:before {\\n      margin-left: 18px;\\n      margin-right: 18px; } }\\n  @media (min-width: 992px) and (min-width: 992px) and (max-width: 1199px) {\\n    header nav li + li:before {\\n      margin-left: 27px;\\n      margin-right: 27px; } }\\n  @media (min-width: 992px) and (min-width: 1200px) {\\n    header nav li + li:before {\\n      margin-left: 27px;\\n      margin-right: 27px; } }\\n\\n#side-projects h4 {\\n  margin-bottom: 18px; }\\n\\n#side-projects ul.legend > li + li {\\n  margin-top: 9px; }\\n\\n#side-projects > ul:not(.legend) > li + li {\\n  margin-top: 27px; }\\n\\n#side-projects .application,\\n#side-projects .tool,\\n#side-projects .library {\\n  vertical-align: top;\\n  margin-top: 0;\\n  margin-bottom: 0;\\n  border-left-style: solid;\\n  padding-top: 9px;\\n  padding-bottom: 9px;\\n  display: inline-block;\\n  position: relative; }\\n  @media (max-width: 479px) {\\n    #side-projects .application,\\n    #side-projects .tool,\\n    #side-projects .library {\\n      padding-left: 9px; } }\\n  @media (min-width: 480px) and (max-width: 767px) {\\n    #side-projects .application,\\n    #side-projects .tool,\\n    #side-projects .library {\\n      padding-left: 36px; } }\\n  @media (min-width: 768px) and (max-width: 991px) {\\n    #side-projects .application,\\n    #side-projects .tool,\\n    #side-projects .library {\\n      padding-left: 36px; } }\\n  @media (min-width: 992px) and (max-width: 1199px) {\\n    #side-projects .application,\\n    #side-projects .tool,\\n    #side-projects .library {\\n      padding-left: 54px; } }\\n  @media (min-width: 1200px) {\\n    #side-projects .application,\\n    #side-projects .tool,\\n    #side-projects .library {\\n      padding-left: 54px; } }\\n  @media (max-width: 479px) {\\n    #side-projects .application,\\n    #side-projects .tool,\\n    #side-projects .library {\\n      padding-right: 9px; } }\\n  @media (min-width: 480px) and (max-width: 767px) {\\n    #side-projects .application,\\n    #side-projects .tool,\\n    #side-projects .library {\\n      padding-right: 45px; } }\\n  @media (min-width: 768px) and (max-width: 991px) {\\n    #side-projects .application,\\n    #side-projects .tool,\\n    #side-projects .library {\\n      padding-right: 45px; } }\\n  @media (min-width: 992px) and (max-width: 1199px) {\\n    #side-projects .application,\\n    #side-projects .tool,\\n    #side-projects .library {\\n      padding-right: 63px; } }\\n  @media (min-width: 1200px) {\\n    #side-projects .application,\\n    #side-projects .tool,\\n    #side-projects .library {\\n      padding-right: 63px; } }\\n  @media (max-width: 479px) {\\n    #side-projects .application,\\n    #side-projects .tool,\\n    #side-projects .library {\\n      border-left-width: 2px; } }\\n  @media (min-width: 480px) and (max-width: 767px) {\\n    #side-projects .application,\\n    #side-projects .tool,\\n    #side-projects .library {\\n      border-left-width: 2px; } }\\n  @media (min-width: 768px) and (max-width: 991px) {\\n    #side-projects .application,\\n    #side-projects .tool,\\n    #side-projects .library {\\n      border-left-width: 3px; } }\\n  @media (min-width: 992px) and (max-width: 1199px) {\\n    #side-projects .application,\\n    #side-projects .tool,\\n    #side-projects .library {\\n      border-left-width: 3px; } }\\n  @media (min-width: 1200px) {\\n    #side-projects .application,\\n    #side-projects .tool,\\n    #side-projects .library {\\n      border-left-width: 3px; } }\\n  #side-projects .application:before,\\n  #side-projects .tool:before,\\n  #side-projects .library:before {\\n    content: none; }\\n  @media (min-width: 480px) {\\n    #side-projects .application:after,\\n    #side-projects .tool:after,\\n    #side-projects .library:after {\\n      position: absolute;\\n      content: '';\\n      top: 0;\\n      right: 0;\\n      width: 0;\\n      height: 0;\\n      border-top: 20.5px solid transparent;\\n      border-bottom: 20.5px solid transparent;\\n      border-right: 9px solid white; } }\\n\\n#side-projects .application {\\n  border-left-color: #19610d;\\n  background-color: rgba(26, 189, 0, 0.3); }\\n  #side-projects .application + button {\\n    cursor: pointer; }\\n    #side-projects .application + button svg path {\\n      fill: #19610d; }\\n\\n#side-projects .tool {\\n  border-left-color: #f0a300;\\n  background-color: rgba(240, 163, 0, 0.3); }\\n  #side-projects .tool + button {\\n    cursor: pointer; }\\n    #side-projects .tool + button svg path {\\n      fill: #f0a300; }\\n\\n#side-projects .library {\\n  border-left-color: #84008a;\\n  background-color: rgba(132, 0, 138, 0.15); }\\n  #side-projects .library + button {\\n    cursor: pointer; }\\n    #side-projects .library + button svg path {\\n      fill: #84008a; }\\n\\n@media (max-width: 479px) {\\n  #side-projects button {\\n    margin-left: 18px; } }\\n\\n@media (min-width: 480px) and (max-width: 767px) {\\n  #side-projects button {\\n    margin-left: 27px; } }\\n\\n@media (min-width: 768px) and (max-width: 991px) {\\n  #side-projects button {\\n    margin-left: 27px; } }\\n\\n@media (min-width: 992px) and (max-width: 1199px) {\\n  #side-projects button {\\n    margin-left: 36px; } }\\n\\n@media (min-width: 1200px) {\\n  #side-projects button {\\n    margin-left: 36px; } }\\n\\n#side-projects .content {\\n  height: 0;\\n  overflow: hidden; }\\n  @media (max-width: 479px) {\\n    #side-projects .content {\\n      margin-left: 9px; } }\\n  @media (min-width: 480px) and (max-width: 767px) {\\n    #side-projects .content {\\n      margin-left: 9px; } }\\n  @media (min-width: 768px) and (max-width: 991px) {\\n    #side-projects .content {\\n      margin-left: 18px; } }\\n  @media (min-width: 992px) and (max-width: 1199px) {\\n    #side-projects .content {\\n      margin-left: 18px; } }\\n  @media (min-width: 1200px) {\\n    #side-projects .content {\\n      margin-left: 18px; } }\\n  #side-projects .content > a {\\n    display: block; }\\n    #side-projects .content > a:first-child {\\n      margin-top: 18px; }\\n    #side-projects .content > a:not(:first-child) {\\n      margin-top: 9px; }\\n\\n@media (max-width: 479px) {\\n  #side-projects dd + dt {\\n    margin-top: 9px; } }\\n\\n@media (min-width: 480px) and (max-width: 767px) {\\n  #side-projects dd + dt {\\n    margin-top: 9px; } }\\n\\n@media (min-width: 768px) and (max-width: 991px) {\\n  #side-projects dd + dt {\\n    margin-top: 18px; } }\\n\\n@media (min-width: 992px) and (max-width: 1199px) {\\n  #side-projects dd + dt {\\n    margin-top: 18px; } }\\n\\n@media (min-width: 1200px) {\\n  #side-projects dd + dt {\\n    margin-top: 18px; } }\\n\\n#side-projects dt:before {\\n  content: '- '; }\\n\\n@media (max-width: 479px) {\\n  #side-projects dd {\\n    margin-top: 3px; } }\\n\\n@media (min-width: 480px) and (max-width: 767px) {\\n  #side-projects dd {\\n    margin-top: 3px; } }\\n\\n@media (min-width: 768px) and (max-width: 991px) {\\n  #side-projects dd {\\n    margin-top: 4px; } }\\n\\n@media (min-width: 992px) and (max-width: 1199px) {\\n  #side-projects dd {\\n    margin-top: 4px; } }\\n\\n@media (min-width: 1200px) {\\n  #side-projects dd {\\n    margin-top: 5px; } }\\n\\n@media (max-width: 479px) {\\n  #side-projects dd {\\n    margin-left: 18px; } }\\n\\n@media (min-width: 480px) and (max-width: 767px) {\\n  #side-projects dd {\\n    margin-left: 18px; } }\\n\\n@media (min-width: 768px) and (max-width: 991px) {\\n  #side-projects dd {\\n    margin-left: 18px; } }\\n\\n@media (min-width: 992px) and (max-width: 1199px) {\\n  #side-projects dd {\\n    margin-left: 27px; } }\\n\\n@media (min-width: 1200px) {\\n  #side-projects dd {\\n    margin-left: 27px; } }\\n\", \"\", {\"version\":3,\"sources\":[\"/home/phil/git-repos/personal/personal-home2/client/scss/client/scss/fonts.scss\",\"/home/phil/git-repos/personal/personal-home2/client/scss/client/scss/main.scss\",\"/home/phil/git-repos/personal/personal-home2/client/scss/client/scss/variables.scss\",\"/home/phil/git-repos/personal/personal-home2/client/scss/client/scss/mixins.scss\",\"/home/phil/git-repos/personal/personal-home2/client/scss/client/scss/partials/footer.scss\",\"/home/phil/git-repos/personal/personal-home2/client/scss/client/scss/partials/header.scss\",\"/home/phil/git-repos/personal/personal-home2/client/scss/client/scss/partials/side-projects.scss\"],\"names\":[],\"mappings\":\"AAAA;EACC,sBAAqB;EACrB,iBAAgB;EAChB,kDAAwD,EAAA;;AAEzD;EACC,yBAAwB;EACxB,iBAAgB;EAChB,kDAAwD,EAAA;;AAEzD;EACC,yBAAwB;EACxB,iBAAgB;EACf,mBAAkB;EACnB,kDAAuD,EAAA;;ACdxD;;EAEE,kBCEQ;EDDR,eCGU;EDFV,qCAAoC;EACpC,gBCoBc,EDnBf;;AAED;EACE,cAAa;EACb,uBAAsB;EACtB,kBAAiB,EAKlB;EARD;IAMI,aAAY,EACb;;AAGH;;;;EAIE,6BAA4B,EAC7B;;AAED;;;;;;EAME,iBAAgB,EACjB;;AAED;;;;;;;;;;;EAWE,UAAS;EACT,WAAU,EACX;;AAED;;;;;;;EAOE,eAAc,EACf;;AAED;EACE,UAAS;EACT,yBAAwB;EACxB,iBAAgB;EAChB,sBAAqB;EACrB,aAAY,EACb;;AAED;EACE,iBAAgB,EACjB;;AAED;EACE,gBClCY,EDmCb;;AACD;EACE,gBCpCY,EDqCb;;AACD;EACE,gBCtCY,EDuCb;;AACD;EACE,gBCxCY,EDyCb;;AACD;EACE,gBC1CY;ED2CZ,mBCnDoB,EDoDrB;;AAED;EACE,eClFY;EDmFZ,sBAAqB,EACtB;;AAED;EACE,mBAAkB,EACnB;;AE9FC;EFgGF;;;IE9FM,gBAAU,EFyGf,EAAA;;AEtGC;EF2FF;;;IEzFM,gBAAU,EFoGf,EAAA;;AEjGC;EFsFF;;;IEpFM,gBAAU,EF+Ff,EAAA;;AE5FC;EFiFF;;;IE/EM,gBAAU,EF0Ff,EAAA;;AEvFC;EF4EF;;;IE1EM,gBAAU,EFqFf,EAAA;;AAED;;EAEE,iBAAgB,EACjB;;AAED;EACE,eAAc;EACd,kBC7FiB,EDgGlB;EEvHC;IFkHF;MEhHM,mBAAU;MAAV,oBAAU,EFqHf,EAAA;EElHC;IF6GF;ME3GM,mBAAU;MAAV,oBAAU,EFgHf,EAAA;EE7GC;IFwGF;MEtGM,mBAAU;MAAV,oBAAU,EF2Gf,EAAA;EExGC;IFmGF;MEjGM,mBAAU;MAAV,oBAAU,EFsGf,EAAA;EEnGC;IF8FF;ME5FM,mBAAU;MAAV,oBAAU,EFiGf,EAAA;;AEvHC;EFyHF;IEvHM,iBAAU,EF2Jf,EAAA;;AExJC;EFoHF;IElHM,iBAAU,EFsJf,EAAA;;AEnJC;EF+GF;IE7GM,iBAAU,EFiJf,EAAA;;AE9IC;EF0GF;IExGM,iBAAU,EF4If,EAAA;;AEzIC;EFqGF;IEnGM,iBAAU,EFuIf,EAAA;;AApCD;EAII,eCtHY;ED+HZ,oBC9GY,ED+Gb;EEvID;IFyHF;MEvHM,gBAAU,EFqIb,EAAA;EElID;IFoHF;MElHM,gBAAU,EFgIb,EAAA;EE7HD;IF+GF;ME7GM,gBAAU,EF2Hb,EAAA;EExHD;IF0GF;MExGM,gBAAU,EFsHb,EAAA;EEnHD;IFqGF;MEnGM,gBAAU,EFiHb,EAAA;;AAdH;EAiBI,iBC3G8B,ED4G/B;;AAlBH;EAoBI,iBCrHY,EDsHb;;AArBH;EAuBI,gBC/GkB,EDgHnB;;AAxBH;EA0BI,iBC3HY,ED4Hb;;AA3BH;EA8BI,mBCtHkB,ED2HnB;EAnCH;IAiCM,eAAc,EACf;;AAIL;EACE,aCtGqC;EDuGrC,YCvGqC,EDwGtC;;AAED;EACE,mBAAkB,EACnB;;AAED;EACE,yCAAwC,EACzC;;AG3KD;EAGE,0BFcoB;EEbpB,aFAQ;EECR,mBAAkB,EAgCnB;EDpCC;ICDF;MDGM,aAAU;MAAV,kBAAU,ECkCf,EAAA;ED/BC;ICNF;MDQM,aAAU;MAAV,kBAAU,EC6Bf,EAAA;ED1BC;ICXF;MDaM,cAAU;MAAV,mBAAU,ECwBf,EAAA;EDrBC;IChBF;MDkBM,cAAU;MAAV,mBAAU,ECmBf,EAAA;EDhBC;ICrBF;MDuBM,cAAU;MAAV,mBAAU,ECcf,EAAA;EDpCC;ICDF;MDGM,iBAAU,ECkCf,EAAA;ED/BC;ICNF;MDQM,iBAAU,EC6Bf,EAAA;ED1BC;ICXF;MDaM,iBAAU,ECwBf,EAAA;EDrBC;IChBF;MDkBM,iBAAU,ECmBf,EAAA;EDhBC;ICrBF;MDuBM,iBAAU,ECcf,EAAA;EArCD;IAkBI,uBAAsB,EACvB;IDlBD;MCDF;QDGM,mBAAU,ECgBb,EAAA;IDbD;MCNF;QDQM,mBAAU,ECWb,EAAA;IDRD;MCXF;QDaM,mBAAU,ECMb,EAAA;IDHD;MChBF;QDkBM,mBAAU,ECCb,EAAA;IDED;MCrBF;QDuBM,mBAAU,ECJb,EAAA;IDlBD;MCDF;QDGM,gBAAU,ECgBb,EAAA;IDbD;MCNF;QDQM,gBAAU,ECWb,EAAA;IDRD;MCXF;QDaM,gBAAU,ECMb,EAAA;IDHD;MChBF;QDkBM,gBAAU,ECCb,EAAA;IDED;MCrBF;QDuBM,gBAAU,ECJb,EAAA;EAnBH;IAsBI,uBAAsB,EAcvB;IDnCD;MCDF;QDGM,aAAU,ECiCb,EAAA;ID9BD;MCNF;QDQM,aAAU,EC4Bb,EAAA;IDzBD;MCXF;QDaM,aAAU,ECuBb,EAAA;IDpBD;MChBF;QDkBM,aAAU,ECkBb,EAAA;IDfD;MCrBF;QDuBM,aAAU,ECab,EAAA;IDnCD;MCDF;QDGM,iBAAU;QAAV,oBAAU,ECiCb,EAAA;ID9BD;MCNF;QDQM,iBAAU;QAAV,oBAAU,EC4Bb,EAAA;IDzBD;MCXF;QDaM,iBAAU;QAAV,oBAAU,ECuBb,EAAA;IDpBD;MChBF;QDkBM,iBAAU;QAAV,oBAAU,ECkBb,EAAA;IDfD;MCrBF;QDuBM,iBAAU;QAAV,oBAAU,ECab,EAAA;IApCH;MAkCM,YF9BI,EE+BL;;ACnCL;EAEE,mBAAkB,EA0CnB;EF3CC;IEDF;MFGM,iBAAU,EEyCf,EAAA;EFtCC;IENF;MFQM,iBAAU,EEoCf,EAAA;EFjCC;IEXF;MFaM,iBAAU,EE+Bf,EAAA;EF5BC;IEhBF;MFkBM,iBAAU,EE0Bf,EAAA;EFvBC;IErBF;MFuBM,iBAAU,EEqBf,EAAA;EA5CD;IAKI,oBHoBY,EGnBb;EANH;IAUI,oBHeY,EGdb;IFVD;MEDF;QFGM,cAAU,EEQb,EAAA;IFLD;MENF;QFQM,cAAU,EEGb,EAAA;IFAD;MEXF;QFaM,cAAU,EEFb,EAAA;IFKD;MEhBF;QFkBM,cAAU,EEPb,EAAA;IFUD;MErBF;QFuBM,cAAU,EEZb,EAAA;EFVD;IEDF;MFGM,oBAAU,EEYb,EAAA;EFTD;IENF;MFQM,oBAAU,EEOb,EAAA;EFJD;IEXF;MFaM,oBAAU,EEEb,EAAA;EFCD;IEhBF;MFkBM,oBAAU,EEHb,EAAA;EFMD;IErBF;MFuBM,oBAAU,EERb,EAAA;EAfH;IAmBI,mBAAkB,EAGnB;IFrBD;MEDF;QFGM,oBAAU,EEmBb,EAAA;IFhBD;MENF;QFQM,oBAAU,EEcb,EAAA;IFXD;MEXF;QFaM,oBAAU,EESb,EAAA;IFND;MEhBF;QFkBM,oBAAU,EEIb,EAAA;IFDD;MErBF;QFuBM,oBAAU,EEDb,EAAA;IFrBD;MEDF;QFGM,gBAAU,EEmBb,EAAA;IFhBD;MENF;QFQM,gBAAU,EEcb,EAAA;IFXD;MEXF;QFaM,gBAAU,EESb,EAAA;IFND;MEhBF;QFkBM,gBAAU,EEIb,EAAA;IFDD;MErBF;QFuBM,gBAAU,EEDb,EAAA;EAtBH;IA0BI,6BAA4B,EAiB7B;IF1CD;MEDF;QFGM,gBAAU,EEwCb,EAAA;IFrCD;MENF;QFQM,gBAAU,EEmCb,EAAA;IFhCD;MEXF;QFaM,gBAAU,EE8Bb,EAAA;IF3BD;MEhBF;QFkBM,gBAAU,EEyBb,EAAA;IFtBD;MErBF;QFuBM,gBAAU,EEoBb,EAAA;IAfC;MA5BJ;QA8BQ,iBHLQ,EGMT,EAAA;IAGH;MAlCJ;QAoCQ,sBAAqB,EACtB;MArCP;QAuCQ,aAAY,EAEb,EAAA;EFxCL;IEDF;MFGM,iBAAU;MAAV,kBAAU,EEsCT,EAAA;EFnCL;IENF;MFQM,kBAAU;MAAV,mBAAU,EEiCT,EAAA;EF9BL;IEXF;MFaM,kBAAU;MAAV,mBAAU,EE4BT,EAAA;EFzBL;IEhBF;MFkBM,kBAAU;MAAV,mBAAU,EEuBT,EAAA;EFpBL;IErBF;MFuBM,kBAAU;MAAV,mBAAU,EEkBT,EAAA;;ACzCP;EAEI,oBJuBY,EItBb;;AAHH;EAMI,gBJ4BkB,EI3BnB;;AAPH;EAUI,iBJsB8B,EIrB/B;;AAXH;;;EAgBI,oBAAmB;EACnB,cAAa;EACb,iBAAgB;EAChB,yBAAwB;EACxB,iBJckB;EIblB,oBJakB;EIZlB,sBAAqB;EACrB,mBAAkB,EA6BnB;EHnDD;IGDF;;;MHGM,kBAAU,EGiDb,EAAA;EH9CD;IGNF;;;MHQM,mBAAU,EG4Cb,EAAA;EHzCD;IGXF;;;MHaM,mBAAU,EGuCb,EAAA;EHpCD;IGhBF;;;MHkBM,mBAAU,EGkCb,EAAA;EH/BD;IGrBF;;;MHuBM,mBAAU,EG6Bb,EAAA;EHnDD;IGDF;;;MHGM,mBAAU,EGiDb,EAAA;EH9CD;IGNF;;;MHQM,oBAAU,EG4Cb,EAAA;EHzCD;IGXF;;;MHaM,oBAAU,EGuCb,EAAA;EHpCD;IGhBF;;;MHkBM,oBAAU,EGkCb,EAAA;EH/BD;IGrBF;;;MHuBM,oBAAU,EG6Bb,EAAA;EHnDD;IGDF;;;MHGM,uBAAU,EGiDb,EAAA;EH9CD;IGNF;;;MHQM,uBAAU,EG4Cb,EAAA;EHzCD;IGXF;;;MHaM,uBAAU,EGuCb,EAAA;EHpCD;IGhBF;;;MHkBM,uBAAU,EGkCb,EAAA;EH/BD;IGrBF;;;MHuBM,uBAAU,EG6Bb,EAAA;EApDH;;;IAoCM,cAAa,EACd;EAED;IAvCJ;;;MAyCQ,mBAAkB;MAClB,YAAW;MACX,OAAM;MACN,SAAQ;MACR,SAAQ;MACR,UAAS;MACT,qCAAmD;MACnD,wCAAsD;MACtD,8BJ7CE,EI8CH,EAAA;;AAlDP;EAuDI,2BJ7CiB;EI8CjB,wCJ7CmC,EIsDpC;EAjEH;IA2DM,gBAAe,EAKhB;IAhEL;MA8DQ,cJpDa,EIqDd;;AA/DP;EAoEI,2BJxDU;EIyDV,yCJxD0B,EIiE3B;EA9EH;IAwEM,gBAAe,EAKhB;IA7EL;MA2EQ,cJ/DM,EIgEP;;AA5EP;EAiFI,2BJnEa;EIoEb,0CJnEiC,EI4ElC;EA3FH;IAqFM,gBAAe,EAKhB;IA1FL;MAwFQ,cJ1ES,EI2EV;;AHxFL;EGDF;IHGM,kBAAU,EG4Fb,EAAA;;AHzFD;EGNF;IHQM,kBAAU,EGuFb,EAAA;;AHpFD;EGXF;IHaM,kBAAU,EGkFb,EAAA;;AH/ED;EGhBF;IHkBM,kBAAU,EG6Eb,EAAA;;AH1ED;EGrBF;IHuBM,kBAAU,EGwEb,EAAA;;AA/FH;EAkGI,UAAS;EACT,iBAAgB,EAajB;EH/GD;IGDF;MHGM,iBAAU,EG6Gb,EAAA;EH1GD;IGNF;MHQM,iBAAU,EGwGb,EAAA;EHrGD;IGXF;MHaM,kBAAU,EGmGb,EAAA;EHhGD;IGhBF;MHkBM,kBAAU,EG8Fb,EAAA;EH3FD;IGrBF;MHuBM,kBAAU,EGyFb,EAAA;EAhHH;IAuGM,eAAc,EAQf;IA/GL;MA0GQ,iBJjFQ,EIkFT;IA3GP;MA6GQ,gBJ3Ec,EI4Ef;;AH7GL;EGDF;IHGM,gBAAU,EGiHb,EAAA;;AH9GD;EGNF;IHQM,gBAAU,EG4Gb,EAAA;;AHzGD;EGXF;IHaM,iBAAU,EGuGb,EAAA;;AHpGD;EGhBF;IHkBM,iBAAU,EGkGb,EAAA;;AH/FD;EGrBF;IHuBM,iBAAU,EG6Fb,EAAA;;AApHH;EAsHI,cAAa,EACd;;AHtHD;EGDF;IHGM,gBAAU,EGwHb,EAAA;;AHrHD;EGNF;IHQM,gBAAU,EGmHb,EAAA;;AHhHD;EGXF;IHaM,gBAAU,EG8Gb,EAAA;;AH3GD;EGhBF;IHkBM,gBAAU,EGyGb,EAAA;;AHtGD;EGrBF;IHuBM,gBAAU,EGoGb,EAAA;;AH1HD;EGDF;IHGM,kBAAU,EGwHb,EAAA;;AHrHD;EGNF;IHQM,kBAAU,EGmHb,EAAA;;AHhHD;EGXF;IHaM,kBAAU,EG8Gb,EAAA;;AH3GD;EGhBF;IHkBM,kBAAU,EGyGb,EAAA;;AHtGD;EGrBF;IHuBM,kBAAU,EGoGb,EAAA\",\"file\":\"index.scss\",\"sourcesContent\":[\"@font-face{\\n\\tfont-family: ScopeOne;\\n\\tfont-weight: 400;\\n\\tsrc: url(../fonts/scope-one.regular.woff) format(\\\"woff\\\");\\n}\\n@font-face{\\n\\tfont-family: 'Open Sans';\\n\\tfont-weight: 400;\\n\\tsrc: url(../fonts/open-sans.regular.woff) format(\\\"woff\\\");\\n}\\n@font-face{\\n\\tfont-family: 'Open Sans';\\n\\tfont-weight: 400;\\n  font-style: italic;\\n\\tsrc: url(../fonts/open-sans.italic.woff) format(\\\"woff\\\");\\n}\\n\",\"html,\\nbody {\\n  background: $bg;\\n  color: $fg;\\n  font-family: 'Open Sans', sans-serif;\\n  font-size: $font-base;\\n}\\n\\nbody {\\n  display: flex;\\n  flex-direction: column;\\n  min-height: 100vh;\\n\\n  > .site-container {\\n    flex-grow: 1;\\n  }\\n}\\n\\nh1,\\nh2,\\nh3,\\nh4 {\\n  font-family: ScopeOne, serif;\\n}\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  font-weight: 400;\\n}\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\np,\\nul,\\nol,\\nli,\\nbutton {\\n  margin: 0;\\n  padding: 0;\\n}\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\nli {\\n  line-height: 1;\\n}\\n\\nbutton {\\n  border: 0;\\n  outline: none !important;\\n  background: none;\\n  border-image-width: 0;\\n  font-size: 0;\\n}\\n\\np {\\n  line-height: 1.3;\\n}\\n\\nh1 {\\n  font-size: $font-h1;\\n}\\nh2 {\\n  font-size: $font-xl;\\n}\\nh3 {\\n  font-size: $font-lg;\\n}\\nh4 {\\n  font-size: $font-md;\\n}\\nh5 {\\n  font-size: $font-sm;\\n  margin-bottom: $xxs;\\n}\\n\\na {\\n  color: $link;\\n  text-decoration: none;\\n}\\n\\np.note {\\n  font-style: italic;\\n}\\n\\np,\\ndd,\\ndt {\\n  @include per-size(\\n    'font-size',\\n    $font-xs,\\n    $font-xs,\\n    $font-base,\\n    $font-base,\\n    $font-base\\n  );\\n}\\n\\nul:not(.normal-list),\\nol:not(.normal-list) {\\n  list-style: none;\\n}\\n\\n.site-container {\\n  margin: 0 auto;\\n  max-width: $site-width;\\n\\n  @include per-size(('padding-left', 'padding-right'), $xs, $xs, $sm, $md, $lg);\\n}\\n\\nmain > section {\\n  @include per-size('margin-top', $md, $md, $lg, $lg, $lg);\\n\\n  h3 {\\n    color: $accent;\\n    @include per-size(\\n      'font-size',\\n      $font-lg,\\n      $font-lg,\\n      $font-xl,\\n      $font-xl,\\n      $font-xl\\n    );\\n    margin-bottom: $xs;\\n  }\\n\\n  h4 {\\n    margin-top: $sm;\\n  }\\n  h5 {\\n    margin-top: $xs;\\n  }\\n  p + p {\\n    margin-top: $xxs;\\n  }\\n  p + ul {\\n    margin-top: $xs;\\n  }\\n\\n  h4 {\\n    margin-bottom: $xxs;\\n\\n    &:before {\\n      content: ' - ';\\n    }\\n  }\\n}\\n\\nbutton.expander > svg {\\n  height: $project-height;\\n  width: $project-height;\\n}\\n\\n.sidenote {\\n  font-style: italic;\\n}\\n\\nbutton {\\n  -webkit-tap-highlight-color: transparent;\\n}\\n\",\"//--------//\\n// Colors //\\n//--------//\\n\\n$bg: white;\\n$bg-off: #e9e9e9;\\n$fg: #131313;\\n$link: #2457b0;\\n$accent: #a32500;\\n\\n$application: #19610d;\\n$application-bg: fade_out(#1abd00, 0.7);\\n$tool: #f0a300;\\n$tool-bg: fade_out($tool, 0.7);\\n$library: #84008a;\\n$library-bg: fade_out($library, 0.85);\\n\\n$footer-color: #303030;\\n\\n//\\n//-------//\\n// Sizes //\\n//-------//\\n\\n$site-width: 1100px;\\n$font-base: 18px;\\n\\n// general purpose element spacing\\n\\n$xl: round($font-base * 3.5);\\n$lg: ($font-base * 3);\\n$md: ($font-base * 2);\\n$sm: $font-base + ($font-base / 2);\\n$xs: $font-base;\\n$xxs: ($font-base / 2);\\n\\n// font-sizes\\n\\n$font-h1: 48px;\\n$font-xl: 32px;\\n$font-lg: 26px;\\n$font-md: 23px;\\n$font-sm: 20px;\\n$font-xs: 16px;\\n$font-xxs: 15px;\\n\\n// slightly modified from bootstrap\\n$screen-xs-min: 480px;\\n$screen-sm-min: 768px;\\n$screen-md-min: 992px;\\n$screen-lg-min: 1200px;\\n\\n$screen-xxs-max: ($screen-xs-min - 1);\\n$screen-xs-max: ($screen-sm-min - 1);\\n$screen-sm-max: ($screen-md-min - 1);\\n$screen-md-max: ($screen-lg-min - 1);\\n\\n// context-specific\\n\\n$project-height: $xxs + $xxs + $font-md;\\n\",\"@mixin per-size($prop-list, $xxs, $xs, $sm, $md, $lg, $unit: null) {\\n  @media (max-width: $screen-xxs-max) {\\n    @each $prop in $prop-list {\\n      #{$prop}: #{$xxs}#{$unit};\\n    }\\n  }\\n  @media (min-width: $screen-xs-min) and (max-width: $screen-xs-max) {\\n    @each $prop in $prop-list {\\n      #{$prop}: #{$xs}#{$unit};\\n    }\\n  }\\n  @media (min-width: $screen-sm-min) and (max-width: $screen-sm-max) {\\n    @each $prop in $prop-list {\\n      #{$prop}: #{$sm}#{$unit};\\n    }\\n  }\\n  @media (min-width: $screen-md-min) and (max-width: $screen-md-max) {\\n    @each $prop in $prop-list {\\n      #{$prop}: #{$md}#{$unit};\\n    }\\n  }\\n  @media (min-width: $screen-lg-min) {\\n    @each $prop in $prop-list {\\n      #{$prop}: #{$lg}#{$unit};\\n    }\\n  }\\n}\\n\",\"footer {\\n  @include per-size(('height', 'line-height'), 80, 80, 110, 110, 110, 'px');\\n  @include per-size('margin-top', $md, $md, $lg, $lg, $lg);\\n  background-color: $footer-color;\\n  color: $bg;\\n  text-align: center;\\n\\n  .email {\\n    @include per-size(('margin-right'), 20, 20, 30, 30, 30, 'px');\\n    @include per-size(\\n      'font-size',\\n      $font-xxs,\\n      $font-xxs,\\n      $font-xs,\\n      $font-xs,\\n      $font-xs\\n    );\\n\\n    vertical-align: middle;\\n  }\\n\\n  .octicon {\\n    vertical-align: middle;\\n    @include per-size('height', 50, 50, 70, 70, 70, 'px');\\n    @include per-size(\\n      ('margin-top', 'margin-bottom'),\\n      10,\\n      10,\\n      15,\\n      15,\\n      15,\\n      'px'\\n    );\\n    path {\\n      fill: $bg;\\n    }\\n  }\\n}\\n\",\"header {\\n  @include per-size('margin-top', $sm, $sm, $md, $lg, $xl);\\n  text-align: center;\\n\\n  h1 {\\n    margin-bottom: $xs;\\n  }\\n\\n  img {\\n    @include per-size('height', '180', '180', '180', '220', '220', 'px');\\n    margin-bottom: $xs;\\n  }\\n\\n  h3 {\\n    @include per-size('margin-bottom', $sm, $sm, $md, $md, $md);\\n  }\\n\\n  p {\\n    @include per-size('margin-bottom', $sm, $sm, $md, $md, $md);\\n    font-style: italic;\\n\\n    @include per-size('font-size', $font-xxs, $font-xs, $font-base, $font-base, $font-base);\\n  }\\n\\n  nav {\\n    @include per-size('font-size', $font-lg, $font-lg, $font-xl, $font-xl, $font-xl);\\n    font-family: ScopeOne, serif;\\n\\n    @media (max-width: $screen-sm-max) {\\n      li + li {\\n        margin-top: $xs;\\n      }\\n    }\\n\\n    @media (min-width: $screen-md-min) {\\n      li {\\n        display: inline-block;\\n      }\\n      li + li:before {\\n        content: \\\"/\\\";\\n        @include per-size(('margin-left', 'margin-right'), $xxs, $xs, $xs, $sm, $sm);\\n      }\\n    }\\n  }\\n}\\n\",\"#side-projects {\\n  h4 {\\n    margin-bottom: $xs;\\n  }\\n\\n  ul.legend > li + li {\\n    margin-top: $xxs;\\n  }\\n\\n  > ul:not(.legend) > li + li {\\n    margin-top: $sm;\\n  }\\n\\n  .application,\\n  .tool,\\n  .library {\\n    vertical-align: top;\\n    margin-top: 0;\\n    margin-bottom: 0;\\n    border-left-style: solid;\\n    padding-top: $xxs;\\n    padding-bottom: $xxs;\\n    display: inline-block;\\n    position: relative;\\n    @include per-size('padding-left', $xxs, $md, $md, $lg, $lg);\\n    @include per-size(\\n      'padding-right',\\n      $xxs,\\n      ($md + $xxs),\\n      ($md + $xxs),\\n      ($lg + $xxs),\\n      ($lg + $xxs)\\n    );\\n    @include per-size('border-left-width', 2, 2, 3, 3, 3, 'px');\\n\\n    &:before {\\n      content: none;\\n    }\\n\\n    @media (min-width: $screen-xs-min) {\\n      &:after {\\n        position: absolute;\\n        content: '';\\n        top: 0;\\n        right: 0;\\n        width: 0;\\n        height: 0;\\n        border-top: ($project-height / 2) solid transparent;\\n        border-bottom: ($project-height / 2) solid transparent;\\n        border-right: $xxs solid $bg;\\n      }\\n    }\\n  }\\n\\n  .application {\\n    border-left-color: $application;\\n    background-color: $application-bg;\\n\\n    + button {\\n      cursor: pointer;\\n\\n      svg path {\\n        fill: $application;\\n      }\\n    }\\n  }\\n\\n  .tool {\\n    border-left-color: $tool;\\n    background-color: $tool-bg;\\n\\n    + button {\\n      cursor: pointer;\\n\\n      svg path {\\n        fill: $tool;\\n      }\\n    }\\n  }\\n\\n  .library {\\n    border-left-color: $library;\\n    background-color: $library-bg;\\n\\n    + button {\\n      cursor: pointer;\\n\\n      svg path {\\n        fill: $library;\\n      }\\n    }\\n  }\\n\\n  button {\\n    @include per-size('margin-left', $xs, $sm, $sm, $md, $md);\\n  }\\n\\n  .content {\\n    height: 0;\\n    overflow: hidden;\\n    @include per-size('margin-left', $xxs, $xxs, $xs, $xs, $xs);\\n\\n    > a {\\n      display: block;\\n\\n      &:first-child {\\n        margin-top: $xs;\\n      }\\n      &:not(:first-child) {\\n        margin-top: $xxs;\\n      }\\n    }\\n  }\\n\\n  dd + dt {\\n    @include per-size('margin-top', $xxs, $xxs, $xs, $xs, $xs);\\n  }\\n  dt:before {\\n    content: '- ';\\n  }\\n  dd {\\n    @include per-size('margin-top', 3, 3, 4, 4, 5, 'px');\\n    @include per-size('margin-left', $xs, $xs, $xs, $sm, $sm);\\n  }\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS04LTEhLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS04LTIhLi9jbGllbnQvc2Nzcy9pbmRleC5zY3NzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vY2xpZW50L3Njc3MvaW5kZXguc2Nzcz9kYTFjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBlc2NhcGUgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL3VybC9lc2NhcGUuanNcIik7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGltcG9ydCB1cmwoL25vZGVfbW9kdWxlcy9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3MpO1wiLCBcIlwiXSk7XG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGZvbnQtZmFjZSB7XFxuICBmb250LWZhbWlseTogU2NvcGVPbmU7XFxuICBmb250LXdlaWdodDogNDAwO1xcbiAgc3JjOiB1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4uL2ZvbnRzL3Njb3BlLW9uZS5yZWd1bGFyLndvZmZcIikpICsgXCIpIGZvcm1hdChcXFwid29mZlxcXCIpOyB9XFxuXFxuQGZvbnQtZmFjZSB7XFxuICBmb250LWZhbWlseTogJ09wZW4gU2Fucyc7XFxuICBmb250LXdlaWdodDogNDAwO1xcbiAgc3JjOiB1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4uL2ZvbnRzL29wZW4tc2Fucy5yZWd1bGFyLndvZmZcIikpICsgXCIpIGZvcm1hdChcXFwid29mZlxcXCIpOyB9XFxuXFxuQGZvbnQtZmFjZSB7XFxuICBmb250LWZhbWlseTogJ09wZW4gU2Fucyc7XFxuICBmb250LXdlaWdodDogNDAwO1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcbiAgc3JjOiB1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4uL2ZvbnRzL29wZW4tc2Fucy5pdGFsaWMud29mZlwiKSkgKyBcIikgZm9ybWF0KFxcXCJ3b2ZmXFxcIik7IH1cXG5cXG5odG1sLFxcbmJvZHkge1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxuICBjb2xvcjogIzEzMTMxMztcXG4gIGZvbnQtZmFtaWx5OiAnT3BlbiBTYW5zJywgc2Fucy1zZXJpZjtcXG4gIGZvbnQtc2l6ZTogMThweDsgfVxcblxcbmJvZHkge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBtaW4taGVpZ2h0OiAxMDB2aDsgfVxcbiAgYm9keSA+IC5zaXRlLWNvbnRhaW5lciB7XFxuICAgIGZsZXgtZ3JvdzogMTsgfVxcblxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0IHtcXG4gIGZvbnQtZmFtaWx5OiBTY29wZU9uZSwgc2VyaWY7IH1cXG5cXG5oMSxcXG5oMixcXG5oMyxcXG5oNCxcXG5oNSxcXG5oNiB7XFxuICBmb250LXdlaWdodDogNDAwOyB9XFxuXFxuaDEsXFxuaDIsXFxuaDMsXFxuaDQsXFxuaDUsXFxuaDYsXFxucCxcXG51bCxcXG5vbCxcXG5saSxcXG5idXR0b24ge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDsgfVxcblxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0LFxcbmg1LFxcbmg2LFxcbmxpIHtcXG4gIGxpbmUtaGVpZ2h0OiAxOyB9XFxuXFxuYnV0dG9uIHtcXG4gIGJvcmRlcjogMDtcXG4gIG91dGxpbmU6IG5vbmUgIWltcG9ydGFudDtcXG4gIGJhY2tncm91bmQ6IG5vbmU7XFxuICBib3JkZXItaW1hZ2Utd2lkdGg6IDA7XFxuICBmb250LXNpemU6IDA7IH1cXG5cXG5wIHtcXG4gIGxpbmUtaGVpZ2h0OiAxLjM7IH1cXG5cXG5oMSB7XFxuICBmb250LXNpemU6IDQ4cHg7IH1cXG5cXG5oMiB7XFxuICBmb250LXNpemU6IDMycHg7IH1cXG5cXG5oMyB7XFxuICBmb250LXNpemU6IDI2cHg7IH1cXG5cXG5oNCB7XFxuICBmb250LXNpemU6IDIzcHg7IH1cXG5cXG5oNSB7XFxuICBmb250LXNpemU6IDIwcHg7XFxuICBtYXJnaW4tYm90dG9tOiA5cHg7IH1cXG5cXG5hIHtcXG4gIGNvbG9yOiAjMjQ1N2IwO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuXFxucC5ub3RlIHtcXG4gIGZvbnQtc3R5bGU6IGl0YWxpYzsgfVxcblxcbkBtZWRpYSAobWF4LXdpZHRoOiA0NzlweCkge1xcbiAgcCxcXG4gIGRkLFxcbiAgZHQge1xcbiAgICBmb250LXNpemU6IDE2cHg7IH0gfVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA0ODBweCkgYW5kIChtYXgtd2lkdGg6IDc2N3B4KSB7XFxuICBwLFxcbiAgZGQsXFxuICBkdCB7XFxuICAgIGZvbnQtc2l6ZTogMTZweDsgfSB9XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1heC13aWR0aDogOTkxcHgpIHtcXG4gIHAsXFxuICBkZCxcXG4gIGR0IHtcXG4gICAgZm9udC1zaXplOiAxOHB4OyB9IH1cXG5cXG5AbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIGFuZCAobWF4LXdpZHRoOiAxMTk5cHgpIHtcXG4gIHAsXFxuICBkZCxcXG4gIGR0IHtcXG4gICAgZm9udC1zaXplOiAxOHB4OyB9IH1cXG5cXG5AbWVkaWEgKG1pbi13aWR0aDogMTIwMHB4KSB7XFxuICBwLFxcbiAgZGQsXFxuICBkdCB7XFxuICAgIGZvbnQtc2l6ZTogMThweDsgfSB9XFxuXFxudWw6bm90KC5ub3JtYWwtbGlzdCksXFxub2w6bm90KC5ub3JtYWwtbGlzdCkge1xcbiAgbGlzdC1zdHlsZTogbm9uZTsgfVxcblxcbi5zaXRlLWNvbnRhaW5lciB7XFxuICBtYXJnaW46IDAgYXV0bztcXG4gIG1heC13aWR0aDogMTEwMHB4OyB9XFxuICBAbWVkaWEgKG1heC13aWR0aDogNDc5cHgpIHtcXG4gICAgLnNpdGUtY29udGFpbmVyIHtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IDE4cHg7XFxuICAgICAgcGFkZGluZy1yaWdodDogMThweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogNDgwcHgpIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcbiAgICAuc2l0ZS1jb250YWluZXIge1xcbiAgICAgIHBhZGRpbmctbGVmdDogMThweDtcXG4gICAgICBwYWRkaW5nLXJpZ2h0OiAxOHB4OyB9IH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkgYW5kIChtYXgtd2lkdGg6IDk5MXB4KSB7XFxuICAgIC5zaXRlLWNvbnRhaW5lciB7XFxuICAgICAgcGFkZGluZy1sZWZ0OiAyN3B4O1xcbiAgICAgIHBhZGRpbmctcmlnaHQ6IDI3cHg7IH0gfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDk5MnB4KSBhbmQgKG1heC13aWR0aDogMTE5OXB4KSB7XFxuICAgIC5zaXRlLWNvbnRhaW5lciB7XFxuICAgICAgcGFkZGluZy1sZWZ0OiAzNnB4O1xcbiAgICAgIHBhZGRpbmctcmlnaHQ6IDM2cHg7IH0gfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDEyMDBweCkge1xcbiAgICAuc2l0ZS1jb250YWluZXIge1xcbiAgICAgIHBhZGRpbmctbGVmdDogNTRweDtcXG4gICAgICBwYWRkaW5nLXJpZ2h0OiA1NHB4OyB9IH1cXG5cXG5AbWVkaWEgKG1heC13aWR0aDogNDc5cHgpIHtcXG4gIG1haW4gPiBzZWN0aW9uIHtcXG4gICAgbWFyZ2luLXRvcDogMzZweDsgfSB9XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDQ4MHB4KSBhbmQgKG1heC13aWR0aDogNzY3cHgpIHtcXG4gIG1haW4gPiBzZWN0aW9uIHtcXG4gICAgbWFyZ2luLXRvcDogMzZweDsgfSB9XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1heC13aWR0aDogOTkxcHgpIHtcXG4gIG1haW4gPiBzZWN0aW9uIHtcXG4gICAgbWFyZ2luLXRvcDogNTRweDsgfSB9XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDk5MnB4KSBhbmQgKG1heC13aWR0aDogMTE5OXB4KSB7XFxuICBtYWluID4gc2VjdGlvbiB7XFxuICAgIG1hcmdpbi10b3A6IDU0cHg7IH0gfVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiAxMjAwcHgpIHtcXG4gIG1haW4gPiBzZWN0aW9uIHtcXG4gICAgbWFyZ2luLXRvcDogNTRweDsgfSB9XFxuXFxubWFpbiA+IHNlY3Rpb24gaDMge1xcbiAgY29sb3I6ICNhMzI1MDA7XFxuICBtYXJnaW4tYm90dG9tOiAxOHB4OyB9XFxuICBAbWVkaWEgKG1heC13aWR0aDogNDc5cHgpIHtcXG4gICAgbWFpbiA+IHNlY3Rpb24gaDMge1xcbiAgICAgIGZvbnQtc2l6ZTogMjZweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogNDgwcHgpIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcbiAgICBtYWluID4gc2VjdGlvbiBoMyB7XFxuICAgICAgZm9udC1zaXplOiAyNnB4OyB9IH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkgYW5kIChtYXgtd2lkdGg6IDk5MXB4KSB7XFxuICAgIG1haW4gPiBzZWN0aW9uIGgzIHtcXG4gICAgICBmb250LXNpemU6IDMycHg7IH0gfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDk5MnB4KSBhbmQgKG1heC13aWR0aDogMTE5OXB4KSB7XFxuICAgIG1haW4gPiBzZWN0aW9uIGgzIHtcXG4gICAgICBmb250LXNpemU6IDMycHg7IH0gfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDEyMDBweCkge1xcbiAgICBtYWluID4gc2VjdGlvbiBoMyB7XFxuICAgICAgZm9udC1zaXplOiAzMnB4OyB9IH1cXG5cXG5tYWluID4gc2VjdGlvbiBoNCB7XFxuICBtYXJnaW4tdG9wOiAyN3B4OyB9XFxuXFxubWFpbiA+IHNlY3Rpb24gaDUge1xcbiAgbWFyZ2luLXRvcDogMThweDsgfVxcblxcbm1haW4gPiBzZWN0aW9uIHAgKyBwIHtcXG4gIG1hcmdpbi10b3A6IDlweDsgfVxcblxcbm1haW4gPiBzZWN0aW9uIHAgKyB1bCB7XFxuICBtYXJnaW4tdG9wOiAxOHB4OyB9XFxuXFxubWFpbiA+IHNlY3Rpb24gaDQge1xcbiAgbWFyZ2luLWJvdHRvbTogOXB4OyB9XFxuICBtYWluID4gc2VjdGlvbiBoNDpiZWZvcmUge1xcbiAgICBjb250ZW50OiAnIC0gJzsgfVxcblxcbmJ1dHRvbi5leHBhbmRlciA+IHN2ZyB7XFxuICBoZWlnaHQ6IDQxcHg7XFxuICB3aWR0aDogNDFweDsgfVxcblxcbi5zaWRlbm90ZSB7XFxuICBmb250LXN0eWxlOiBpdGFsaWM7IH1cXG5cXG5idXR0b24ge1xcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcblxcbmZvb3RlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzAzMDMwO1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyOyB9XFxuICBAbWVkaWEgKG1heC13aWR0aDogNDc5cHgpIHtcXG4gICAgZm9vdGVyIHtcXG4gICAgICBoZWlnaHQ6IDgwcHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IDgwcHg7IH0gfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDQ4MHB4KSBhbmQgKG1heC13aWR0aDogNzY3cHgpIHtcXG4gICAgZm9vdGVyIHtcXG4gICAgICBoZWlnaHQ6IDgwcHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IDgwcHg7IH0gfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1heC13aWR0aDogOTkxcHgpIHtcXG4gICAgZm9vdGVyIHtcXG4gICAgICBoZWlnaHQ6IDExMHB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiAxMTBweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIGFuZCAobWF4LXdpZHRoOiAxMTk5cHgpIHtcXG4gICAgZm9vdGVyIHtcXG4gICAgICBoZWlnaHQ6IDExMHB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiAxMTBweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogMTIwMHB4KSB7XFxuICAgIGZvb3RlciB7XFxuICAgICAgaGVpZ2h0OiAxMTBweDtcXG4gICAgICBsaW5lLWhlaWdodDogMTEwcHg7IH0gfVxcbiAgQG1lZGlhIChtYXgtd2lkdGg6IDQ3OXB4KSB7XFxuICAgIGZvb3RlciB7XFxuICAgICAgbWFyZ2luLXRvcDogMzZweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogNDgwcHgpIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcbiAgICBmb290ZXIge1xcbiAgICAgIG1hcmdpbi10b3A6IDM2cHg7IH0gfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1heC13aWR0aDogOTkxcHgpIHtcXG4gICAgZm9vdGVyIHtcXG4gICAgICBtYXJnaW4tdG9wOiA1NHB4OyB9IH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkgYW5kIChtYXgtd2lkdGg6IDExOTlweCkge1xcbiAgICBmb290ZXIge1xcbiAgICAgIG1hcmdpbi10b3A6IDU0cHg7IH0gfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDEyMDBweCkge1xcbiAgICBmb290ZXIge1xcbiAgICAgIG1hcmdpbi10b3A6IDU0cHg7IH0gfVxcbiAgZm9vdGVyIC5lbWFpbCB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDQ3OXB4KSB7XFxuICAgICAgZm9vdGVyIC5lbWFpbCB7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDIwcHg7IH0gfVxcbiAgICBAbWVkaWEgKG1pbi13aWR0aDogNDgwcHgpIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcbiAgICAgIGZvb3RlciAuZW1haWwge1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAyMHB4OyB9IH1cXG4gICAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1heC13aWR0aDogOTkxcHgpIHtcXG4gICAgICBmb290ZXIgLmVtYWlsIHtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogMzBweDsgfSB9XFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkgYW5kIChtYXgtd2lkdGg6IDExOTlweCkge1xcbiAgICAgIGZvb3RlciAuZW1haWwge1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAzMHB4OyB9IH1cXG4gICAgQG1lZGlhIChtaW4td2lkdGg6IDEyMDBweCkge1xcbiAgICAgIGZvb3RlciAuZW1haWwge1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAzMHB4OyB9IH1cXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDQ3OXB4KSB7XFxuICAgICAgZm9vdGVyIC5lbWFpbCB7XFxuICAgICAgICBmb250LXNpemU6IDE1cHg7IH0gfVxcbiAgICBAbWVkaWEgKG1pbi13aWR0aDogNDgwcHgpIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcbiAgICAgIGZvb3RlciAuZW1haWwge1xcbiAgICAgICAgZm9udC1zaXplOiAxNXB4OyB9IH1cXG4gICAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1heC13aWR0aDogOTkxcHgpIHtcXG4gICAgICBmb290ZXIgLmVtYWlsIHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDsgfSB9XFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkgYW5kIChtYXgtd2lkdGg6IDExOTlweCkge1xcbiAgICAgIGZvb3RlciAuZW1haWwge1xcbiAgICAgICAgZm9udC1zaXplOiAxNnB4OyB9IH1cXG4gICAgQG1lZGlhIChtaW4td2lkdGg6IDEyMDBweCkge1xcbiAgICAgIGZvb3RlciAuZW1haWwge1xcbiAgICAgICAgZm9udC1zaXplOiAxNnB4OyB9IH1cXG4gIGZvb3RlciAub2N0aWNvbiB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDQ3OXB4KSB7XFxuICAgICAgZm9vdGVyIC5vY3RpY29uIHtcXG4gICAgICAgIGhlaWdodDogNTBweDsgfSB9XFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiA0ODBweCkgYW5kIChtYXgtd2lkdGg6IDc2N3B4KSB7XFxuICAgICAgZm9vdGVyIC5vY3RpY29uIHtcXG4gICAgICAgIGhlaWdodDogNTBweDsgfSB9XFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkgYW5kIChtYXgtd2lkdGg6IDk5MXB4KSB7XFxuICAgICAgZm9vdGVyIC5vY3RpY29uIHtcXG4gICAgICAgIGhlaWdodDogNzBweDsgfSB9XFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkgYW5kIChtYXgtd2lkdGg6IDExOTlweCkge1xcbiAgICAgIGZvb3RlciAub2N0aWNvbiB7XFxuICAgICAgICBoZWlnaHQ6IDcwcHg7IH0gfVxcbiAgICBAbWVkaWEgKG1pbi13aWR0aDogMTIwMHB4KSB7XFxuICAgICAgZm9vdGVyIC5vY3RpY29uIHtcXG4gICAgICAgIGhlaWdodDogNzBweDsgfSB9XFxuICAgIEBtZWRpYSAobWF4LXdpZHRoOiA0NzlweCkge1xcbiAgICAgIGZvb3RlciAub2N0aWNvbiB7XFxuICAgICAgICBtYXJnaW4tdG9wOiAxMHB4O1xcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMTBweDsgfSB9XFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiA0ODBweCkgYW5kIChtYXgtd2lkdGg6IDc2N3B4KSB7XFxuICAgICAgZm9vdGVyIC5vY3RpY29uIHtcXG4gICAgICAgIG1hcmdpbi10b3A6IDEwcHg7XFxuICAgICAgICBtYXJnaW4tYm90dG9tOiAxMHB4OyB9IH1cXG4gICAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1heC13aWR0aDogOTkxcHgpIHtcXG4gICAgICBmb290ZXIgLm9jdGljb24ge1xcbiAgICAgICAgbWFyZ2luLXRvcDogMTVweDtcXG4gICAgICAgIG1hcmdpbi1ib3R0b206IDE1cHg7IH0gfVxcbiAgICBAbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIGFuZCAobWF4LXdpZHRoOiAxMTk5cHgpIHtcXG4gICAgICBmb290ZXIgLm9jdGljb24ge1xcbiAgICAgICAgbWFyZ2luLXRvcDogMTVweDtcXG4gICAgICAgIG1hcmdpbi1ib3R0b206IDE1cHg7IH0gfVxcbiAgICBAbWVkaWEgKG1pbi13aWR0aDogMTIwMHB4KSB7XFxuICAgICAgZm9vdGVyIC5vY3RpY29uIHtcXG4gICAgICAgIG1hcmdpbi10b3A6IDE1cHg7XFxuICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4OyB9IH1cXG4gICAgZm9vdGVyIC5vY3RpY29uIHBhdGgge1xcbiAgICAgIGZpbGw6IHdoaXRlOyB9XFxuXFxuaGVhZGVyIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcbiAgQG1lZGlhIChtYXgtd2lkdGg6IDQ3OXB4KSB7XFxuICAgIGhlYWRlciB7XFxuICAgICAgbWFyZ2luLXRvcDogMjdweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogNDgwcHgpIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcbiAgICBoZWFkZXIge1xcbiAgICAgIG1hcmdpbi10b3A6IDI3cHg7IH0gfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1heC13aWR0aDogOTkxcHgpIHtcXG4gICAgaGVhZGVyIHtcXG4gICAgICBtYXJnaW4tdG9wOiAzNnB4OyB9IH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkgYW5kIChtYXgtd2lkdGg6IDExOTlweCkge1xcbiAgICBoZWFkZXIge1xcbiAgICAgIG1hcmdpbi10b3A6IDU0cHg7IH0gfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDEyMDBweCkge1xcbiAgICBoZWFkZXIge1xcbiAgICAgIG1hcmdpbi10b3A6IDYzcHg7IH0gfVxcbiAgaGVhZGVyIGgxIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMThweDsgfVxcbiAgaGVhZGVyIGltZyB7XFxuICAgIG1hcmdpbi1ib3R0b206IDE4cHg7IH1cXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDQ3OXB4KSB7XFxuICAgICAgaGVhZGVyIGltZyB7XFxuICAgICAgICBoZWlnaHQ6IDE4MHB4OyB9IH1cXG4gICAgQG1lZGlhIChtaW4td2lkdGg6IDQ4MHB4KSBhbmQgKG1heC13aWR0aDogNzY3cHgpIHtcXG4gICAgICBoZWFkZXIgaW1nIHtcXG4gICAgICAgIGhlaWdodDogMTgwcHg7IH0gfVxcbiAgICBAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIGFuZCAobWF4LXdpZHRoOiA5OTFweCkge1xcbiAgICAgIGhlYWRlciBpbWcge1xcbiAgICAgICAgaGVpZ2h0OiAxODBweDsgfSB9XFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkgYW5kIChtYXgtd2lkdGg6IDExOTlweCkge1xcbiAgICAgIGhlYWRlciBpbWcge1xcbiAgICAgICAgaGVpZ2h0OiAyMjBweDsgfSB9XFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiAxMjAwcHgpIHtcXG4gICAgICBoZWFkZXIgaW1nIHtcXG4gICAgICAgIGhlaWdodDogMjIwcHg7IH0gfVxcbiAgQG1lZGlhIChtYXgtd2lkdGg6IDQ3OXB4KSB7XFxuICAgIGhlYWRlciBoMyB7XFxuICAgICAgbWFyZ2luLWJvdHRvbTogMjdweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogNDgwcHgpIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcbiAgICBoZWFkZXIgaDMge1xcbiAgICAgIG1hcmdpbi1ib3R0b206IDI3cHg7IH0gfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1heC13aWR0aDogOTkxcHgpIHtcXG4gICAgaGVhZGVyIGgzIHtcXG4gICAgICBtYXJnaW4tYm90dG9tOiAzNnB4OyB9IH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkgYW5kIChtYXgtd2lkdGg6IDExOTlweCkge1xcbiAgICBoZWFkZXIgaDMge1xcbiAgICAgIG1hcmdpbi1ib3R0b206IDM2cHg7IH0gfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDEyMDBweCkge1xcbiAgICBoZWFkZXIgaDMge1xcbiAgICAgIG1hcmdpbi1ib3R0b206IDM2cHg7IH0gfVxcbiAgaGVhZGVyIHAge1xcbiAgICBmb250LXN0eWxlOiBpdGFsaWM7IH1cXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDQ3OXB4KSB7XFxuICAgICAgaGVhZGVyIHAge1xcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMjdweDsgfSB9XFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiA0ODBweCkgYW5kIChtYXgtd2lkdGg6IDc2N3B4KSB7XFxuICAgICAgaGVhZGVyIHAge1xcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMjdweDsgfSB9XFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkgYW5kIChtYXgtd2lkdGg6IDk5MXB4KSB7XFxuICAgICAgaGVhZGVyIHAge1xcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMzZweDsgfSB9XFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkgYW5kIChtYXgtd2lkdGg6IDExOTlweCkge1xcbiAgICAgIGhlYWRlciBwIHtcXG4gICAgICAgIG1hcmdpbi1ib3R0b206IDM2cHg7IH0gfVxcbiAgICBAbWVkaWEgKG1pbi13aWR0aDogMTIwMHB4KSB7XFxuICAgICAgaGVhZGVyIHAge1xcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMzZweDsgfSB9XFxuICAgIEBtZWRpYSAobWF4LXdpZHRoOiA0NzlweCkge1xcbiAgICAgIGhlYWRlciBwIHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTVweDsgfSB9XFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiA0ODBweCkgYW5kIChtYXgtd2lkdGg6IDc2N3B4KSB7XFxuICAgICAgaGVhZGVyIHAge1xcbiAgICAgICAgZm9udC1zaXplOiAxNnB4OyB9IH1cXG4gICAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1heC13aWR0aDogOTkxcHgpIHtcXG4gICAgICBoZWFkZXIgcCB7XFxuICAgICAgICBmb250LXNpemU6IDE4cHg7IH0gfVxcbiAgICBAbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIGFuZCAobWF4LXdpZHRoOiAxMTk5cHgpIHtcXG4gICAgICBoZWFkZXIgcCB7XFxuICAgICAgICBmb250LXNpemU6IDE4cHg7IH0gfVxcbiAgICBAbWVkaWEgKG1pbi13aWR0aDogMTIwMHB4KSB7XFxuICAgICAgaGVhZGVyIHAge1xcbiAgICAgICAgZm9udC1zaXplOiAxOHB4OyB9IH1cXG4gIGhlYWRlciBuYXYge1xcbiAgICBmb250LWZhbWlseTogU2NvcGVPbmUsIHNlcmlmOyB9XFxuICAgIEBtZWRpYSAobWF4LXdpZHRoOiA0NzlweCkge1xcbiAgICAgIGhlYWRlciBuYXYge1xcbiAgICAgICAgZm9udC1zaXplOiAyNnB4OyB9IH1cXG4gICAgQG1lZGlhIChtaW4td2lkdGg6IDQ4MHB4KSBhbmQgKG1heC13aWR0aDogNzY3cHgpIHtcXG4gICAgICBoZWFkZXIgbmF2IHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMjZweDsgfSB9XFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkgYW5kIChtYXgtd2lkdGg6IDk5MXB4KSB7XFxuICAgICAgaGVhZGVyIG5hdiB7XFxuICAgICAgICBmb250LXNpemU6IDMycHg7IH0gfVxcbiAgICBAbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIGFuZCAobWF4LXdpZHRoOiAxMTk5cHgpIHtcXG4gICAgICBoZWFkZXIgbmF2IHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMzJweDsgfSB9XFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiAxMjAwcHgpIHtcXG4gICAgICBoZWFkZXIgbmF2IHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMzJweDsgfSB9XFxuICAgIEBtZWRpYSAobWF4LXdpZHRoOiA5OTFweCkge1xcbiAgICAgIGhlYWRlciBuYXYgbGkgKyBsaSB7XFxuICAgICAgICBtYXJnaW4tdG9wOiAxOHB4OyB9IH1cXG4gICAgQG1lZGlhIChtaW4td2lkdGg6IDk5MnB4KSB7XFxuICAgICAgaGVhZGVyIG5hdiBsaSB7XFxuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IH1cXG4gICAgICBoZWFkZXIgbmF2IGxpICsgbGk6YmVmb3JlIHtcXG4gICAgICAgIGNvbnRlbnQ6IFxcXCIvXFxcIjsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIGFuZCAobWF4LXdpZHRoOiA0NzlweCkge1xcbiAgICBoZWFkZXIgbmF2IGxpICsgbGk6YmVmb3JlIHtcXG4gICAgICBtYXJnaW4tbGVmdDogOXB4O1xcbiAgICAgIG1hcmdpbi1yaWdodDogOXB4OyB9IH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkgYW5kIChtaW4td2lkdGg6IDQ4MHB4KSBhbmQgKG1heC13aWR0aDogNzY3cHgpIHtcXG4gICAgaGVhZGVyIG5hdiBsaSArIGxpOmJlZm9yZSB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDE4cHg7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAxOHB4OyB9IH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkgYW5kIChtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1heC13aWR0aDogOTkxcHgpIHtcXG4gICAgaGVhZGVyIG5hdiBsaSArIGxpOmJlZm9yZSB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDE4cHg7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAxOHB4OyB9IH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkgYW5kIChtaW4td2lkdGg6IDk5MnB4KSBhbmQgKG1heC13aWR0aDogMTE5OXB4KSB7XFxuICAgIGhlYWRlciBuYXYgbGkgKyBsaTpiZWZvcmUge1xcbiAgICAgIG1hcmdpbi1sZWZ0OiAyN3B4O1xcbiAgICAgIG1hcmdpbi1yaWdodDogMjdweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIGFuZCAobWluLXdpZHRoOiAxMjAwcHgpIHtcXG4gICAgaGVhZGVyIG5hdiBsaSArIGxpOmJlZm9yZSB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDI3cHg7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAyN3B4OyB9IH1cXG5cXG4jc2lkZS1wcm9qZWN0cyBoNCB7XFxuICBtYXJnaW4tYm90dG9tOiAxOHB4OyB9XFxuXFxuI3NpZGUtcHJvamVjdHMgdWwubGVnZW5kID4gbGkgKyBsaSB7XFxuICBtYXJnaW4tdG9wOiA5cHg7IH1cXG5cXG4jc2lkZS1wcm9qZWN0cyA+IHVsOm5vdCgubGVnZW5kKSA+IGxpICsgbGkge1xcbiAgbWFyZ2luLXRvcDogMjdweDsgfVxcblxcbiNzaWRlLXByb2plY3RzIC5hcHBsaWNhdGlvbixcXG4jc2lkZS1wcm9qZWN0cyAudG9vbCxcXG4jc2lkZS1wcm9qZWN0cyAubGlicmFyeSB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xcbiAgbWFyZ2luLXRvcDogMDtcXG4gIG1hcmdpbi1ib3R0b206IDA7XFxuICBib3JkZXItbGVmdC1zdHlsZTogc29saWQ7XFxuICBwYWRkaW5nLXRvcDogOXB4O1xcbiAgcGFkZGluZy1ib3R0b206IDlweDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcbiAgQG1lZGlhIChtYXgtd2lkdGg6IDQ3OXB4KSB7XFxuICAgICNzaWRlLXByb2plY3RzIC5hcHBsaWNhdGlvbixcXG4gICAgI3NpZGUtcHJvamVjdHMgLnRvb2wsXFxuICAgICNzaWRlLXByb2plY3RzIC5saWJyYXJ5IHtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IDlweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogNDgwcHgpIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcbiAgICAjc2lkZS1wcm9qZWN0cyAuYXBwbGljYXRpb24sXFxuICAgICNzaWRlLXByb2plY3RzIC50b29sLFxcbiAgICAjc2lkZS1wcm9qZWN0cyAubGlicmFyeSB7XFxuICAgICAgcGFkZGluZy1sZWZ0OiAzNnB4OyB9IH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkgYW5kIChtYXgtd2lkdGg6IDk5MXB4KSB7XFxuICAgICNzaWRlLXByb2plY3RzIC5hcHBsaWNhdGlvbixcXG4gICAgI3NpZGUtcHJvamVjdHMgLnRvb2wsXFxuICAgICNzaWRlLXByb2plY3RzIC5saWJyYXJ5IHtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IDM2cHg7IH0gfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDk5MnB4KSBhbmQgKG1heC13aWR0aDogMTE5OXB4KSB7XFxuICAgICNzaWRlLXByb2plY3RzIC5hcHBsaWNhdGlvbixcXG4gICAgI3NpZGUtcHJvamVjdHMgLnRvb2wsXFxuICAgICNzaWRlLXByb2plY3RzIC5saWJyYXJ5IHtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IDU0cHg7IH0gfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDEyMDBweCkge1xcbiAgICAjc2lkZS1wcm9qZWN0cyAuYXBwbGljYXRpb24sXFxuICAgICNzaWRlLXByb2plY3RzIC50b29sLFxcbiAgICAjc2lkZS1wcm9qZWN0cyAubGlicmFyeSB7XFxuICAgICAgcGFkZGluZy1sZWZ0OiA1NHB4OyB9IH1cXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA0NzlweCkge1xcbiAgICAjc2lkZS1wcm9qZWN0cyAuYXBwbGljYXRpb24sXFxuICAgICNzaWRlLXByb2plY3RzIC50b29sLFxcbiAgICAjc2lkZS1wcm9qZWN0cyAubGlicmFyeSB7XFxuICAgICAgcGFkZGluZy1yaWdodDogOXB4OyB9IH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA0ODBweCkgYW5kIChtYXgtd2lkdGg6IDc2N3B4KSB7XFxuICAgICNzaWRlLXByb2plY3RzIC5hcHBsaWNhdGlvbixcXG4gICAgI3NpZGUtcHJvamVjdHMgLnRvb2wsXFxuICAgICNzaWRlLXByb2plY3RzIC5saWJyYXJ5IHtcXG4gICAgICBwYWRkaW5nLXJpZ2h0OiA0NXB4OyB9IH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkgYW5kIChtYXgtd2lkdGg6IDk5MXB4KSB7XFxuICAgICNzaWRlLXByb2plY3RzIC5hcHBsaWNhdGlvbixcXG4gICAgI3NpZGUtcHJvamVjdHMgLnRvb2wsXFxuICAgICNzaWRlLXByb2plY3RzIC5saWJyYXJ5IHtcXG4gICAgICBwYWRkaW5nLXJpZ2h0OiA0NXB4OyB9IH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkgYW5kIChtYXgtd2lkdGg6IDExOTlweCkge1xcbiAgICAjc2lkZS1wcm9qZWN0cyAuYXBwbGljYXRpb24sXFxuICAgICNzaWRlLXByb2plY3RzIC50b29sLFxcbiAgICAjc2lkZS1wcm9qZWN0cyAubGlicmFyeSB7XFxuICAgICAgcGFkZGluZy1yaWdodDogNjNweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogMTIwMHB4KSB7XFxuICAgICNzaWRlLXByb2plY3RzIC5hcHBsaWNhdGlvbixcXG4gICAgI3NpZGUtcHJvamVjdHMgLnRvb2wsXFxuICAgICNzaWRlLXByb2plY3RzIC5saWJyYXJ5IHtcXG4gICAgICBwYWRkaW5nLXJpZ2h0OiA2M3B4OyB9IH1cXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA0NzlweCkge1xcbiAgICAjc2lkZS1wcm9qZWN0cyAuYXBwbGljYXRpb24sXFxuICAgICNzaWRlLXByb2plY3RzIC50b29sLFxcbiAgICAjc2lkZS1wcm9qZWN0cyAubGlicmFyeSB7XFxuICAgICAgYm9yZGVyLWxlZnQtd2lkdGg6IDJweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogNDgwcHgpIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcbiAgICAjc2lkZS1wcm9qZWN0cyAuYXBwbGljYXRpb24sXFxuICAgICNzaWRlLXByb2plY3RzIC50b29sLFxcbiAgICAjc2lkZS1wcm9qZWN0cyAubGlicmFyeSB7XFxuICAgICAgYm9yZGVyLWxlZnQtd2lkdGg6IDJweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIGFuZCAobWF4LXdpZHRoOiA5OTFweCkge1xcbiAgICAjc2lkZS1wcm9qZWN0cyAuYXBwbGljYXRpb24sXFxuICAgICNzaWRlLXByb2plY3RzIC50b29sLFxcbiAgICAjc2lkZS1wcm9qZWN0cyAubGlicmFyeSB7XFxuICAgICAgYm9yZGVyLWxlZnQtd2lkdGg6IDNweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIGFuZCAobWF4LXdpZHRoOiAxMTk5cHgpIHtcXG4gICAgI3NpZGUtcHJvamVjdHMgLmFwcGxpY2F0aW9uLFxcbiAgICAjc2lkZS1wcm9qZWN0cyAudG9vbCxcXG4gICAgI3NpZGUtcHJvamVjdHMgLmxpYnJhcnkge1xcbiAgICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAzcHg7IH0gfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDEyMDBweCkge1xcbiAgICAjc2lkZS1wcm9qZWN0cyAuYXBwbGljYXRpb24sXFxuICAgICNzaWRlLXByb2plY3RzIC50b29sLFxcbiAgICAjc2lkZS1wcm9qZWN0cyAubGlicmFyeSB7XFxuICAgICAgYm9yZGVyLWxlZnQtd2lkdGg6IDNweDsgfSB9XFxuICAjc2lkZS1wcm9qZWN0cyAuYXBwbGljYXRpb246YmVmb3JlLFxcbiAgI3NpZGUtcHJvamVjdHMgLnRvb2w6YmVmb3JlLFxcbiAgI3NpZGUtcHJvamVjdHMgLmxpYnJhcnk6YmVmb3JlIHtcXG4gICAgY29udGVudDogbm9uZTsgfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDQ4MHB4KSB7XFxuICAgICNzaWRlLXByb2plY3RzIC5hcHBsaWNhdGlvbjphZnRlcixcXG4gICAgI3NpZGUtcHJvamVjdHMgLnRvb2w6YWZ0ZXIsXFxuICAgICNzaWRlLXByb2plY3RzIC5saWJyYXJ5OmFmdGVyIHtcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgY29udGVudDogJyc7XFxuICAgICAgdG9wOiAwO1xcbiAgICAgIHJpZ2h0OiAwO1xcbiAgICAgIHdpZHRoOiAwO1xcbiAgICAgIGhlaWdodDogMDtcXG4gICAgICBib3JkZXItdG9wOiAyMC41cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICAgICAgYm9yZGVyLWJvdHRvbTogMjAuNXB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgICAgIGJvcmRlci1yaWdodDogOXB4IHNvbGlkIHdoaXRlOyB9IH1cXG5cXG4jc2lkZS1wcm9qZWN0cyAuYXBwbGljYXRpb24ge1xcbiAgYm9yZGVyLWxlZnQtY29sb3I6ICMxOTYxMGQ7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI2LCAxODksIDAsIDAuMyk7IH1cXG4gICNzaWRlLXByb2plY3RzIC5hcHBsaWNhdGlvbiArIGJ1dHRvbiB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjsgfVxcbiAgICAjc2lkZS1wcm9qZWN0cyAuYXBwbGljYXRpb24gKyBidXR0b24gc3ZnIHBhdGgge1xcbiAgICAgIGZpbGw6ICMxOTYxMGQ7IH1cXG5cXG4jc2lkZS1wcm9qZWN0cyAudG9vbCB7XFxuICBib3JkZXItbGVmdC1jb2xvcjogI2YwYTMwMDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQwLCAxNjMsIDAsIDAuMyk7IH1cXG4gICNzaWRlLXByb2plY3RzIC50b29sICsgYnV0dG9uIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyOyB9XFxuICAgICNzaWRlLXByb2plY3RzIC50b29sICsgYnV0dG9uIHN2ZyBwYXRoIHtcXG4gICAgICBmaWxsOiAjZjBhMzAwOyB9XFxuXFxuI3NpZGUtcHJvamVjdHMgLmxpYnJhcnkge1xcbiAgYm9yZGVyLWxlZnQtY29sb3I6ICM4NDAwOGE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzMiwgMCwgMTM4LCAwLjE1KTsgfVxcbiAgI3NpZGUtcHJvamVjdHMgLmxpYnJhcnkgKyBidXR0b24ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7IH1cXG4gICAgI3NpZGUtcHJvamVjdHMgLmxpYnJhcnkgKyBidXR0b24gc3ZnIHBhdGgge1xcbiAgICAgIGZpbGw6ICM4NDAwOGE7IH1cXG5cXG5AbWVkaWEgKG1heC13aWR0aDogNDc5cHgpIHtcXG4gICNzaWRlLXByb2plY3RzIGJ1dHRvbiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxOHB4OyB9IH1cXG5cXG5AbWVkaWEgKG1pbi13aWR0aDogNDgwcHgpIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcbiAgI3NpZGUtcHJvamVjdHMgYnV0dG9uIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDI3cHg7IH0gfVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkgYW5kIChtYXgtd2lkdGg6IDk5MXB4KSB7XFxuICAjc2lkZS1wcm9qZWN0cyBidXR0b24ge1xcbiAgICBtYXJnaW4tbGVmdDogMjdweDsgfSB9XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDk5MnB4KSBhbmQgKG1heC13aWR0aDogMTE5OXB4KSB7XFxuICAjc2lkZS1wcm9qZWN0cyBidXR0b24ge1xcbiAgICBtYXJnaW4tbGVmdDogMzZweDsgfSB9XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDEyMDBweCkge1xcbiAgI3NpZGUtcHJvamVjdHMgYnV0dG9uIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDM2cHg7IH0gfVxcblxcbiNzaWRlLXByb2plY3RzIC5jb250ZW50IHtcXG4gIGhlaWdodDogMDtcXG4gIG92ZXJmbG93OiBoaWRkZW47IH1cXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA0NzlweCkge1xcbiAgICAjc2lkZS1wcm9qZWN0cyAuY29udGVudCB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDlweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogNDgwcHgpIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcbiAgICAjc2lkZS1wcm9qZWN0cyAuY29udGVudCB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDlweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIGFuZCAobWF4LXdpZHRoOiA5OTFweCkge1xcbiAgICAjc2lkZS1wcm9qZWN0cyAuY29udGVudCB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDE4cHg7IH0gfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDk5MnB4KSBhbmQgKG1heC13aWR0aDogMTE5OXB4KSB7XFxuICAgICNzaWRlLXByb2plY3RzIC5jb250ZW50IHtcXG4gICAgICBtYXJnaW4tbGVmdDogMThweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogMTIwMHB4KSB7XFxuICAgICNzaWRlLXByb2plY3RzIC5jb250ZW50IHtcXG4gICAgICBtYXJnaW4tbGVmdDogMThweDsgfSB9XFxuICAjc2lkZS1wcm9qZWN0cyAuY29udGVudCA+IGEge1xcbiAgICBkaXNwbGF5OiBibG9jazsgfVxcbiAgICAjc2lkZS1wcm9qZWN0cyAuY29udGVudCA+IGE6Zmlyc3QtY2hpbGQge1xcbiAgICAgIG1hcmdpbi10b3A6IDE4cHg7IH1cXG4gICAgI3NpZGUtcHJvamVjdHMgLmNvbnRlbnQgPiBhOm5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gICAgICBtYXJnaW4tdG9wOiA5cHg7IH1cXG5cXG5AbWVkaWEgKG1heC13aWR0aDogNDc5cHgpIHtcXG4gICNzaWRlLXByb2plY3RzIGRkICsgZHQge1xcbiAgICBtYXJnaW4tdG9wOiA5cHg7IH0gfVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA0ODBweCkgYW5kIChtYXgtd2lkdGg6IDc2N3B4KSB7XFxuICAjc2lkZS1wcm9qZWN0cyBkZCArIGR0IHtcXG4gICAgbWFyZ2luLXRvcDogOXB4OyB9IH1cXG5cXG5AbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIGFuZCAobWF4LXdpZHRoOiA5OTFweCkge1xcbiAgI3NpZGUtcHJvamVjdHMgZGQgKyBkdCB7XFxuICAgIG1hcmdpbi10b3A6IDE4cHg7IH0gfVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkgYW5kIChtYXgtd2lkdGg6IDExOTlweCkge1xcbiAgI3NpZGUtcHJvamVjdHMgZGQgKyBkdCB7XFxuICAgIG1hcmdpbi10b3A6IDE4cHg7IH0gfVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiAxMjAwcHgpIHtcXG4gICNzaWRlLXByb2plY3RzIGRkICsgZHQge1xcbiAgICBtYXJnaW4tdG9wOiAxOHB4OyB9IH1cXG5cXG4jc2lkZS1wcm9qZWN0cyBkdDpiZWZvcmUge1xcbiAgY29udGVudDogJy0gJzsgfVxcblxcbkBtZWRpYSAobWF4LXdpZHRoOiA0NzlweCkge1xcbiAgI3NpZGUtcHJvamVjdHMgZGQge1xcbiAgICBtYXJnaW4tdG9wOiAzcHg7IH0gfVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA0ODBweCkgYW5kIChtYXgtd2lkdGg6IDc2N3B4KSB7XFxuICAjc2lkZS1wcm9qZWN0cyBkZCB7XFxuICAgIG1hcmdpbi10b3A6IDNweDsgfSB9XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1heC13aWR0aDogOTkxcHgpIHtcXG4gICNzaWRlLXByb2plY3RzIGRkIHtcXG4gICAgbWFyZ2luLXRvcDogNHB4OyB9IH1cXG5cXG5AbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIGFuZCAobWF4LXdpZHRoOiAxMTk5cHgpIHtcXG4gICNzaWRlLXByb2plY3RzIGRkIHtcXG4gICAgbWFyZ2luLXRvcDogNHB4OyB9IH1cXG5cXG5AbWVkaWEgKG1pbi13aWR0aDogMTIwMHB4KSB7XFxuICAjc2lkZS1wcm9qZWN0cyBkZCB7XFxuICAgIG1hcmdpbi10b3A6IDVweDsgfSB9XFxuXFxuQG1lZGlhIChtYXgtd2lkdGg6IDQ3OXB4KSB7XFxuICAjc2lkZS1wcm9qZWN0cyBkZCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxOHB4OyB9IH1cXG5cXG5AbWVkaWEgKG1pbi13aWR0aDogNDgwcHgpIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcbiAgI3NpZGUtcHJvamVjdHMgZGQge1xcbiAgICBtYXJnaW4tbGVmdDogMThweDsgfSB9XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1heC13aWR0aDogOTkxcHgpIHtcXG4gICNzaWRlLXByb2plY3RzIGRkIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDE4cHg7IH0gfVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkgYW5kIChtYXgtd2lkdGg6IDExOTlweCkge1xcbiAgI3NpZGUtcHJvamVjdHMgZGQge1xcbiAgICBtYXJnaW4tbGVmdDogMjdweDsgfSB9XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDEyMDBweCkge1xcbiAgI3NpZGUtcHJvamVjdHMgZGQge1xcbiAgICBtYXJnaW4tbGVmdDogMjdweDsgfSB9XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9ob21lL3BoaWwvZ2l0LXJlcG9zL3BlcnNvbmFsL3BlcnNvbmFsLWhvbWUyL2NsaWVudC9zY3NzL2NsaWVudC9zY3NzL2ZvbnRzLnNjc3NcIixcIi9ob21lL3BoaWwvZ2l0LXJlcG9zL3BlcnNvbmFsL3BlcnNvbmFsLWhvbWUyL2NsaWVudC9zY3NzL2NsaWVudC9zY3NzL21haW4uc2Nzc1wiLFwiL2hvbWUvcGhpbC9naXQtcmVwb3MvcGVyc29uYWwvcGVyc29uYWwtaG9tZTIvY2xpZW50L3Njc3MvY2xpZW50L3Njc3MvdmFyaWFibGVzLnNjc3NcIixcIi9ob21lL3BoaWwvZ2l0LXJlcG9zL3BlcnNvbmFsL3BlcnNvbmFsLWhvbWUyL2NsaWVudC9zY3NzL2NsaWVudC9zY3NzL21peGlucy5zY3NzXCIsXCIvaG9tZS9waGlsL2dpdC1yZXBvcy9wZXJzb25hbC9wZXJzb25hbC1ob21lMi9jbGllbnQvc2Nzcy9jbGllbnQvc2Nzcy9wYXJ0aWFscy9mb290ZXIuc2Nzc1wiLFwiL2hvbWUvcGhpbC9naXQtcmVwb3MvcGVyc29uYWwvcGVyc29uYWwtaG9tZTIvY2xpZW50L3Njc3MvY2xpZW50L3Njc3MvcGFydGlhbHMvaGVhZGVyLnNjc3NcIixcIi9ob21lL3BoaWwvZ2l0LXJlcG9zL3BlcnNvbmFsL3BlcnNvbmFsLWhvbWUyL2NsaWVudC9zY3NzL2NsaWVudC9zY3NzL3BhcnRpYWxzL3NpZGUtcHJvamVjdHMuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNDLHNCQUFxQjtFQUNyQixpQkFBZ0I7RUFDaEIsa0RBQXdELEVBQUE7O0FBRXpEO0VBQ0MseUJBQXdCO0VBQ3hCLGlCQUFnQjtFQUNoQixrREFBd0QsRUFBQTs7QUFFekQ7RUFDQyx5QkFBd0I7RUFDeEIsaUJBQWdCO0VBQ2YsbUJBQWtCO0VBQ25CLGtEQUF1RCxFQUFBOztBQ2R4RDs7RUFFRSxrQkNFUTtFRERSLGVDR1U7RURGVixxQ0FBb0M7RUFDcEMsZ0JDb0JjLEVEbkJmOztBQUVEO0VBQ0UsY0FBYTtFQUNiLHVCQUFzQjtFQUN0QixrQkFBaUIsRUFLbEI7RUFSRDtJQU1JLGFBQVksRUFDYjs7QUFHSDs7OztFQUlFLDZCQUE0QixFQUM3Qjs7QUFFRDs7Ozs7O0VBTUUsaUJBQWdCLEVBQ2pCOztBQUVEOzs7Ozs7Ozs7OztFQVdFLFVBQVM7RUFDVCxXQUFVLEVBQ1g7O0FBRUQ7Ozs7Ozs7RUFPRSxlQUFjLEVBQ2Y7O0FBRUQ7RUFDRSxVQUFTO0VBQ1QseUJBQXdCO0VBQ3hCLGlCQUFnQjtFQUNoQixzQkFBcUI7RUFDckIsYUFBWSxFQUNiOztBQUVEO0VBQ0UsaUJBQWdCLEVBQ2pCOztBQUVEO0VBQ0UsZ0JDbENZLEVEbUNiOztBQUNEO0VBQ0UsZ0JDcENZLEVEcUNiOztBQUNEO0VBQ0UsZ0JDdENZLEVEdUNiOztBQUNEO0VBQ0UsZ0JDeENZLEVEeUNiOztBQUNEO0VBQ0UsZ0JDMUNZO0VEMkNaLG1CQ25Eb0IsRURvRHJCOztBQUVEO0VBQ0UsZUNsRlk7RURtRlosc0JBQXFCLEVBQ3RCOztBQUVEO0VBQ0UsbUJBQWtCLEVBQ25COztBRTlGQztFRmdHRjs7O0lFOUZNLGdCQUFVLEVGeUdmLEVBQUE7O0FFdEdDO0VGMkZGOzs7SUV6Rk0sZ0JBQVUsRUZvR2YsRUFBQTs7QUVqR0M7RUZzRkY7OztJRXBGTSxnQkFBVSxFRitGZixFQUFBOztBRTVGQztFRmlGRjs7O0lFL0VNLGdCQUFVLEVGMEZmLEVBQUE7O0FFdkZDO0VGNEVGOzs7SUUxRU0sZ0JBQVUsRUZxRmYsRUFBQTs7QUFFRDs7RUFFRSxpQkFBZ0IsRUFDakI7O0FBRUQ7RUFDRSxlQUFjO0VBQ2Qsa0JDN0ZpQixFRGdHbEI7RUV2SEM7SUZrSEY7TUVoSE0sbUJBQVU7TUFBVixvQkFBVSxFRnFIZixFQUFBO0VFbEhDO0lGNkdGO01FM0dNLG1CQUFVO01BQVYsb0JBQVUsRUZnSGYsRUFBQTtFRTdHQztJRndHRjtNRXRHTSxtQkFBVTtNQUFWLG9CQUFVLEVGMkdmLEVBQUE7RUV4R0M7SUZtR0Y7TUVqR00sbUJBQVU7TUFBVixvQkFBVSxFRnNHZixFQUFBO0VFbkdDO0lGOEZGO01FNUZNLG1CQUFVO01BQVYsb0JBQVUsRUZpR2YsRUFBQTs7QUV2SEM7RUZ5SEY7SUV2SE0saUJBQVUsRUYySmYsRUFBQTs7QUV4SkM7RUZvSEY7SUVsSE0saUJBQVUsRUZzSmYsRUFBQTs7QUVuSkM7RUYrR0Y7SUU3R00saUJBQVUsRUZpSmYsRUFBQTs7QUU5SUM7RUYwR0Y7SUV4R00saUJBQVUsRUY0SWYsRUFBQTs7QUV6SUM7RUZxR0Y7SUVuR00saUJBQVUsRUZ1SWYsRUFBQTs7QUFwQ0Q7RUFJSSxlQ3RIWTtFRCtIWixvQkM5R1ksRUQrR2I7RUV2SUQ7SUZ5SEY7TUV2SE0sZ0JBQVUsRUZxSWIsRUFBQTtFRWxJRDtJRm9IRjtNRWxITSxnQkFBVSxFRmdJYixFQUFBO0VFN0hEO0lGK0dGO01FN0dNLGdCQUFVLEVGMkhiLEVBQUE7RUV4SEQ7SUYwR0Y7TUV4R00sZ0JBQVUsRUZzSGIsRUFBQTtFRW5IRDtJRnFHRjtNRW5HTSxnQkFBVSxFRmlIYixFQUFBOztBQWRIO0VBaUJJLGlCQzNHOEIsRUQ0Ry9COztBQWxCSDtFQW9CSSxpQkNySFksRURzSGI7O0FBckJIO0VBdUJJLGdCQy9Ha0IsRURnSG5COztBQXhCSDtFQTBCSSxpQkMzSFksRUQ0SGI7O0FBM0JIO0VBOEJJLG1CQ3RIa0IsRUQySG5CO0VBbkNIO0lBaUNNLGVBQWMsRUFDZjs7QUFJTDtFQUNFLGFDdEdxQztFRHVHckMsWUN2R3FDLEVEd0d0Qzs7QUFFRDtFQUNFLG1CQUFrQixFQUNuQjs7QUFFRDtFQUNFLHlDQUF3QyxFQUN6Qzs7QUczS0Q7RUFHRSwwQkZjb0I7RUVicEIsYUZBUTtFRUNSLG1CQUFrQixFQWdDbkI7RURwQ0M7SUNERjtNREdNLGFBQVU7TUFBVixrQkFBVSxFQ2tDZixFQUFBO0VEL0JDO0lDTkY7TURRTSxhQUFVO01BQVYsa0JBQVUsRUM2QmYsRUFBQTtFRDFCQztJQ1hGO01EYU0sY0FBVTtNQUFWLG1CQUFVLEVDd0JmLEVBQUE7RURyQkM7SUNoQkY7TURrQk0sY0FBVTtNQUFWLG1CQUFVLEVDbUJmLEVBQUE7RURoQkM7SUNyQkY7TUR1Qk0sY0FBVTtNQUFWLG1CQUFVLEVDY2YsRUFBQTtFRHBDQztJQ0RGO01ER00saUJBQVUsRUNrQ2YsRUFBQTtFRC9CQztJQ05GO01EUU0saUJBQVUsRUM2QmYsRUFBQTtFRDFCQztJQ1hGO01EYU0saUJBQVUsRUN3QmYsRUFBQTtFRHJCQztJQ2hCRjtNRGtCTSxpQkFBVSxFQ21CZixFQUFBO0VEaEJDO0lDckJGO01EdUJNLGlCQUFVLEVDY2YsRUFBQTtFQXJDRDtJQWtCSSx1QkFBc0IsRUFDdkI7SURsQkQ7TUNERjtRREdNLG1CQUFVLEVDZ0JiLEVBQUE7SURiRDtNQ05GO1FEUU0sbUJBQVUsRUNXYixFQUFBO0lEUkQ7TUNYRjtRRGFNLG1CQUFVLEVDTWIsRUFBQTtJREhEO01DaEJGO1FEa0JNLG1CQUFVLEVDQ2IsRUFBQTtJREVEO01DckJGO1FEdUJNLG1CQUFVLEVDSmIsRUFBQTtJRGxCRDtNQ0RGO1FER00sZ0JBQVUsRUNnQmIsRUFBQTtJRGJEO01DTkY7UURRTSxnQkFBVSxFQ1diLEVBQUE7SURSRDtNQ1hGO1FEYU0sZ0JBQVUsRUNNYixFQUFBO0lESEQ7TUNoQkY7UURrQk0sZ0JBQVUsRUNDYixFQUFBO0lERUQ7TUNyQkY7UUR1Qk0sZ0JBQVUsRUNKYixFQUFBO0VBbkJIO0lBc0JJLHVCQUFzQixFQWN2QjtJRG5DRDtNQ0RGO1FER00sYUFBVSxFQ2lDYixFQUFBO0lEOUJEO01DTkY7UURRTSxhQUFVLEVDNEJiLEVBQUE7SUR6QkQ7TUNYRjtRRGFNLGFBQVUsRUN1QmIsRUFBQTtJRHBCRDtNQ2hCRjtRRGtCTSxhQUFVLEVDa0JiLEVBQUE7SURmRDtNQ3JCRjtRRHVCTSxhQUFVLEVDYWIsRUFBQTtJRG5DRDtNQ0RGO1FER00saUJBQVU7UUFBVixvQkFBVSxFQ2lDYixFQUFBO0lEOUJEO01DTkY7UURRTSxpQkFBVTtRQUFWLG9CQUFVLEVDNEJiLEVBQUE7SUR6QkQ7TUNYRjtRRGFNLGlCQUFVO1FBQVYsb0JBQVUsRUN1QmIsRUFBQTtJRHBCRDtNQ2hCRjtRRGtCTSxpQkFBVTtRQUFWLG9CQUFVLEVDa0JiLEVBQUE7SURmRDtNQ3JCRjtRRHVCTSxpQkFBVTtRQUFWLG9CQUFVLEVDYWIsRUFBQTtJQXBDSDtNQWtDTSxZRjlCSSxFRStCTDs7QUNuQ0w7RUFFRSxtQkFBa0IsRUEwQ25CO0VGM0NDO0lFREY7TUZHTSxpQkFBVSxFRXlDZixFQUFBO0VGdENDO0lFTkY7TUZRTSxpQkFBVSxFRW9DZixFQUFBO0VGakNDO0lFWEY7TUZhTSxpQkFBVSxFRStCZixFQUFBO0VGNUJDO0lFaEJGO01Ga0JNLGlCQUFVLEVFMEJmLEVBQUE7RUZ2QkM7SUVyQkY7TUZ1Qk0saUJBQVUsRUVxQmYsRUFBQTtFQTVDRDtJQUtJLG9CSG9CWSxFR25CYjtFQU5IO0lBVUksb0JIZVksRUdkYjtJRlZEO01FREY7UUZHTSxjQUFVLEVFUWIsRUFBQTtJRkxEO01FTkY7UUZRTSxjQUFVLEVFR2IsRUFBQTtJRkFEO01FWEY7UUZhTSxjQUFVLEVFRmIsRUFBQTtJRktEO01FaEJGO1FGa0JNLGNBQVUsRUVQYixFQUFBO0lGVUQ7TUVyQkY7UUZ1Qk0sY0FBVSxFRVpiLEVBQUE7RUZWRDtJRURGO01GR00sb0JBQVUsRUVZYixFQUFBO0VGVEQ7SUVORjtNRlFNLG9CQUFVLEVFT2IsRUFBQTtFRkpEO0lFWEY7TUZhTSxvQkFBVSxFRUViLEVBQUE7RUZDRDtJRWhCRjtNRmtCTSxvQkFBVSxFRUhiLEVBQUE7RUZNRDtJRXJCRjtNRnVCTSxvQkFBVSxFRVJiLEVBQUE7RUFmSDtJQW1CSSxtQkFBa0IsRUFHbkI7SUZyQkQ7TUVERjtRRkdNLG9CQUFVLEVFbUJiLEVBQUE7SUZoQkQ7TUVORjtRRlFNLG9CQUFVLEVFY2IsRUFBQTtJRlhEO01FWEY7UUZhTSxvQkFBVSxFRVNiLEVBQUE7SUZORDtNRWhCRjtRRmtCTSxvQkFBVSxFRUliLEVBQUE7SUZERDtNRXJCRjtRRnVCTSxvQkFBVSxFRURiLEVBQUE7SUZyQkQ7TUVERjtRRkdNLGdCQUFVLEVFbUJiLEVBQUE7SUZoQkQ7TUVORjtRRlFNLGdCQUFVLEVFY2IsRUFBQTtJRlhEO01FWEY7UUZhTSxnQkFBVSxFRVNiLEVBQUE7SUZORDtNRWhCRjtRRmtCTSxnQkFBVSxFRUliLEVBQUE7SUZERDtNRXJCRjtRRnVCTSxnQkFBVSxFRURiLEVBQUE7RUF0Qkg7SUEwQkksNkJBQTRCLEVBaUI3QjtJRjFDRDtNRURGO1FGR00sZ0JBQVUsRUV3Q2IsRUFBQTtJRnJDRDtNRU5GO1FGUU0sZ0JBQVUsRUVtQ2IsRUFBQTtJRmhDRDtNRVhGO1FGYU0sZ0JBQVUsRUU4QmIsRUFBQTtJRjNCRDtNRWhCRjtRRmtCTSxnQkFBVSxFRXlCYixFQUFBO0lGdEJEO01FckJGO1FGdUJNLGdCQUFVLEVFb0JiLEVBQUE7SUFmQztNQTVCSjtRQThCUSxpQkhMUSxFR01ULEVBQUE7SUFHSDtNQWxDSjtRQW9DUSxzQkFBcUIsRUFDdEI7TUFyQ1A7UUF1Q1EsYUFBWSxFQUViLEVBQUE7RUZ4Q0w7SUVERjtNRkdNLGlCQUFVO01BQVYsa0JBQVUsRUVzQ1QsRUFBQTtFRm5DTDtJRU5GO01GUU0sa0JBQVU7TUFBVixtQkFBVSxFRWlDVCxFQUFBO0VGOUJMO0lFWEY7TUZhTSxrQkFBVTtNQUFWLG1CQUFVLEVFNEJULEVBQUE7RUZ6Qkw7SUVoQkY7TUZrQk0sa0JBQVU7TUFBVixtQkFBVSxFRXVCVCxFQUFBO0VGcEJMO0lFckJGO01GdUJNLGtCQUFVO01BQVYsbUJBQVUsRUVrQlQsRUFBQTs7QUN6Q1A7RUFFSSxvQkp1QlksRUl0QmI7O0FBSEg7RUFNSSxnQko0QmtCLEVJM0JuQjs7QUFQSDtFQVVJLGlCSnNCOEIsRUlyQi9COztBQVhIOzs7RUFnQkksb0JBQW1CO0VBQ25CLGNBQWE7RUFDYixpQkFBZ0I7RUFDaEIseUJBQXdCO0VBQ3hCLGlCSmNrQjtFSWJsQixvQkpha0I7RUlabEIsc0JBQXFCO0VBQ3JCLG1CQUFrQixFQTZCbkI7RUhuREQ7SUdERjs7O01IR00sa0JBQVUsRUdpRGIsRUFBQTtFSDlDRDtJR05GOzs7TUhRTSxtQkFBVSxFRzRDYixFQUFBO0VIekNEO0lHWEY7OztNSGFNLG1CQUFVLEVHdUNiLEVBQUE7RUhwQ0Q7SUdoQkY7OztNSGtCTSxtQkFBVSxFR2tDYixFQUFBO0VIL0JEO0lHckJGOzs7TUh1Qk0sbUJBQVUsRUc2QmIsRUFBQTtFSG5ERDtJR0RGOzs7TUhHTSxtQkFBVSxFR2lEYixFQUFBO0VIOUNEO0lHTkY7OztNSFFNLG9CQUFVLEVHNENiLEVBQUE7RUh6Q0Q7SUdYRjs7O01IYU0sb0JBQVUsRUd1Q2IsRUFBQTtFSHBDRDtJR2hCRjs7O01Ia0JNLG9CQUFVLEVHa0NiLEVBQUE7RUgvQkQ7SUdyQkY7OztNSHVCTSxvQkFBVSxFRzZCYixFQUFBO0VIbkREO0lHREY7OztNSEdNLHVCQUFVLEVHaURiLEVBQUE7RUg5Q0Q7SUdORjs7O01IUU0sdUJBQVUsRUc0Q2IsRUFBQTtFSHpDRDtJR1hGOzs7TUhhTSx1QkFBVSxFR3VDYixFQUFBO0VIcENEO0lHaEJGOzs7TUhrQk0sdUJBQVUsRUdrQ2IsRUFBQTtFSC9CRDtJR3JCRjs7O01IdUJNLHVCQUFVLEVHNkJiLEVBQUE7RUFwREg7OztJQW9DTSxjQUFhLEVBQ2Q7RUFFRDtJQXZDSjs7O01BeUNRLG1CQUFrQjtNQUNsQixZQUFXO01BQ1gsT0FBTTtNQUNOLFNBQVE7TUFDUixTQUFRO01BQ1IsVUFBUztNQUNULHFDQUFtRDtNQUNuRCx3Q0FBc0Q7TUFDdEQsOEJKN0NFLEVJOENILEVBQUE7O0FBbERQO0VBdURJLDJCSjdDaUI7RUk4Q2pCLHdDSjdDbUMsRUlzRHBDO0VBakVIO0lBMkRNLGdCQUFlLEVBS2hCO0lBaEVMO01BOERRLGNKcERhLEVJcURkOztBQS9EUDtFQW9FSSwyQkp4RFU7RUl5RFYseUNKeEQwQixFSWlFM0I7RUE5RUg7SUF3RU0sZ0JBQWUsRUFLaEI7SUE3RUw7TUEyRVEsY0ovRE0sRUlnRVA7O0FBNUVQO0VBaUZJLDJCSm5FYTtFSW9FYiwwQ0puRWlDLEVJNEVsQztFQTNGSDtJQXFGTSxnQkFBZSxFQUtoQjtJQTFGTDtNQXdGUSxjSjFFUyxFSTJFVjs7QUh4Rkw7RUdERjtJSEdNLGtCQUFVLEVHNEZiLEVBQUE7O0FIekZEO0VHTkY7SUhRTSxrQkFBVSxFR3VGYixFQUFBOztBSHBGRDtFR1hGO0lIYU0sa0JBQVUsRUdrRmIsRUFBQTs7QUgvRUQ7RUdoQkY7SUhrQk0sa0JBQVUsRUc2RWIsRUFBQTs7QUgxRUQ7RUdyQkY7SUh1Qk0sa0JBQVUsRUd3RWIsRUFBQTs7QUEvRkg7RUFrR0ksVUFBUztFQUNULGlCQUFnQixFQWFqQjtFSC9HRDtJR0RGO01IR00saUJBQVUsRUc2R2IsRUFBQTtFSDFHRDtJR05GO01IUU0saUJBQVUsRUd3R2IsRUFBQTtFSHJHRDtJR1hGO01IYU0sa0JBQVUsRUdtR2IsRUFBQTtFSGhHRDtJR2hCRjtNSGtCTSxrQkFBVSxFRzhGYixFQUFBO0VIM0ZEO0lHckJGO01IdUJNLGtCQUFVLEVHeUZiLEVBQUE7RUFoSEg7SUF1R00sZUFBYyxFQVFmO0lBL0dMO01BMEdRLGlCSmpGUSxFSWtGVDtJQTNHUDtNQTZHUSxnQkozRWMsRUk0RWY7O0FIN0dMO0VHREY7SUhHTSxnQkFBVSxFR2lIYixFQUFBOztBSDlHRDtFR05GO0lIUU0sZ0JBQVUsRUc0R2IsRUFBQTs7QUh6R0Q7RUdYRjtJSGFNLGlCQUFVLEVHdUdiLEVBQUE7O0FIcEdEO0VHaEJGO0lIa0JNLGlCQUFVLEVHa0diLEVBQUE7O0FIL0ZEO0VHckJGO0lIdUJNLGlCQUFVLEVHNkZiLEVBQUE7O0FBcEhIO0VBc0hJLGNBQWEsRUFDZDs7QUh0SEQ7RUdERjtJSEdNLGdCQUFVLEVHd0hiLEVBQUE7O0FIckhEO0VHTkY7SUhRTSxnQkFBVSxFR21IYixFQUFBOztBSGhIRDtFR1hGO0lIYU0sZ0JBQVUsRUc4R2IsRUFBQTs7QUgzR0Q7RUdoQkY7SUhrQk0sZ0JBQVUsRUd5R2IsRUFBQTs7QUh0R0Q7RUdyQkY7SUh1Qk0sZ0JBQVUsRUdvR2IsRUFBQTs7QUgxSEQ7RUdERjtJSEdNLGtCQUFVLEVHd0hiLEVBQUE7O0FIckhEO0VHTkY7SUhRTSxrQkFBVSxFR21IYixFQUFBOztBSGhIRDtFR1hGO0lIYU0sa0JBQVUsRUc4R2IsRUFBQTs7QUgzR0Q7RUdoQkY7SUhrQk0sa0JBQVUsRUd5R2IsRUFBQTs7QUh0R0Q7RUdyQkY7SUh1Qk0sa0JBQVUsRUdvR2IsRUFBQVwiLFwiZmlsZVwiOlwiaW5kZXguc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAZm9udC1mYWNle1xcblxcdGZvbnQtZmFtaWx5OiBTY29wZU9uZTtcXG5cXHRmb250LXdlaWdodDogNDAwO1xcblxcdHNyYzogdXJsKC4uL2ZvbnRzL3Njb3BlLW9uZS5yZWd1bGFyLndvZmYpIGZvcm1hdChcXFwid29mZlxcXCIpO1xcbn1cXG5AZm9udC1mYWNle1xcblxcdGZvbnQtZmFtaWx5OiAnT3BlbiBTYW5zJztcXG5cXHRmb250LXdlaWdodDogNDAwO1xcblxcdHNyYzogdXJsKC4uL2ZvbnRzL29wZW4tc2Fucy5yZWd1bGFyLndvZmYpIGZvcm1hdChcXFwid29mZlxcXCIpO1xcbn1cXG5AZm9udC1mYWNle1xcblxcdGZvbnQtZmFtaWx5OiAnT3BlbiBTYW5zJztcXG5cXHRmb250LXdlaWdodDogNDAwO1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcblxcdHNyYzogdXJsKC4uL2ZvbnRzL29wZW4tc2Fucy5pdGFsaWMud29mZikgZm9ybWF0KFxcXCJ3b2ZmXFxcIik7XFxufVxcblwiLFwiaHRtbCxcXG5ib2R5IHtcXG4gIGJhY2tncm91bmQ6ICRiZztcXG4gIGNvbG9yOiAkZmc7XFxuICBmb250LWZhbWlseTogJ09wZW4gU2FucycsIHNhbnMtc2VyaWY7XFxuICBmb250LXNpemU6ICRmb250LWJhc2U7XFxufVxcblxcbmJvZHkge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBtaW4taGVpZ2h0OiAxMDB2aDtcXG5cXG4gID4gLnNpdGUtY29udGFpbmVyIHtcXG4gICAgZmxleC1ncm93OiAxO1xcbiAgfVxcbn1cXG5cXG5oMSxcXG5oMixcXG5oMyxcXG5oNCB7XFxuICBmb250LWZhbWlseTogU2NvcGVPbmUsIHNlcmlmO1xcbn1cXG5cXG5oMSxcXG5oMixcXG5oMyxcXG5oNCxcXG5oNSxcXG5oNiB7XFxuICBmb250LXdlaWdodDogNDAwO1xcbn1cXG5cXG5oMSxcXG5oMixcXG5oMyxcXG5oNCxcXG5oNSxcXG5oNixcXG5wLFxcbnVsLFxcbm9sLFxcbmxpLFxcbmJ1dHRvbiB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG5oMSxcXG5oMixcXG5oMyxcXG5oNCxcXG5oNSxcXG5oNixcXG5saSB7XFxuICBsaW5lLWhlaWdodDogMTtcXG59XFxuXFxuYnV0dG9uIHtcXG4gIGJvcmRlcjogMDtcXG4gIG91dGxpbmU6IG5vbmUgIWltcG9ydGFudDtcXG4gIGJhY2tncm91bmQ6IG5vbmU7XFxuICBib3JkZXItaW1hZ2Utd2lkdGg6IDA7XFxuICBmb250LXNpemU6IDA7XFxufVxcblxcbnAge1xcbiAgbGluZS1oZWlnaHQ6IDEuMztcXG59XFxuXFxuaDEge1xcbiAgZm9udC1zaXplOiAkZm9udC1oMTtcXG59XFxuaDIge1xcbiAgZm9udC1zaXplOiAkZm9udC14bDtcXG59XFxuaDMge1xcbiAgZm9udC1zaXplOiAkZm9udC1sZztcXG59XFxuaDQge1xcbiAgZm9udC1zaXplOiAkZm9udC1tZDtcXG59XFxuaDUge1xcbiAgZm9udC1zaXplOiAkZm9udC1zbTtcXG4gIG1hcmdpbi1ib3R0b206ICR4eHM7XFxufVxcblxcbmEge1xcbiAgY29sb3I6ICRsaW5rO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbn1cXG5cXG5wLm5vdGUge1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcbn1cXG5cXG5wLFxcbmRkLFxcbmR0IHtcXG4gIEBpbmNsdWRlIHBlci1zaXplKFxcbiAgICAnZm9udC1zaXplJyxcXG4gICAgJGZvbnQteHMsXFxuICAgICRmb250LXhzLFxcbiAgICAkZm9udC1iYXNlLFxcbiAgICAkZm9udC1iYXNlLFxcbiAgICAkZm9udC1iYXNlXFxuICApO1xcbn1cXG5cXG51bDpub3QoLm5vcm1hbC1saXN0KSxcXG5vbDpub3QoLm5vcm1hbC1saXN0KSB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbn1cXG5cXG4uc2l0ZS1jb250YWluZXIge1xcbiAgbWFyZ2luOiAwIGF1dG87XFxuICBtYXgtd2lkdGg6ICRzaXRlLXdpZHRoO1xcblxcbiAgQGluY2x1ZGUgcGVyLXNpemUoKCdwYWRkaW5nLWxlZnQnLCAncGFkZGluZy1yaWdodCcpLCAkeHMsICR4cywgJHNtLCAkbWQsICRsZyk7XFxufVxcblxcbm1haW4gPiBzZWN0aW9uIHtcXG4gIEBpbmNsdWRlIHBlci1zaXplKCdtYXJnaW4tdG9wJywgJG1kLCAkbWQsICRsZywgJGxnLCAkbGcpO1xcblxcbiAgaDMge1xcbiAgICBjb2xvcjogJGFjY2VudDtcXG4gICAgQGluY2x1ZGUgcGVyLXNpemUoXFxuICAgICAgJ2ZvbnQtc2l6ZScsXFxuICAgICAgJGZvbnQtbGcsXFxuICAgICAgJGZvbnQtbGcsXFxuICAgICAgJGZvbnQteGwsXFxuICAgICAgJGZvbnQteGwsXFxuICAgICAgJGZvbnQteGxcXG4gICAgKTtcXG4gICAgbWFyZ2luLWJvdHRvbTogJHhzO1xcbiAgfVxcblxcbiAgaDQge1xcbiAgICBtYXJnaW4tdG9wOiAkc207XFxuICB9XFxuICBoNSB7XFxuICAgIG1hcmdpbi10b3A6ICR4cztcXG4gIH1cXG4gIHAgKyBwIHtcXG4gICAgbWFyZ2luLXRvcDogJHh4cztcXG4gIH1cXG4gIHAgKyB1bCB7XFxuICAgIG1hcmdpbi10b3A6ICR4cztcXG4gIH1cXG5cXG4gIGg0IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogJHh4cztcXG5cXG4gICAgJjpiZWZvcmUge1xcbiAgICAgIGNvbnRlbnQ6ICcgLSAnO1xcbiAgICB9XFxuICB9XFxufVxcblxcbmJ1dHRvbi5leHBhbmRlciA+IHN2ZyB7XFxuICBoZWlnaHQ6ICRwcm9qZWN0LWhlaWdodDtcXG4gIHdpZHRoOiAkcHJvamVjdC1oZWlnaHQ7XFxufVxcblxcbi5zaWRlbm90ZSB7XFxuICBmb250LXN0eWxlOiBpdGFsaWM7XFxufVxcblxcbmJ1dHRvbiB7XFxuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG5cIixcIi8vLS0tLS0tLS0vL1xcbi8vIENvbG9ycyAvL1xcbi8vLS0tLS0tLS0vL1xcblxcbiRiZzogd2hpdGU7XFxuJGJnLW9mZjogI2U5ZTllOTtcXG4kZmc6ICMxMzEzMTM7XFxuJGxpbms6ICMyNDU3YjA7XFxuJGFjY2VudDogI2EzMjUwMDtcXG5cXG4kYXBwbGljYXRpb246ICMxOTYxMGQ7XFxuJGFwcGxpY2F0aW9uLWJnOiBmYWRlX291dCgjMWFiZDAwLCAwLjcpO1xcbiR0b29sOiAjZjBhMzAwO1xcbiR0b29sLWJnOiBmYWRlX291dCgkdG9vbCwgMC43KTtcXG4kbGlicmFyeTogIzg0MDA4YTtcXG4kbGlicmFyeS1iZzogZmFkZV9vdXQoJGxpYnJhcnksIDAuODUpO1xcblxcbiRmb290ZXItY29sb3I6ICMzMDMwMzA7XFxuXFxuLy9cXG4vLy0tLS0tLS0vL1xcbi8vIFNpemVzIC8vXFxuLy8tLS0tLS0tLy9cXG5cXG4kc2l0ZS13aWR0aDogMTEwMHB4O1xcbiRmb250LWJhc2U6IDE4cHg7XFxuXFxuLy8gZ2VuZXJhbCBwdXJwb3NlIGVsZW1lbnQgc3BhY2luZ1xcblxcbiR4bDogcm91bmQoJGZvbnQtYmFzZSAqIDMuNSk7XFxuJGxnOiAoJGZvbnQtYmFzZSAqIDMpO1xcbiRtZDogKCRmb250LWJhc2UgKiAyKTtcXG4kc206ICRmb250LWJhc2UgKyAoJGZvbnQtYmFzZSAvIDIpO1xcbiR4czogJGZvbnQtYmFzZTtcXG4keHhzOiAoJGZvbnQtYmFzZSAvIDIpO1xcblxcbi8vIGZvbnQtc2l6ZXNcXG5cXG4kZm9udC1oMTogNDhweDtcXG4kZm9udC14bDogMzJweDtcXG4kZm9udC1sZzogMjZweDtcXG4kZm9udC1tZDogMjNweDtcXG4kZm9udC1zbTogMjBweDtcXG4kZm9udC14czogMTZweDtcXG4kZm9udC14eHM6IDE1cHg7XFxuXFxuLy8gc2xpZ2h0bHkgbW9kaWZpZWQgZnJvbSBib290c3RyYXBcXG4kc2NyZWVuLXhzLW1pbjogNDgwcHg7XFxuJHNjcmVlbi1zbS1taW46IDc2OHB4O1xcbiRzY3JlZW4tbWQtbWluOiA5OTJweDtcXG4kc2NyZWVuLWxnLW1pbjogMTIwMHB4O1xcblxcbiRzY3JlZW4teHhzLW1heDogKCRzY3JlZW4teHMtbWluIC0gMSk7XFxuJHNjcmVlbi14cy1tYXg6ICgkc2NyZWVuLXNtLW1pbiAtIDEpO1xcbiRzY3JlZW4tc20tbWF4OiAoJHNjcmVlbi1tZC1taW4gLSAxKTtcXG4kc2NyZWVuLW1kLW1heDogKCRzY3JlZW4tbGctbWluIC0gMSk7XFxuXFxuLy8gY29udGV4dC1zcGVjaWZpY1xcblxcbiRwcm9qZWN0LWhlaWdodDogJHh4cyArICR4eHMgKyAkZm9udC1tZDtcXG5cIixcIkBtaXhpbiBwZXItc2l6ZSgkcHJvcC1saXN0LCAkeHhzLCAkeHMsICRzbSwgJG1kLCAkbGcsICR1bml0OiBudWxsKSB7XFxuICBAbWVkaWEgKG1heC13aWR0aDogJHNjcmVlbi14eHMtbWF4KSB7XFxuICAgIEBlYWNoICRwcm9wIGluICRwcm9wLWxpc3Qge1xcbiAgICAgICN7JHByb3B9OiAjeyR4eHN9I3skdW5pdH07XFxuICAgIH1cXG4gIH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiAkc2NyZWVuLXhzLW1pbikgYW5kIChtYXgtd2lkdGg6ICRzY3JlZW4teHMtbWF4KSB7XFxuICAgIEBlYWNoICRwcm9wIGluICRwcm9wLWxpc3Qge1xcbiAgICAgICN7JHByb3B9OiAjeyR4c30jeyR1bml0fTtcXG4gICAgfVxcbiAgfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6ICRzY3JlZW4tc20tbWluKSBhbmQgKG1heC13aWR0aDogJHNjcmVlbi1zbS1tYXgpIHtcXG4gICAgQGVhY2ggJHByb3AgaW4gJHByb3AtbGlzdCB7XFxuICAgICAgI3skcHJvcH06ICN7JHNtfSN7JHVuaXR9O1xcbiAgICB9XFxuICB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogJHNjcmVlbi1tZC1taW4pIGFuZCAobWF4LXdpZHRoOiAkc2NyZWVuLW1kLW1heCkge1xcbiAgICBAZWFjaCAkcHJvcCBpbiAkcHJvcC1saXN0IHtcXG4gICAgICAjeyRwcm9wfTogI3skbWR9I3skdW5pdH07XFxuICAgIH1cXG4gIH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiAkc2NyZWVuLWxnLW1pbikge1xcbiAgICBAZWFjaCAkcHJvcCBpbiAkcHJvcC1saXN0IHtcXG4gICAgICAjeyRwcm9wfTogI3skbGd9I3skdW5pdH07XFxuICAgIH1cXG4gIH1cXG59XFxuXCIsXCJmb290ZXIge1xcbiAgQGluY2x1ZGUgcGVyLXNpemUoKCdoZWlnaHQnLCAnbGluZS1oZWlnaHQnKSwgODAsIDgwLCAxMTAsIDExMCwgMTEwLCAncHgnKTtcXG4gIEBpbmNsdWRlIHBlci1zaXplKCdtYXJnaW4tdG9wJywgJG1kLCAkbWQsICRsZywgJGxnLCAkbGcpO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogJGZvb3Rlci1jb2xvcjtcXG4gIGNvbG9yOiAkYmc7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuXFxuICAuZW1haWwge1xcbiAgICBAaW5jbHVkZSBwZXItc2l6ZSgoJ21hcmdpbi1yaWdodCcpLCAyMCwgMjAsIDMwLCAzMCwgMzAsICdweCcpO1xcbiAgICBAaW5jbHVkZSBwZXItc2l6ZShcXG4gICAgICAnZm9udC1zaXplJyxcXG4gICAgICAkZm9udC14eHMsXFxuICAgICAgJGZvbnQteHhzLFxcbiAgICAgICRmb250LXhzLFxcbiAgICAgICRmb250LXhzLFxcbiAgICAgICRmb250LXhzXFxuICAgICk7XFxuXFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICB9XFxuXFxuICAub2N0aWNvbiB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIEBpbmNsdWRlIHBlci1zaXplKCdoZWlnaHQnLCA1MCwgNTAsIDcwLCA3MCwgNzAsICdweCcpO1xcbiAgICBAaW5jbHVkZSBwZXItc2l6ZShcXG4gICAgICAoJ21hcmdpbi10b3AnLCAnbWFyZ2luLWJvdHRvbScpLFxcbiAgICAgIDEwLFxcbiAgICAgIDEwLFxcbiAgICAgIDE1LFxcbiAgICAgIDE1LFxcbiAgICAgIDE1LFxcbiAgICAgICdweCdcXG4gICAgKTtcXG4gICAgcGF0aCB7XFxuICAgICAgZmlsbDogJGJnO1xcbiAgICB9XFxuICB9XFxufVxcblwiLFwiaGVhZGVyIHtcXG4gIEBpbmNsdWRlIHBlci1zaXplKCdtYXJnaW4tdG9wJywgJHNtLCAkc20sICRtZCwgJGxnLCAkeGwpO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcblxcbiAgaDEge1xcbiAgICBtYXJnaW4tYm90dG9tOiAkeHM7XFxuICB9XFxuXFxuICBpbWcge1xcbiAgICBAaW5jbHVkZSBwZXItc2l6ZSgnaGVpZ2h0JywgJzE4MCcsICcxODAnLCAnMTgwJywgJzIyMCcsICcyMjAnLCAncHgnKTtcXG4gICAgbWFyZ2luLWJvdHRvbTogJHhzO1xcbiAgfVxcblxcbiAgaDMge1xcbiAgICBAaW5jbHVkZSBwZXItc2l6ZSgnbWFyZ2luLWJvdHRvbScsICRzbSwgJHNtLCAkbWQsICRtZCwgJG1kKTtcXG4gIH1cXG5cXG4gIHAge1xcbiAgICBAaW5jbHVkZSBwZXItc2l6ZSgnbWFyZ2luLWJvdHRvbScsICRzbSwgJHNtLCAkbWQsICRtZCwgJG1kKTtcXG4gICAgZm9udC1zdHlsZTogaXRhbGljO1xcblxcbiAgICBAaW5jbHVkZSBwZXItc2l6ZSgnZm9udC1zaXplJywgJGZvbnQteHhzLCAkZm9udC14cywgJGZvbnQtYmFzZSwgJGZvbnQtYmFzZSwgJGZvbnQtYmFzZSk7XFxuICB9XFxuXFxuICBuYXYge1xcbiAgICBAaW5jbHVkZSBwZXItc2l6ZSgnZm9udC1zaXplJywgJGZvbnQtbGcsICRmb250LWxnLCAkZm9udC14bCwgJGZvbnQteGwsICRmb250LXhsKTtcXG4gICAgZm9udC1mYW1pbHk6IFNjb3BlT25lLCBzZXJpZjtcXG5cXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6ICRzY3JlZW4tc20tbWF4KSB7XFxuICAgICAgbGkgKyBsaSB7XFxuICAgICAgICBtYXJnaW4tdG9wOiAkeHM7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiAkc2NyZWVuLW1kLW1pbikge1xcbiAgICAgIGxpIHtcXG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICB9XFxuICAgICAgbGkgKyBsaTpiZWZvcmUge1xcbiAgICAgICAgY29udGVudDogXFxcIi9cXFwiO1xcbiAgICAgICAgQGluY2x1ZGUgcGVyLXNpemUoKCdtYXJnaW4tbGVmdCcsICdtYXJnaW4tcmlnaHQnKSwgJHh4cywgJHhzLCAkeHMsICRzbSwgJHNtKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59XFxuXCIsXCIjc2lkZS1wcm9qZWN0cyB7XFxuICBoNCB7XFxuICAgIG1hcmdpbi1ib3R0b206ICR4cztcXG4gIH1cXG5cXG4gIHVsLmxlZ2VuZCA+IGxpICsgbGkge1xcbiAgICBtYXJnaW4tdG9wOiAkeHhzO1xcbiAgfVxcblxcbiAgPiB1bDpub3QoLmxlZ2VuZCkgPiBsaSArIGxpIHtcXG4gICAgbWFyZ2luLXRvcDogJHNtO1xcbiAgfVxcblxcbiAgLmFwcGxpY2F0aW9uLFxcbiAgLnRvb2wsXFxuICAubGlicmFyeSB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuICAgIG1hcmdpbi10b3A6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IDA7XFxuICAgIGJvcmRlci1sZWZ0LXN0eWxlOiBzb2xpZDtcXG4gICAgcGFkZGluZy10b3A6ICR4eHM7XFxuICAgIHBhZGRpbmctYm90dG9tOiAkeHhzO1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgQGluY2x1ZGUgcGVyLXNpemUoJ3BhZGRpbmctbGVmdCcsICR4eHMsICRtZCwgJG1kLCAkbGcsICRsZyk7XFxuICAgIEBpbmNsdWRlIHBlci1zaXplKFxcbiAgICAgICdwYWRkaW5nLXJpZ2h0JyxcXG4gICAgICAkeHhzLFxcbiAgICAgICgkbWQgKyAkeHhzKSxcXG4gICAgICAoJG1kICsgJHh4cyksXFxuICAgICAgKCRsZyArICR4eHMpLFxcbiAgICAgICgkbGcgKyAkeHhzKVxcbiAgICApO1xcbiAgICBAaW5jbHVkZSBwZXItc2l6ZSgnYm9yZGVyLWxlZnQtd2lkdGgnLCAyLCAyLCAzLCAzLCAzLCAncHgnKTtcXG5cXG4gICAgJjpiZWZvcmUge1xcbiAgICAgIGNvbnRlbnQ6IG5vbmU7XFxuICAgIH1cXG5cXG4gICAgQG1lZGlhIChtaW4td2lkdGg6ICRzY3JlZW4teHMtbWluKSB7XFxuICAgICAgJjphZnRlciB7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICBjb250ZW50OiAnJztcXG4gICAgICAgIHRvcDogMDtcXG4gICAgICAgIHJpZ2h0OiAwO1xcbiAgICAgICAgd2lkdGg6IDA7XFxuICAgICAgICBoZWlnaHQ6IDA7XFxuICAgICAgICBib3JkZXItdG9wOiAoJHByb2plY3QtaGVpZ2h0IC8gMikgc29saWQgdHJhbnNwYXJlbnQ7XFxuICAgICAgICBib3JkZXItYm90dG9tOiAoJHByb2plY3QtaGVpZ2h0IC8gMikgc29saWQgdHJhbnNwYXJlbnQ7XFxuICAgICAgICBib3JkZXItcmlnaHQ6ICR4eHMgc29saWQgJGJnO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgLmFwcGxpY2F0aW9uIHtcXG4gICAgYm9yZGVyLWxlZnQtY29sb3I6ICRhcHBsaWNhdGlvbjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJGFwcGxpY2F0aW9uLWJnO1xcblxcbiAgICArIGJ1dHRvbiB7XFxuICAgICAgY3Vyc29yOiBwb2ludGVyO1xcblxcbiAgICAgIHN2ZyBwYXRoIHtcXG4gICAgICAgIGZpbGw6ICRhcHBsaWNhdGlvbjtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIC50b29sIHtcXG4gICAgYm9yZGVyLWxlZnQtY29sb3I6ICR0b29sO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkdG9vbC1iZztcXG5cXG4gICAgKyBidXR0b24ge1xcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG5cXG4gICAgICBzdmcgcGF0aCB7XFxuICAgICAgICBmaWxsOiAkdG9vbDtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIC5saWJyYXJ5IHtcXG4gICAgYm9yZGVyLWxlZnQtY29sb3I6ICRsaWJyYXJ5O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkbGlicmFyeS1iZztcXG5cXG4gICAgKyBidXR0b24ge1xcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG5cXG4gICAgICBzdmcgcGF0aCB7XFxuICAgICAgICBmaWxsOiAkbGlicmFyeTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGJ1dHRvbiB7XFxuICAgIEBpbmNsdWRlIHBlci1zaXplKCdtYXJnaW4tbGVmdCcsICR4cywgJHNtLCAkc20sICRtZCwgJG1kKTtcXG4gIH1cXG5cXG4gIC5jb250ZW50IHtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICBAaW5jbHVkZSBwZXItc2l6ZSgnbWFyZ2luLWxlZnQnLCAkeHhzLCAkeHhzLCAkeHMsICR4cywgJHhzKTtcXG5cXG4gICAgPiBhIHtcXG4gICAgICBkaXNwbGF5OiBibG9jaztcXG5cXG4gICAgICAmOmZpcnN0LWNoaWxkIHtcXG4gICAgICAgIG1hcmdpbi10b3A6ICR4cztcXG4gICAgICB9XFxuICAgICAgJjpub3QoOmZpcnN0LWNoaWxkKSB7XFxuICAgICAgICBtYXJnaW4tdG9wOiAkeHhzO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZGQgKyBkdCB7XFxuICAgIEBpbmNsdWRlIHBlci1zaXplKCdtYXJnaW4tdG9wJywgJHh4cywgJHh4cywgJHhzLCAkeHMsICR4cyk7XFxuICB9XFxuICBkdDpiZWZvcmUge1xcbiAgICBjb250ZW50OiAnLSAnO1xcbiAgfVxcbiAgZGQge1xcbiAgICBAaW5jbHVkZSBwZXItc2l6ZSgnbWFyZ2luLXRvcCcsIDMsIDMsIDQsIDQsIDUsICdweCcpO1xcbiAgICBAaW5jbHVkZSBwZXItc2l6ZSgnbWFyZ2luLWxlZnQnLCAkeHMsICR4cywgJHhzLCAkc20sICRzbSk7XFxuICB9XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js??ref--8-1!./node_modules/sass-loader/lib/loader.js??ref--8-2!./client/scss/index.scss\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/css-base.js\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/url/escape.js":
/*!***************************************************!*\
  !*** ./node_modules/css-loader/lib/url/escape.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi91cmwvZXNjYXBlLmpzP2IwNDEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlc2NhcGUodXJsKSB7XG4gICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB1cmxcbiAgICB9XG4gICAgLy8gSWYgdXJsIGlzIGFscmVhZHkgd3JhcHBlZCBpbiBxdW90ZXMsIHJlbW92ZSB0aGVtXG4gICAgaWYgKC9eWydcIl0uKlsnXCJdJC8udGVzdCh1cmwpKSB7XG4gICAgICAgIHVybCA9IHVybC5zbGljZSgxLCAtMSk7XG4gICAgfVxuICAgIC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuICAgIGlmICgvW1wiJygpIFxcdFxcbl0vLnRlc3QodXJsKSkge1xuICAgICAgICByZXR1cm4gJ1wiJyArIHVybC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpICsgJ1wiJ1xuICAgIH1cblxuICAgIHJldHVybiB1cmxcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/url/escape.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/array.js":
/*!*********************************************!*\
  !*** ./node_modules/domtastic/src/array.js ***!
  \*********************************************/
/*! exports provided: every, filter, forEach, each, indexOf, map, pop, push, reduce, reduceRight, reverse, shift, some, unshift */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"every\", function() { return every; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"filter\", function() { return filter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"each\", function() { return each; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"indexOf\", function() { return indexOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"map\", function() { return map; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pop\", function() { return pop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"push\", function() { return push; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reduce\", function() { return reduce; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reduceRight\", function() { return reduceRight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reverse\", function() { return reverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shift\", function() { return shift; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"some\", function() { return some; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unshift\", function() { return unshift; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./node_modules/domtastic/src/util.js\");\n/* harmony import */ var _selector_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selector/index */ \"./node_modules/domtastic/src/selector/index.js\");\n/**\n * @module Array\n */\n\n\n\n\nconst ArrayProto = Array.prototype;\n\n/**\n * Checks if the given callback returns a true(-ish) value for each element in the collection.\n *\n * @param {Function} callback Function to execute for each element, invoked with `element` as argument.\n * @param {Object} [thisArg] Value to use as `this` when executing `callback`.\n * @return {Boolean} Whether each element passed the callback check.\n * @example\n *     // Test whether every element in the collection has the \"active\" attribute\n *     $('.items').every(function(element) {\n *         return element.hasAttribute('active')\n *     });\n */\n\nconst every = ArrayProto.every;\n\n/**\n * Filter the collection by selector or function, and return a new collection with the result.\n *\n * @param {String|Function} selector Selector or function to filter the collection.\n * @param {Object} [thisArg] Value to use as `this` when executing `callback`.\n * @return {Object} A new wrapped collection\n * @chainable\n * @example\n *     $('.items').filter('.active');\n * @example\n *     $('.items').filter(function(element) {\n *         return element.hasAttribute('active')\n *     });\n */\n\nconst filter = function(selector, thisArg) {\n  const callback = typeof selector === 'function' ? selector : element => Object(_selector_index__WEBPACK_IMPORTED_MODULE_1__[\"matches\"])(element, selector);\n  return Object(_selector_index__WEBPACK_IMPORTED_MODULE_1__[\"$\"])(ArrayProto.filter.call(this, callback, thisArg));\n};\n\n/**\n * Execute a function for each element in the collection.\n *\n * @param {Function} callback Function to execute for each element, invoked with `element` as argument.\n * @param {Object} [thisArg] Value to use as `this` when executing `callback`.\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.items').forEach(function(element) {\n *         element.style.color = 'evergreen';\n *     );\n */\n\nconst forEach = function(callback, thisArg) {\n  return Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, callback, thisArg);\n};\n\nconst each = forEach;\n\n/**\n * Returns the index of an element in the collection.\n *\n * @param {Node} element\n * @return {Number} The zero-based index, -1 if not found.\n * @example\n *     $('.items').indexOf(element); // 2\n */\n\nconst indexOf = ArrayProto.indexOf;\n\n/**\n * Create a new collection by executing the callback for each element in the collection.\n *\n * @param {Function} callback Function to execute for each element, invoked with `element` as argument.\n * @param {Object} [thisArg] Value to use as `this` when executing `callback`.\n * @return {Array} Collection with the return value of the executed callback for each element.\n * @example\n *     // Create a new array with the attribute value of each element:\n *     $('.items').map(function(element) {\n *         return element.getAttribute('name')\n */\n\nconst map = ArrayProto.map;\n\n/**\n * Removes the last element from the collection, and returns that element.\n *\n * @return {Object} The last element from the collection.\n * @example\n *     var lastElement = $('.items').pop();\n */\n\nconst pop = ArrayProto.pop;\n\n/**\n * Adds one or more elements to the end of the collection, and returns the new length of the collection.\n *\n * @param {Object} element Element(s) to add to the collection\n * @return {Number} The new length of the collection\n * @example\n *     $('.items').push(element);\n */\n\nconst push = ArrayProto.push;\n\n/**\n * Apply a function against each element in the collection, and this accumulator function has to reduce it\n * to a single value.\n *\n * @param {Function} callback Function to execute on each value in the array, taking four arguments (see example).\n * @param {Mixed} initialValue Object to use as the first argument to the first call of the callback.\n * @example\n *     // Calculate the combined height of elements:\n *     $('.items').reduce(function(previousValue, element, index, collection) {\n *         return previousValue + element.clientHeight;\n *     }, 0);\n */\n\nconst reduce = ArrayProto.reduce;\n\n/**\n * Apply a function against each element in the collection (from right-to-left), and this accumulator function has\n * to reduce it to a single value.\n *\n * @param {Function} callback Function to execute on each value in the array, taking four arguments (see example).\n * @param {Mixed} initialValue Object to use as the first argument to the first call of the callback.\n * @example\n *     // Concatenate the text of elements in reversed order:\n *     $('.items').reduceRight(function(previousValue, element, index, collection) {\n *         return previousValue + element.textContent;\n *     }, '');\n */\n\nconst reduceRight = ArrayProto.reduceRight;\n\n/**\n * Reverses an array in place. The first array element becomes the last and the last becomes the first.\n *\n * @return {Object} The wrapped collection, reversed\n * @chainable\n * @example\n *     $('.items').reverse();\n */\n\nconst reverse = function() {\n  return Object(_selector_index__WEBPACK_IMPORTED_MODULE_1__[\"$\"])(Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(this).reverse());\n};\n\n/**\n * Removes the first element from the collection, and returns that element.\n *\n * @return {Object} The first element from the collection.\n * @example\n *     var firstElement = $('.items').shift();\n */\n\nconst shift = ArrayProto.shift;\n\n/**\n * Checks if the given callback returns a true(-ish) value for any of the elements in the collection.\n *\n * @param {Function} callback Function to execute for each element, invoked with `element` as argument.\n * @return {Boolean} Whether any element passed the callback check.\n * @example\n *     $('.items').some(function(element) {\n *         return element.hasAttribute('active')\n *     }); // true/false\n */\n\nconst some = ArrayProto.some;\n\n/**\n * Adds one or more elements to the beginning of the collection, and returns the new length of the collection.\n *\n * @param {Object} element Element(s) to add to the collection\n * @return {Number} The new length of the collection\n * @example\n *     $('.items').unshift(element);\n */\n\nconst unshift = ArrayProto.unshift;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9hcnJheS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb210YXN0aWMvc3JjL2FycmF5LmpzPzlkNzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIEFycmF5XG4gKi9cblxuaW1wb3J0IHsgZWFjaCBhcyBfZWFjaCwgdG9BcnJheSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyAkLCBtYXRjaGVzIH0gZnJvbSAnLi9zZWxlY3Rvci9pbmRleCc7XG5cbmNvbnN0IEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBjYWxsYmFjayByZXR1cm5zIGEgdHJ1ZSgtaXNoKSB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZWxlbWVudCwgaW52b2tlZCB3aXRoIGBlbGVtZW50YCBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbdGhpc0FyZ10gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgY2FsbGJhY2tgLlxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBlYWNoIGVsZW1lbnQgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjay5cbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gVGVzdCB3aGV0aGVyIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb24gaGFzIHRoZSBcImFjdGl2ZVwiIGF0dHJpYnV0ZVxuICogICAgICQoJy5pdGVtcycpLmV2ZXJ5KGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAqICAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdhY3RpdmUnKVxuICogICAgIH0pO1xuICovXG5cbmV4cG9ydCBjb25zdCBldmVyeSA9IEFycmF5UHJvdG8uZXZlcnk7XG5cbi8qKlxuICogRmlsdGVyIHRoZSBjb2xsZWN0aW9uIGJ5IHNlbGVjdG9yIG9yIGZ1bmN0aW9uLCBhbmQgcmV0dXJuIGEgbmV3IGNvbGxlY3Rpb24gd2l0aCB0aGUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBTZWxlY3RvciBvciBmdW5jdGlvbiB0byBmaWx0ZXIgdGhlIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gW3RoaXNBcmddIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGNhbGxiYWNrYC5cbiAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgd3JhcHBlZCBjb2xsZWN0aW9uXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5pdGVtcycpLmZpbHRlcignLmFjdGl2ZScpO1xuICogQGV4YW1wbGVcbiAqICAgICAkKCcuaXRlbXMnKS5maWx0ZXIoZnVuY3Rpb24oZWxlbWVudCkge1xuICogICAgICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2FjdGl2ZScpXG4gKiAgICAgfSk7XG4gKi9cblxuZXhwb3J0IGNvbnN0IGZpbHRlciA9IGZ1bmN0aW9uKHNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gIGNvbnN0IGNhbGxiYWNrID0gdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nID8gc2VsZWN0b3IgOiBlbGVtZW50ID0+IG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpO1xuICByZXR1cm4gJChBcnJheVByb3RvLmZpbHRlci5jYWxsKHRoaXMsIGNhbGxiYWNrLCB0aGlzQXJnKSk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZWxlbWVudCwgaW52b2tlZCB3aXRoIGBlbGVtZW50YCBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbdGhpc0FyZ10gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgY2FsbGJhY2tgLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgd3JhcHBlZCBjb2xsZWN0aW9uXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5pdGVtcycpLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICogICAgICAgICBlbGVtZW50LnN0eWxlLmNvbG9yID0gJ2V2ZXJncmVlbic7XG4gKiAgICAgKTtcbiAqL1xuXG5leHBvcnQgY29uc3QgZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gIHJldHVybiBfZWFjaCh0aGlzLCBjYWxsYmFjaywgdGhpc0FyZyk7XG59O1xuXG5leHBvcnQgY29uc3QgZWFjaCA9IGZvckVhY2g7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgYW4gZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IGVsZW1lbnRcbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIHplcm8tYmFzZWQgaW5kZXgsIC0xIGlmIG5vdCBmb3VuZC5cbiAqIEBleGFtcGxlXG4gKiAgICAgJCgnLml0ZW1zJykuaW5kZXhPZihlbGVtZW50KTsgLy8gMlxuICovXG5cbmV4cG9ydCBjb25zdCBpbmRleE9mID0gQXJyYXlQcm90by5pbmRleE9mO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uIGJ5IGV4ZWN1dGluZyB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVsZW1lbnQsIGludm9rZWQgd2l0aCBgZWxlbWVudGAgYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gW3RoaXNBcmddIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGNhbGxiYWNrYC5cbiAqIEByZXR1cm4ge0FycmF5fSBDb2xsZWN0aW9uIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZXhlY3V0ZWQgY2FsbGJhY2sgZm9yIGVhY2ggZWxlbWVudC5cbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHdpdGggdGhlIGF0dHJpYnV0ZSB2YWx1ZSBvZiBlYWNoIGVsZW1lbnQ6XG4gKiAgICAgJCgnLml0ZW1zJykubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAqICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAqL1xuXG5leHBvcnQgY29uc3QgbWFwID0gQXJyYXlQcm90by5tYXA7XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgbGFzdCBlbGVtZW50IGZyb20gdGhlIGNvbGxlY3Rpb24sIGFuZCByZXR1cm5zIHRoYXQgZWxlbWVudC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBsYXN0IGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIGxhc3RFbGVtZW50ID0gJCgnLml0ZW1zJykucG9wKCk7XG4gKi9cblxuZXhwb3J0IGNvbnN0IHBvcCA9IEFycmF5UHJvdG8ucG9wO1xuXG4vKipcbiAqIEFkZHMgb25lIG9yIG1vcmUgZWxlbWVudHMgdG8gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbiwgYW5kIHJldHVybnMgdGhlIG5ldyBsZW5ndGggb2YgdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgRWxlbWVudChzKSB0byBhZGQgdG8gdGhlIGNvbGxlY3Rpb25cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIG5ldyBsZW5ndGggb2YgdGhlIGNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiAgICAgJCgnLml0ZW1zJykucHVzaChlbGVtZW50KTtcbiAqL1xuXG5leHBvcnQgY29uc3QgcHVzaCA9IEFycmF5UHJvdG8ucHVzaDtcblxuLyoqXG4gKiBBcHBseSBhIGZ1bmN0aW9uIGFnYWluc3QgZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uLCBhbmQgdGhpcyBhY2N1bXVsYXRvciBmdW5jdGlvbiBoYXMgdG8gcmVkdWNlIGl0XG4gKiB0byBhIHNpbmdsZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5LCB0YWtpbmcgZm91ciBhcmd1bWVudHMgKHNlZSBleGFtcGxlKS5cbiAqIEBwYXJhbSB7TWl4ZWR9IGluaXRpYWxWYWx1ZSBPYmplY3QgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIENhbGN1bGF0ZSB0aGUgY29tYmluZWQgaGVpZ2h0IG9mIGVsZW1lbnRzOlxuICogICAgICQoJy5pdGVtcycpLnJlZHVjZShmdW5jdGlvbihwcmV2aW91c1ZhbHVlLCBlbGVtZW50LCBpbmRleCwgY29sbGVjdGlvbikge1xuICogICAgICAgICByZXR1cm4gcHJldmlvdXNWYWx1ZSArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICogICAgIH0sIDApO1xuICovXG5cbmV4cG9ydCBjb25zdCByZWR1Y2UgPSBBcnJheVByb3RvLnJlZHVjZTtcblxuLyoqXG4gKiBBcHBseSBhIGZ1bmN0aW9uIGFnYWluc3QgZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uIChmcm9tIHJpZ2h0LXRvLWxlZnQpLCBhbmQgdGhpcyBhY2N1bXVsYXRvciBmdW5jdGlvbiBoYXNcbiAqIHRvIHJlZHVjZSBpdCB0byBhIHNpbmdsZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5LCB0YWtpbmcgZm91ciBhcmd1bWVudHMgKHNlZSBleGFtcGxlKS5cbiAqIEBwYXJhbSB7TWl4ZWR9IGluaXRpYWxWYWx1ZSBPYmplY3QgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIENvbmNhdGVuYXRlIHRoZSB0ZXh0IG9mIGVsZW1lbnRzIGluIHJldmVyc2VkIG9yZGVyOlxuICogICAgICQoJy5pdGVtcycpLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKHByZXZpb3VzVmFsdWUsIGVsZW1lbnQsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gKiAgICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlICsgZWxlbWVudC50ZXh0Q29udGVudDtcbiAqICAgICB9LCAnJyk7XG4gKi9cblxuZXhwb3J0IGNvbnN0IHJlZHVjZVJpZ2h0ID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodDtcblxuLyoqXG4gKiBSZXZlcnNlcyBhbiBhcnJheSBpbiBwbGFjZS4gVGhlIGZpcnN0IGFycmF5IGVsZW1lbnQgYmVjb21lcyB0aGUgbGFzdCBhbmQgdGhlIGxhc3QgYmVjb21lcyB0aGUgZmlyc3QuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgd3JhcHBlZCBjb2xsZWN0aW9uLCByZXZlcnNlZFxuICogQGNoYWluYWJsZVxuICogQGV4YW1wbGVcbiAqICAgICAkKCcuaXRlbXMnKS5yZXZlcnNlKCk7XG4gKi9cblxuZXhwb3J0IGNvbnN0IHJldmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICQodG9BcnJheSh0aGlzKS5yZXZlcnNlKCkpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhlIGNvbGxlY3Rpb24sIGFuZCByZXR1cm5zIHRoYXQgZWxlbWVudC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBmaXJzdEVsZW1lbnQgPSAkKCcuaXRlbXMnKS5zaGlmdCgpO1xuICovXG5cbmV4cG9ydCBjb25zdCBzaGlmdCA9IEFycmF5UHJvdG8uc2hpZnQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBjYWxsYmFjayByZXR1cm5zIGEgdHJ1ZSgtaXNoKSB2YWx1ZSBmb3IgYW55IG9mIHRoZSBlbGVtZW50cyBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVsZW1lbnQsIGludm9rZWQgd2l0aCBgZWxlbWVudGAgYXMgYXJndW1lbnQuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGFueSBlbGVtZW50IHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2suXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5pdGVtcycpLnNvbWUoZnVuY3Rpb24oZWxlbWVudCkge1xuICogICAgICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2FjdGl2ZScpXG4gKiAgICAgfSk7IC8vIHRydWUvZmFsc2VcbiAqL1xuXG5leHBvcnQgY29uc3Qgc29tZSA9IEFycmF5UHJvdG8uc29tZTtcblxuLyoqXG4gKiBBZGRzIG9uZSBvciBtb3JlIGVsZW1lbnRzIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24sIGFuZCByZXR1cm5zIHRoZSBuZXcgbGVuZ3RoIG9mIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IEVsZW1lbnQocykgdG8gYWRkIHRvIHRoZSBjb2xsZWN0aW9uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBuZXcgbGVuZ3RoIG9mIHRoZSBjb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5pdGVtcycpLnVuc2hpZnQoZWxlbWVudCk7XG4gKi9cblxuZXhwb3J0IGNvbnN0IHVuc2hpZnQgPSBBcnJheVByb3RvLnVuc2hpZnQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/array.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/baseClass.js":
/*!*************************************************!*\
  !*** ./node_modules/domtastic/src/baseClass.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _selector_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selector/index */ \"./node_modules/domtastic/src/selector/index.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./node_modules/domtastic/src/util.js\");\n/**\n * @module BaseClass\n */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(api) {\n\n  /**\n   * Provide subclass for classes or components to extend from.\n   * The opposite and successor of plugins (no need to extend `$.fn` anymore, complete control).\n   *\n   * @return {Class} The class to extend from, including all `$.fn` methods.\n   * @example\n   *     import { BaseClass } from  'domtastic';\n   *\n   *     class MyComponent extends BaseClass {\n   *         doSomething() {\n   *             return this.addClass('.foo');\n   *         }\n   *     }\n   *\n   *     let component = new MyComponent('body');\n   *     component.doSomething();\n   *\n   * @example\n   *     import $ from  'domtastic';\n   *\n   *     class MyComponent extends $.BaseClass {\n   *         progress(value) {\n   *             return this.attr('data-progress', value);\n   *         }\n   *     }\n   *\n   *     let component = new MyComponent(document.body);\n   *     component.progress('ive').append('<p>enhancement</p>');\n   */\n\n  class BaseClass {\n    constructor() {\n      _selector_index__WEBPACK_IMPORTED_MODULE_0__[\"DOMtastic\"].call(this, Object(_selector_index__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(...arguments));\n    }\n  }\n  Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])(BaseClass.prototype, api);\n  return BaseClass;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9iYXNlQ2xhc3MuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9iYXNlQ2xhc3MuanM/ZDRjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgQmFzZUNsYXNzXG4gKi9cblxuaW1wb3J0IHsgJCBhcyBzZWxlY3RvciwgRE9NdGFzdGljIH0gZnJvbSAnLi9zZWxlY3Rvci9pbmRleCc7XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhcGkpIHtcblxuICAvKipcbiAgICogUHJvdmlkZSBzdWJjbGFzcyBmb3IgY2xhc3NlcyBvciBjb21wb25lbnRzIHRvIGV4dGVuZCBmcm9tLlxuICAgKiBUaGUgb3Bwb3NpdGUgYW5kIHN1Y2Nlc3NvciBvZiBwbHVnaW5zIChubyBuZWVkIHRvIGV4dGVuZCBgJC5mbmAgYW55bW9yZSwgY29tcGxldGUgY29udHJvbCkuXG4gICAqXG4gICAqIEByZXR1cm4ge0NsYXNzfSBUaGUgY2xhc3MgdG8gZXh0ZW5kIGZyb20sIGluY2x1ZGluZyBhbGwgYCQuZm5gIG1ldGhvZHMuXG4gICAqIEBleGFtcGxlXG4gICAqICAgICBpbXBvcnQgeyBCYXNlQ2xhc3MgfSBmcm9tICAnZG9tdGFzdGljJztcbiAgICpcbiAgICogICAgIGNsYXNzIE15Q29tcG9uZW50IGV4dGVuZHMgQmFzZUNsYXNzIHtcbiAgICogICAgICAgICBkb1NvbWV0aGluZygpIHtcbiAgICogICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQ2xhc3MoJy5mb28nKTtcbiAgICogICAgICAgICB9XG4gICAqICAgICB9XG4gICAqXG4gICAqICAgICBsZXQgY29tcG9uZW50ID0gbmV3IE15Q29tcG9uZW50KCdib2R5Jyk7XG4gICAqICAgICBjb21wb25lbnQuZG9Tb21ldGhpbmcoKTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICAgIGltcG9ydCAkIGZyb20gICdkb210YXN0aWMnO1xuICAgKlxuICAgKiAgICAgY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyAkLkJhc2VDbGFzcyB7XG4gICAqICAgICAgICAgcHJvZ3Jlc3ModmFsdWUpIHtcbiAgICogICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignZGF0YS1wcm9ncmVzcycsIHZhbHVlKTtcbiAgICogICAgICAgICB9XG4gICAqICAgICB9XG4gICAqXG4gICAqICAgICBsZXQgY29tcG9uZW50ID0gbmV3IE15Q29tcG9uZW50KGRvY3VtZW50LmJvZHkpO1xuICAgKiAgICAgY29tcG9uZW50LnByb2dyZXNzKCdpdmUnKS5hcHBlbmQoJzxwPmVuaGFuY2VtZW50PC9wPicpO1xuICAgKi9cblxuICBjbGFzcyBCYXNlQ2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgRE9NdGFzdGljLmNhbGwodGhpcywgc2VsZWN0b3IoLi4uYXJndW1lbnRzKSk7XG4gICAgfVxuICB9XG4gIGV4dGVuZChCYXNlQ2xhc3MucHJvdG90eXBlLCBhcGkpO1xuICByZXR1cm4gQmFzZUNsYXNzO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/baseClass.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/css.js":
/*!*******************************************!*\
  !*** ./node_modules/domtastic/src/css.js ***!
  \*******************************************/
/*! exports provided: css */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"css\", function() { return css; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./node_modules/domtastic/src/util.js\");\n/**\n * @module CSS\n */\n\n\n\nconst isNumeric = value => !isNaN(parseFloat(value)) && isFinite(value);\n\nconst camelize = value => value.replace(/-([\\da-z])/gi, (matches, letter) => letter.toUpperCase());\n\nconst dasherize = value => value.replace(/([a-z\\d])([A-Z])/g, '$1-$2').toLowerCase();\n\n/**\n * Get the value of a style property for the first element, or set one or more style properties for each element in the collection.\n *\n * @param {String|Object} key The name of the style property to get or set. Or an object containing key-value pairs to set as style properties.\n * @param {String} [value] The value of the style property to set.\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.item').css('padding-left'); // get\n *     $('.item').css('color', '#f00'); // set\n *     $('.item').css({'border-width': '1px', display: 'inline-block'}); // set multiple\n */\n\nconst css = function(key, value) {\n\n  let styleProps, prop, val;\n\n  if(typeof key === 'string') {\n    key = camelize(key);\n\n    if(typeof value === 'undefined') {\n      let element = this.nodeType ? this : this[0];\n      if(element) {\n        val = element.style[key];\n        return isNumeric(val) ? parseFloat(val) : val;\n      }\n      return undefined;\n    }\n\n    styleProps = {};\n    styleProps[key] = value;\n  } else {\n    styleProps = key;\n    for(prop in styleProps) {\n      val = styleProps[prop];\n      delete styleProps[prop];\n      styleProps[camelize(prop)] = val;\n    }\n  }\n\n  Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => {\n    for(prop in styleProps) {\n      if(styleProps[prop] || styleProps[prop] === 0) {\n        element.style[prop] = styleProps[prop];\n      } else {\n        element.style.removeProperty(dasherize(prop));\n      }\n    }\n  });\n\n  return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9jc3MuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9jc3MuanM/OWQxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgQ1NTXG4gKi9cblxuaW1wb3J0IHsgZWFjaCB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IGlzTnVtZXJpYyA9IHZhbHVlID0+ICFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSkgJiYgaXNGaW5pdGUodmFsdWUpO1xuXG5jb25zdCBjYW1lbGl6ZSA9IHZhbHVlID0+IHZhbHVlLnJlcGxhY2UoLy0oW1xcZGEtel0pL2dpLCAobWF0Y2hlcywgbGV0dGVyKSA9PiBsZXR0ZXIudG9VcHBlckNhc2UoKSk7XG5cbmNvbnN0IGRhc2hlcml6ZSA9IHZhbHVlID0+IHZhbHVlLnJlcGxhY2UoLyhbYS16XFxkXSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBhIHN0eWxlIHByb3BlcnR5IGZvciB0aGUgZmlyc3QgZWxlbWVudCwgb3Igc2V0IG9uZSBvciBtb3JlIHN0eWxlIHByb3BlcnRpZXMgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGtleSBUaGUgbmFtZSBvZiB0aGUgc3R5bGUgcHJvcGVydHkgdG8gZ2V0IG9yIHNldC4gT3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcga2V5LXZhbHVlIHBhaXJzIHRvIHNldCBhcyBzdHlsZSBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtTdHJpbmd9IFt2YWx1ZV0gVGhlIHZhbHVlIG9mIHRoZSBzdHlsZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB3cmFwcGVkIGNvbGxlY3Rpb25cbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKiAgICAgJCgnLml0ZW0nKS5jc3MoJ3BhZGRpbmctbGVmdCcpOyAvLyBnZXRcbiAqICAgICAkKCcuaXRlbScpLmNzcygnY29sb3InLCAnI2YwMCcpOyAvLyBzZXRcbiAqICAgICAkKCcuaXRlbScpLmNzcyh7J2JvcmRlci13aWR0aCc6ICcxcHgnLCBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJ30pOyAvLyBzZXQgbXVsdGlwbGVcbiAqL1xuXG5leHBvcnQgY29uc3QgY3NzID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXG4gIGxldCBzdHlsZVByb3BzLCBwcm9wLCB2YWw7XG5cbiAgaWYodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICBrZXkgPSBjYW1lbGl6ZShrZXkpO1xuXG4gICAgaWYodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLm5vZGVUeXBlID8gdGhpcyA6IHRoaXNbMF07XG4gICAgICBpZihlbGVtZW50KSB7XG4gICAgICAgIHZhbCA9IGVsZW1lbnQuc3R5bGVba2V5XTtcbiAgICAgICAgcmV0dXJuIGlzTnVtZXJpYyh2YWwpID8gcGFyc2VGbG9hdCh2YWwpIDogdmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBzdHlsZVByb3BzID0ge307XG4gICAgc3R5bGVQcm9wc1trZXldID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGVQcm9wcyA9IGtleTtcbiAgICBmb3IocHJvcCBpbiBzdHlsZVByb3BzKSB7XG4gICAgICB2YWwgPSBzdHlsZVByb3BzW3Byb3BdO1xuICAgICAgZGVsZXRlIHN0eWxlUHJvcHNbcHJvcF07XG4gICAgICBzdHlsZVByb3BzW2NhbWVsaXplKHByb3ApXSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBlYWNoKHRoaXMsIGVsZW1lbnQgPT4ge1xuICAgIGZvcihwcm9wIGluIHN0eWxlUHJvcHMpIHtcbiAgICAgIGlmKHN0eWxlUHJvcHNbcHJvcF0gfHwgc3R5bGVQcm9wc1twcm9wXSA9PT0gMCkge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVQcm9wc1twcm9wXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoZGFzaGVyaXplKHByb3ApKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/css.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/dom/attr.js":
/*!************************************************!*\
  !*** ./node_modules/domtastic/src/dom/attr.js ***!
  \************************************************/
/*! exports provided: attr, removeAttr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"attr\", function() { return attr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeAttr\", function() { return removeAttr; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/domtastic/src/util.js\");\n/**\n * @module Attr\n */\n\n\n\n/**\n * Get the value of an attribute for the first element, or set one or more attributes for each element in the collection.\n *\n * @param {String|Object} key The name of the attribute to get or set. Or an object containing key-value pairs to set as attributes.\n * @param {String} [value] The value of the attribute to set.\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.item').attr('attrName'); // get\n *     $('.item').attr('attrName', 'attrValue'); // set\n *     $('.item').attr({attr1: 'value1', 'attr-2': 'value2'}); // set multiple\n */\n\nconst attr = function(key, value) {\n\n  if(typeof key === 'string' && typeof value === 'undefined') {\n    const element = this.nodeType ? this : this[0];\n    return element ? element.getAttribute(key) : undefined;\n  }\n\n  return Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => {\n    if(typeof key === 'object') {\n      for(let attr in key) {\n        element.setAttribute(attr, key[attr]);\n      }\n    } else {\n      element.setAttribute(key, value);\n    }\n  });\n};\n\n/**\n * Remove attribute from each element in the collection.\n *\n * @param {String} key Attribute name\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.items').removeAttr('attrName');\n */\n\nconst removeAttr = function(key) {\n  return Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => element.removeAttribute(key));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9kb20vYXR0ci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb210YXN0aWMvc3JjL2RvbS9hdHRyLmpzPzlkZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIEF0dHJcbiAqL1xuXG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnLi4vdXRpbCc7XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgZm9yIHRoZSBmaXJzdCBlbGVtZW50LCBvciBzZXQgb25lIG9yIG1vcmUgYXR0cmlidXRlcyBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ga2V5IFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gZ2V0IG9yIHNldC4gT3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcga2V5LXZhbHVlIHBhaXJzIHRvIHNldCBhcyBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtTdHJpbmd9IFt2YWx1ZV0gVGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgdG8gc2V0LlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgd3JhcHBlZCBjb2xsZWN0aW9uXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5pdGVtJykuYXR0cignYXR0ck5hbWUnKTsgLy8gZ2V0XG4gKiAgICAgJCgnLml0ZW0nKS5hdHRyKCdhdHRyTmFtZScsICdhdHRyVmFsdWUnKTsgLy8gc2V0XG4gKiAgICAgJCgnLml0ZW0nKS5hdHRyKHthdHRyMTogJ3ZhbHVlMScsICdhdHRyLTInOiAndmFsdWUyJ30pOyAvLyBzZXQgbXVsdGlwbGVcbiAqL1xuXG5leHBvcnQgY29uc3QgYXR0ciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcblxuICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMubm9kZVR5cGUgPyB0aGlzIDogdGhpc1swXTtcbiAgICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGtleSkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gZWFjaCh0aGlzLCBlbGVtZW50ID0+IHtcbiAgICBpZih0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yKGxldCBhdHRyIGluIGtleSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLCBrZXlbYXR0cl0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYXR0cmlidXRlIGZyb20gZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgQXR0cmlidXRlIG5hbWVcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHdyYXBwZWQgY29sbGVjdGlvblxuICogQGNoYWluYWJsZVxuICogQGV4YW1wbGVcbiAqICAgICAkKCcuaXRlbXMnKS5yZW1vdmVBdHRyKCdhdHRyTmFtZScpO1xuICovXG5cbmV4cG9ydCBjb25zdCByZW1vdmVBdHRyID0gZnVuY3Rpb24oa2V5KSB7XG4gIHJldHVybiBlYWNoKHRoaXMsIGVsZW1lbnQgPT4gZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KSk7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/dom/attr.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/dom/class.js":
/*!*************************************************!*\
  !*** ./node_modules/domtastic/src/dom/class.js ***!
  \*************************************************/
/*! exports provided: addClass, removeClass, toggleClass, hasClass */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addClass\", function() { return addClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeClass\", function() { return removeClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toggleClass\", function() { return toggleClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasClass\", function() { return hasClass; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/domtastic/src/util.js\");\n/**\n * @module Class\n */\n\n\n\n/**\n * Add a class to the element(s)\n *\n * @param {String} value Space-separated class name(s) to add to the element(s).\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.item').addClass('bar');\n *     $('.item').addClass('bar foo');\n */\n\nconst addClass = function(value) {\n  if(value && value.length) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(value.split(' '), _each.bind(this, 'add'));\n  }\n  return this;\n};\n\n/**\n * Remove a class from the element(s)\n *\n * @param {String} value Space-separated class name(s) to remove from the element(s).\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.items').removeClass('bar');\n *     $('.items').removeClass('bar foo');\n */\n\nconst removeClass = function(value) {\n  if(value && value.length) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(value.split(' '), _each.bind(this, 'remove'));\n  }\n  return this;\n};\n\n/**\n * Toggle a class at the element(s)\n *\n * @param {String} value Space-separated class name(s) to toggle at the element(s).\n * @param {Boolean} [state] A Boolean value to determine whether the class should be added or removed.\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.item').toggleClass('bar');\n *     $('.item').toggleClass('bar foo');\n *     $('.item').toggleClass('bar', true);\n */\n\nconst toggleClass = function(value, state) {\n  if(value && value.length) {\n    const action = typeof state === 'boolean' ? state ? 'add' : 'remove' : 'toggle';\n    Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(value.split(' '), _each.bind(this, action));\n  }\n  return this;\n};\n\n/**\n * Check if the element(s) have a class.\n *\n * @param {String} value Check if the DOM element contains the class name. When applied to multiple elements,\n * returns `true` if _any_ of them contains the class name.\n * @return {Boolean} Whether the element's class attribute contains the class name.\n * @example\n *     $('.item').hasClass('bar');\n */\n\nconst hasClass = function(value) {\n  return (this.nodeType ? [this] : this).some(element => element.classList.contains(value));\n};\n\n/**\n * Specialized iteration, applying `fn` of the classList API to each element.\n *\n * @param {String} fnName\n * @param {String} className\n * @private\n */\n\nconst _each = function(fnName, className) {\n  return Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => element.classList[fnName](className));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9kb20vY2xhc3MuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9kb20vY2xhc3MuanM/Yzg4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgQ2xhc3NcbiAqL1xuXG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnLi4vdXRpbCc7XG5cbi8qKlxuICogQWRkIGEgY2xhc3MgdG8gdGhlIGVsZW1lbnQocylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgU3BhY2Utc2VwYXJhdGVkIGNsYXNzIG5hbWUocykgdG8gYWRkIHRvIHRoZSBlbGVtZW50KHMpLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgd3JhcHBlZCBjb2xsZWN0aW9uXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5pdGVtJykuYWRkQ2xhc3MoJ2JhcicpO1xuICogICAgICQoJy5pdGVtJykuYWRkQ2xhc3MoJ2JhciBmb28nKTtcbiAqL1xuXG5leHBvcnQgY29uc3QgYWRkQ2xhc3MgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZih2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICBlYWNoKHZhbHVlLnNwbGl0KCcgJyksIF9lYWNoLmJpbmQodGhpcywgJ2FkZCcpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgY2xhc3MgZnJvbSB0aGUgZWxlbWVudChzKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBTcGFjZS1zZXBhcmF0ZWQgY2xhc3MgbmFtZShzKSB0byByZW1vdmUgZnJvbSB0aGUgZWxlbWVudChzKS5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHdyYXBwZWQgY29sbGVjdGlvblxuICogQGNoYWluYWJsZVxuICogQGV4YW1wbGVcbiAqICAgICAkKCcuaXRlbXMnKS5yZW1vdmVDbGFzcygnYmFyJyk7XG4gKiAgICAgJCgnLml0ZW1zJykucmVtb3ZlQ2xhc3MoJ2JhciBmb28nKTtcbiAqL1xuXG5leHBvcnQgY29uc3QgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZih2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICBlYWNoKHZhbHVlLnNwbGl0KCcgJyksIF9lYWNoLmJpbmQodGhpcywgJ3JlbW92ZScpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVG9nZ2xlIGEgY2xhc3MgYXQgdGhlIGVsZW1lbnQocylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgU3BhY2Utc2VwYXJhdGVkIGNsYXNzIG5hbWUocykgdG8gdG9nZ2xlIGF0IHRoZSBlbGVtZW50KHMpLlxuICogQHBhcmFtIHtCb29sZWFufSBbc3RhdGVdIEEgQm9vbGVhbiB2YWx1ZSB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgY2xhc3Mgc2hvdWxkIGJlIGFkZGVkIG9yIHJlbW92ZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB3cmFwcGVkIGNvbGxlY3Rpb25cbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKiAgICAgJCgnLml0ZW0nKS50b2dnbGVDbGFzcygnYmFyJyk7XG4gKiAgICAgJCgnLml0ZW0nKS50b2dnbGVDbGFzcygnYmFyIGZvbycpO1xuICogICAgICQoJy5pdGVtJykudG9nZ2xlQ2xhc3MoJ2JhcicsIHRydWUpO1xuICovXG5cbmV4cG9ydCBjb25zdCB0b2dnbGVDbGFzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdGF0ZSkge1xuICBpZih2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICBjb25zdCBhY3Rpb24gPSB0eXBlb2Ygc3RhdGUgPT09ICdib29sZWFuJyA/IHN0YXRlID8gJ2FkZCcgOiAncmVtb3ZlJyA6ICd0b2dnbGUnO1xuICAgIGVhY2godmFsdWUuc3BsaXQoJyAnKSwgX2VhY2guYmluZCh0aGlzLCBhY3Rpb24pKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGVsZW1lbnQocykgaGF2ZSBhIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBDaGVjayBpZiB0aGUgRE9NIGVsZW1lbnQgY29udGFpbnMgdGhlIGNsYXNzIG5hbWUuIFdoZW4gYXBwbGllZCB0byBtdWx0aXBsZSBlbGVtZW50cyxcbiAqIHJldHVybnMgYHRydWVgIGlmIF9hbnlfIG9mIHRoZW0gY29udGFpbnMgdGhlIGNsYXNzIG5hbWUuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlIGNvbnRhaW5zIHRoZSBjbGFzcyBuYW1lLlxuICogQGV4YW1wbGVcbiAqICAgICAkKCcuaXRlbScpLmhhc0NsYXNzKCdiYXInKTtcbiAqL1xuXG5leHBvcnQgY29uc3QgaGFzQ2xhc3MgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKHRoaXMubm9kZVR5cGUgPyBbdGhpc10gOiB0aGlzKS5zb21lKGVsZW1lbnQgPT4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnModmFsdWUpKTtcbn07XG5cbi8qKlxuICogU3BlY2lhbGl6ZWQgaXRlcmF0aW9uLCBhcHBseWluZyBgZm5gIG9mIHRoZSBjbGFzc0xpc3QgQVBJIHRvIGVhY2ggZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5OYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNvbnN0IF9lYWNoID0gZnVuY3Rpb24oZm5OYW1lLCBjbGFzc05hbWUpIHtcbiAgcmV0dXJuIGVhY2godGhpcywgZWxlbWVudCA9PiBlbGVtZW50LmNsYXNzTGlzdFtmbk5hbWVdKGNsYXNzTmFtZSkpO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/dom/class.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/dom/contains.js":
/*!****************************************************!*\
  !*** ./node_modules/domtastic/src/dom/contains.js ***!
  \****************************************************/
/*! exports provided: contains */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"contains\", function() { return contains; });\n/**\n * @module contains\n */\n\n/**\n * Test whether an element contains another element in the DOM.\n *\n * @param {Element} container The element that may contain the other element.\n * @param {Element} element The element that may be a descendant of the other element.\n * @return {Boolean} Whether the `container` element contains the `element`.\n * @example\n *     $.contains(parentElement, childElement); // true/false\n */\n\nconst contains = (container, element) => {\n  if(!container || !element || container === element) {\n    return false;\n  } else if(container.contains) {\n    return container.contains(element);\n  } else if(container.compareDocumentPosition) {\n    return !(container.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_DISCONNECTED);\n  }\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9kb20vY29udGFpbnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9kb20vY29udGFpbnMuanM/NGY4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgY29udGFpbnNcbiAqL1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBlbGVtZW50IGNvbnRhaW5zIGFub3RoZXIgZWxlbWVudCBpbiB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyIFRoZSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW4gdGhlIG90aGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdGhhdCBtYXkgYmUgYSBkZXNjZW5kYW50IG9mIHRoZSBvdGhlciBlbGVtZW50LlxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgYGNvbnRhaW5lcmAgZWxlbWVudCBjb250YWlucyB0aGUgYGVsZW1lbnRgLlxuICogQGV4YW1wbGVcbiAqICAgICAkLmNvbnRhaW5zKHBhcmVudEVsZW1lbnQsIGNoaWxkRWxlbWVudCk7IC8vIHRydWUvZmFsc2VcbiAqL1xuXG5leHBvcnQgY29uc3QgY29udGFpbnMgPSAoY29udGFpbmVyLCBlbGVtZW50KSA9PiB7XG4gIGlmKCFjb250YWluZXIgfHwgIWVsZW1lbnQgfHwgY29udGFpbmVyID09PSBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYoY29udGFpbmVyLmNvbnRhaW5zKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5jb250YWlucyhlbGVtZW50KTtcbiAgfSBlbHNlIGlmKGNvbnRhaW5lci5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhKGNvbnRhaW5lci5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50KSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRElTQ09OTkVDVEVEKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/dom/contains.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/dom/data.js":
/*!************************************************!*\
  !*** ./node_modules/domtastic/src/dom/data.js ***!
  \************************************************/
/*! exports provided: data, prop */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"data\", function() { return data; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"prop\", function() { return prop; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/domtastic/src/util.js\");\n/**\n * @module Data\n */\n\n\n\nconst isSupportsDataSet = typeof document !== 'undefined' && 'dataset' in document.documentElement;\nconst DATAKEYPROP = isSupportsDataSet ? 'dataset' : '__DOMTASTIC_DATA__';\n\nconst camelize = str => str.replace(/-+(.)?/g, (match, char) => char ? char.toUpperCase() : '');\n\n/**\n * Get data from first element, or set data for each element in the collection.\n *\n * @param {String} key The key for the data to get or set.\n * @param {String} [value] The data to set.\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.item').data('attrName'); // get\n *     $('.item').data('attrName', {any: 'data'}); // set\n */\n\nconst data = function(key, value) {\n\n  if(typeof key === 'string' && typeof value === 'undefined') {\n    const element = this.nodeType ? this : this[0];\n    return element && DATAKEYPROP in element ? element[DATAKEYPROP][camelize(key)] : undefined;\n  }\n\n  return Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => {\n    if(!isSupportsDataSet) {\n      element[DATAKEYPROP] = element[DATAKEYPROP] || {};\n    }\n\n    element[DATAKEYPROP][camelize(key)] = value;\n  });\n};\n\n/**\n * Get property from first element, or set property on each element in the collection.\n *\n * @param {String} key The name of the property to get or set.\n * @param {String} [value] The value of the property to set.\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.item').prop('attrName'); // get\n *     $('.item').prop('attrName', 'attrValue'); // set\n */\n\nconst prop = function(key, value) {\n\n  if(typeof key === 'string' && typeof value === 'undefined') {\n    const element = this.nodeType ? this : this[0];\n    return element && element ? element[key] : undefined;\n  }\n\n  return Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => element[key] = value);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9kb20vZGF0YS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb210YXN0aWMvc3JjL2RvbS9kYXRhLmpzPzRkNTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIERhdGFcbiAqL1xuXG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnLi4vdXRpbCc7XG5cbmNvbnN0IGlzU3VwcG9ydHNEYXRhU2V0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnZGF0YXNldCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuY29uc3QgREFUQUtFWVBST1AgPSBpc1N1cHBvcnRzRGF0YVNldCA/ICdkYXRhc2V0JyA6ICdfX0RPTVRBU1RJQ19EQVRBX18nO1xuXG5jb25zdCBjYW1lbGl6ZSA9IHN0ciA9PiBzdHIucmVwbGFjZSgvLSsoLik/L2csIChtYXRjaCwgY2hhcikgPT4gY2hhciA/IGNoYXIudG9VcHBlckNhc2UoKSA6ICcnKTtcblxuLyoqXG4gKiBHZXQgZGF0YSBmcm9tIGZpcnN0IGVsZW1lbnQsIG9yIHNldCBkYXRhIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IGZvciB0aGUgZGF0YSB0byBnZXQgb3Igc2V0LlxuICogQHBhcmFtIHtTdHJpbmd9IFt2YWx1ZV0gVGhlIGRhdGEgdG8gc2V0LlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgd3JhcHBlZCBjb2xsZWN0aW9uXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5pdGVtJykuZGF0YSgnYXR0ck5hbWUnKTsgLy8gZ2V0XG4gKiAgICAgJCgnLml0ZW0nKS5kYXRhKCdhdHRyTmFtZScsIHthbnk6ICdkYXRhJ30pOyAvLyBzZXRcbiAqL1xuXG5leHBvcnQgY29uc3QgZGF0YSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcblxuICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMubm9kZVR5cGUgPyB0aGlzIDogdGhpc1swXTtcbiAgICByZXR1cm4gZWxlbWVudCAmJiBEQVRBS0VZUFJPUCBpbiBlbGVtZW50ID8gZWxlbWVudFtEQVRBS0VZUFJPUF1bY2FtZWxpemUoa2V5KV0gOiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gZWFjaCh0aGlzLCBlbGVtZW50ID0+IHtcbiAgICBpZighaXNTdXBwb3J0c0RhdGFTZXQpIHtcbiAgICAgIGVsZW1lbnRbREFUQUtFWVBST1BdID0gZWxlbWVudFtEQVRBS0VZUFJPUF0gfHwge307XG4gICAgfVxuXG4gICAgZWxlbWVudFtEQVRBS0VZUFJPUF1bY2FtZWxpemUoa2V5KV0gPSB2YWx1ZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldCBwcm9wZXJ0eSBmcm9tIGZpcnN0IGVsZW1lbnQsIG9yIHNldCBwcm9wZXJ0eSBvbiBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0IG9yIHNldC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWVdIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgd3JhcHBlZCBjb2xsZWN0aW9uXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5pdGVtJykucHJvcCgnYXR0ck5hbWUnKTsgLy8gZ2V0XG4gKiAgICAgJCgnLml0ZW0nKS5wcm9wKCdhdHRyTmFtZScsICdhdHRyVmFsdWUnKTsgLy8gc2V0XG4gKi9cblxuZXhwb3J0IGNvbnN0IHByb3AgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG5cbiAgaWYodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLm5vZGVUeXBlID8gdGhpcyA6IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZW1lbnQgJiYgZWxlbWVudCA/IGVsZW1lbnRba2V5XSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBlYWNoKHRoaXMsIGVsZW1lbnQgPT4gZWxlbWVudFtrZXldID0gdmFsdWUpO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/dom/data.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/dom/extra.js":
/*!*************************************************!*\
  !*** ./node_modules/domtastic/src/dom/extra.js ***!
  \*************************************************/
/*! exports provided: appendTo, empty, remove, replaceWith, text, val */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"appendTo\", function() { return appendTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"empty\", function() { return empty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"remove\", function() { return remove; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"replaceWith\", function() { return replaceWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"text\", function() { return text; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"val\", function() { return val; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/domtastic/src/util.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ \"./node_modules/domtastic/src/dom/index.js\");\n/* harmony import */ var _selector_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../selector/index */ \"./node_modules/domtastic/src/selector/index.js\");\n/**\n * @module DOM (extra)\n */\n\n\n\n\n\n/**\n * Append each element in the collection to the specified element(s).\n *\n * @param {Node|NodeList|Object} element What to append the element(s) to. Clones elements as necessary.\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.item').appendTo(container);\n */\n\nconst appendTo = function(element) {\n  const context = typeof element === 'string' ? Object(_selector_index__WEBPACK_IMPORTED_MODULE_2__[\"$\"])(element) : element;\n  _index__WEBPACK_IMPORTED_MODULE_1__[\"append\"].call(context, this);\n  return this;\n};\n\n/*\n * Empty each element in the collection.\n *\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.item').empty();\n */\n\nconst empty = function() {\n  return Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => element.innerHTML = '');\n};\n\n/**\n * Remove the collection from the DOM.\n *\n * @return {Array} Array containing the removed elements\n * @example\n *     $('.item').remove();\n */\n\nconst remove = function() {\n  return Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => {\n    if(element.parentNode) {\n      element.parentNode.removeChild(element);\n    }\n  });\n};\n\n/**\n * Replace each element in the collection with the provided new content, and return the array of elements that were replaced.\n *\n * @return {Array} Array containing the replaced elements\n */\n\nconst replaceWith = function() {\n  return _index__WEBPACK_IMPORTED_MODULE_1__[\"before\"].apply(this, arguments).remove();\n};\n\n/**\n * Get the `textContent` from the first, or set the `textContent` of each element in the collection.\n *\n * @param {String} [value]\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.item').text('New content');\n */\n\nconst text = function(value) {\n\n  if(value === undefined) {\n    return this[0].textContent;\n  }\n\n  return Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => element.textContent = '' + value);\n};\n\n/**\n * Get the `value` from the first, or set the `value` of each element in the collection.\n *\n * @param {String} [value]\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('input.firstName').val('New value');\n */\n\nconst val = function(value) {\n\n  if(value === undefined) {\n    return this.length > 0 ? this[0].value : undefined;\n  }\n\n  return Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => element.value = value);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9kb20vZXh0cmEuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9kb20vZXh0cmEuanM/OTg2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgRE9NIChleHRyYSlcbiAqL1xuXG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgeyBhcHBlbmQsIGJlZm9yZSB9IGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHsgJCB9IGZyb20gJy4uL3NlbGVjdG9yL2luZGV4JztcblxuLyoqXG4gKiBBcHBlbmQgZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgZWxlbWVudChzKS5cbiAqXG4gKiBAcGFyYW0ge05vZGV8Tm9kZUxpc3R8T2JqZWN0fSBlbGVtZW50IFdoYXQgdG8gYXBwZW5kIHRoZSBlbGVtZW50KHMpIHRvLiBDbG9uZXMgZWxlbWVudHMgYXMgbmVjZXNzYXJ5LlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgd3JhcHBlZCBjb2xsZWN0aW9uXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5pdGVtJykuYXBwZW5kVG8oY29udGFpbmVyKTtcbiAqL1xuXG5leHBvcnQgY29uc3QgYXBwZW5kVG8gPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGNvbnN0IGNvbnRleHQgPSB0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgPyAkKGVsZW1lbnQpIDogZWxlbWVudDtcbiAgYXBwZW5kLmNhbGwoY29udGV4dCwgdGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLypcbiAqIEVtcHR5IGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB3cmFwcGVkIGNvbGxlY3Rpb25cbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKiAgICAgJCgnLml0ZW0nKS5lbXB0eSgpO1xuICovXG5cbmV4cG9ydCBjb25zdCBlbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZWFjaCh0aGlzLCBlbGVtZW50ID0+IGVsZW1lbnQuaW5uZXJIVE1MID0gJycpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGNvbGxlY3Rpb24gZnJvbSB0aGUgRE9NLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBjb250YWluaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5pdGVtJykucmVtb3ZlKCk7XG4gKi9cblxuZXhwb3J0IGNvbnN0IHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZWFjaCh0aGlzLCBlbGVtZW50ID0+IHtcbiAgICBpZihlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBuZXcgY29udGVudCwgYW5kIHJldHVybiB0aGUgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCB3ZXJlIHJlcGxhY2VkLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBjb250YWluaW5nIHRoZSByZXBsYWNlZCBlbGVtZW50c1xuICovXG5cbmV4cG9ydCBjb25zdCByZXBsYWNlV2l0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gYmVmb3JlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykucmVtb3ZlKCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYHRleHRDb250ZW50YCBmcm9tIHRoZSBmaXJzdCwgb3Igc2V0IHRoZSBgdGV4dENvbnRlbnRgIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3ZhbHVlXVxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgd3JhcHBlZCBjb2xsZWN0aW9uXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5pdGVtJykudGV4dCgnTmV3IGNvbnRlbnQnKTtcbiAqL1xuXG5leHBvcnQgY29uc3QgdGV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgaWYodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzWzBdLnRleHRDb250ZW50O1xuICB9XG5cbiAgcmV0dXJuIGVhY2godGhpcywgZWxlbWVudCA9PiBlbGVtZW50LnRleHRDb250ZW50ID0gJycgKyB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYHZhbHVlYCBmcm9tIHRoZSBmaXJzdCwgb3Igc2V0IHRoZSBgdmFsdWVgIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3ZhbHVlXVxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgd3JhcHBlZCBjb2xsZWN0aW9uXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICogICAgICQoJ2lucHV0LmZpcnN0TmFtZScpLnZhbCgnTmV3IHZhbHVlJyk7XG4gKi9cblxuZXhwb3J0IGNvbnN0IHZhbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgaWYodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IDAgPyB0aGlzWzBdLnZhbHVlIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIGVhY2godGhpcywgZWxlbWVudCA9PiBlbGVtZW50LnZhbHVlID0gdmFsdWUpO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/dom/extra.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/dom/html.js":
/*!************************************************!*\
  !*** ./node_modules/domtastic/src/dom/html.js ***!
  \************************************************/
/*! exports provided: html */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"html\", function() { return html; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/domtastic/src/util.js\");\n/**\n * @module HTML\n */\n\n\n\n/*\n * Get the HTML contents of the first element, or set the HTML contents for each element in the collection.\n *\n * @param {String} [fragment] HTML fragment to set for the element. If this argument is omitted, the HTML contents are returned.\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.item').html();\n *     $('.item').html('<span>more</span>');\n */\n\nconst html = function(fragment) {\n\n  if(fragment === undefined) {\n    const element = this.nodeType ? this : this[0];\n    return element ? element.innerHTML : undefined;\n  }\n\n  return Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => element.innerHTML = fragment);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9kb20vaHRtbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb210YXN0aWMvc3JjL2RvbS9odG1sLmpzPzEzOTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIEhUTUxcbiAqL1xuXG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnLi4vdXRpbCc7XG5cbi8qXG4gKiBHZXQgdGhlIEhUTUwgY29udGVudHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQsIG9yIHNldCB0aGUgSFRNTCBjb250ZW50cyBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZnJhZ21lbnRdIEhUTUwgZnJhZ21lbnQgdG8gc2V0IGZvciB0aGUgZWxlbWVudC4gSWYgdGhpcyBhcmd1bWVudCBpcyBvbWl0dGVkLCB0aGUgSFRNTCBjb250ZW50cyBhcmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB3cmFwcGVkIGNvbGxlY3Rpb25cbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKiAgICAgJCgnLml0ZW0nKS5odG1sKCk7XG4gKiAgICAgJCgnLml0ZW0nKS5odG1sKCc8c3Bhbj5tb3JlPC9zcGFuPicpO1xuICovXG5cbmV4cG9ydCBjb25zdCBodG1sID0gZnVuY3Rpb24oZnJhZ21lbnQpIHtcblxuICBpZihmcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMubm9kZVR5cGUgPyB0aGlzIDogdGhpc1swXTtcbiAgICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQuaW5uZXJIVE1MIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIGVhY2godGhpcywgZWxlbWVudCA9PiBlbGVtZW50LmlubmVySFRNTCA9IGZyYWdtZW50KTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/dom/html.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/dom/index.js":
/*!*************************************************!*\
  !*** ./node_modules/domtastic/src/dom/index.js ***!
  \*************************************************/
/*! exports provided: append, prepend, before, after, clone, _clone, _each */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"append\", function() { return append; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"prepend\", function() { return prepend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"before\", function() { return before; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"after\", function() { return after; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_clone\", function() { return _clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_each\", function() { return _each; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/domtastic/src/util.js\");\n/* harmony import */ var _selector_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector/index */ \"./node_modules/domtastic/src/selector/index.js\");\n/**\n * @module DOM\n */\n\n\n\n\nconst forEach = Array.prototype.forEach;\n\n/**\n * Append element(s) to each element in the collection.\n *\n * @param {String|Node|NodeList|Object} element What to append to the element(s).\n * Clones elements as necessary.\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.item').append('<p>more</p>');\n */\n\nconst append = function(element) {\n  if(this instanceof Node) {\n    if(typeof element === 'string') {\n      this.insertAdjacentHTML('beforeend', element);\n    } else {\n      if(element instanceof Node) {\n        this.appendChild(element);\n      } else {\n        const elements = element instanceof NodeList ? Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(element) : element;\n        forEach.call(elements, this.appendChild.bind(this));\n      }\n    }\n  } else {\n    _each(this, append, element);\n  }\n  return this;\n};\n\n/**\n * Place element(s) at the beginning of each element in the collection.\n *\n * @param {String|Node|NodeList|Object} element What to place at the beginning of the element(s).\n * Clones elements as necessary.\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.item').prepend('<span>start</span>');\n */\n\nconst prepend = function(element) {\n  if(this instanceof Node) {\n    if(typeof element === 'string') {\n      this.insertAdjacentHTML('afterbegin', element);\n    } else {\n      if(element instanceof Node) {\n        this.insertBefore(element, this.firstChild);\n      } else {\n        let elements = element instanceof NodeList ? Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(element) : element;\n        forEach.call(elements.reverse(), prepend.bind(this));\n      }\n    }\n  } else {\n    _each(this, prepend, element);\n  }\n  return this;\n};\n\n/**\n * Place element(s) before each element in the collection.\n *\n * @param {String|Node|NodeList|Object} element What to place as sibling(s) before to the element(s).\n * Clones elements as necessary.\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.items').before('<p>prefix</p>');\n */\n\nconst before = function(element) {\n  if(this instanceof Node) {\n    if(typeof element === 'string') {\n      this.insertAdjacentHTML('beforebegin', element);\n    } else {\n      if(element instanceof Node) {\n        this.parentNode.insertBefore(element, this);\n      } else {\n        const elements = element instanceof NodeList ? Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(element) : element;\n        forEach.call(elements, before.bind(this));\n      }\n    }\n  } else {\n    _each(this, before, element);\n  }\n  return this;\n};\n\n/**\n * Place element(s) after each element in the collection.\n *\n * @param {String|Node|NodeList|Object} element What to place as sibling(s) after to the element(s). Clones elements as necessary.\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.items').after('<span>suf</span><span>fix</span>');\n */\n\nconst after = function(element) {\n  if(this instanceof Node) {\n    if(typeof element === 'string') {\n      this.insertAdjacentHTML('afterend', element);\n    } else {\n      if(element instanceof Node) {\n        this.parentNode.insertBefore(element, this.nextSibling);\n      } else {\n        const elements = element instanceof NodeList ? Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(element) : element;\n        forEach.call(elements.reverse(), after.bind(this));\n      }\n    }\n  } else {\n    _each(this, after, element);\n  }\n  return this;\n};\n\n/**\n * Clone a wrapped object.\n *\n * @return {Object} Wrapped collection of cloned nodes.\n * @example\n *     $(element).clone();\n */\n\nconst clone = function() {\n  return Object(_selector_index__WEBPACK_IMPORTED_MODULE_1__[\"$\"])(_clone(this));\n};\n\n/**\n * Clone an object\n *\n * @param {String|Node|NodeList|Array} element The element(s) to clone.\n * @return {String|Node|NodeList|Array} The cloned element(s)\n * @private\n */\n\nconst _clone = element => {\n  if(typeof element === 'string') {\n    return element;\n  } else if(element instanceof Node) {\n    return element.cloneNode(true);\n  } else if('length' in element) {\n    return [].map.call(element, el => el.cloneNode(true));\n  }\n  return element;\n};\n\n/**\n * Specialized iteration, applying `fn` in reversed manner to a clone of each element, but the provided one.\n *\n * @param {NodeList|Array} collection\n * @param {Function} fn\n * @param {Node} element\n * @private\n */\n\nconst _each = (collection, fn, element) => {\n  let l = collection.length;\n  while(l--) {\n    const elm = l === 0 ? element : _clone(element);\n    fn.call(collection[l], elm);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9kb20vaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9kb20vaW5kZXguanM/NmQzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgRE9NXG4gKi9cblxuaW1wb3J0IHsgdG9BcnJheSB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgJCB9IGZyb20gJy4uL3NlbGVjdG9yL2luZGV4JztcblxuY29uc3QgZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuXG4vKipcbiAqIEFwcGVuZCBlbGVtZW50KHMpIHRvIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOb2RlfE5vZGVMaXN0fE9iamVjdH0gZWxlbWVudCBXaGF0IHRvIGFwcGVuZCB0byB0aGUgZWxlbWVudChzKS5cbiAqIENsb25lcyBlbGVtZW50cyBhcyBuZWNlc3NhcnkuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB3cmFwcGVkIGNvbGxlY3Rpb25cbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKiAgICAgJCgnLml0ZW0nKS5hcHBlbmQoJzxwPm1vcmU8L3A+Jyk7XG4gKi9cblxuZXhwb3J0IGNvbnN0IGFwcGVuZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgaWYodGhpcyBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICBpZih0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoZWxlbWVudCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZWxlbWVudCBpbnN0YW5jZW9mIE5vZGVMaXN0ID8gdG9BcnJheShlbGVtZW50KSA6IGVsZW1lbnQ7XG4gICAgICAgIGZvckVhY2guY2FsbChlbGVtZW50cywgdGhpcy5hcHBlbmRDaGlsZC5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgX2VhY2godGhpcywgYXBwZW5kLCBlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUGxhY2UgZWxlbWVudChzKSBhdCB0aGUgYmVnaW5uaW5nIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOb2RlfE5vZGVMaXN0fE9iamVjdH0gZWxlbWVudCBXaGF0IHRvIHBsYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGVsZW1lbnQocykuXG4gKiBDbG9uZXMgZWxlbWVudHMgYXMgbmVjZXNzYXJ5LlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgd3JhcHBlZCBjb2xsZWN0aW9uXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5pdGVtJykucHJlcGVuZCgnPHNwYW4+c3RhcnQ8L3NwYW4+Jyk7XG4gKi9cblxuZXhwb3J0IGNvbnN0IHByZXBlbmQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGlmKHRoaXMgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgaWYodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJiZWdpbicsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihlbGVtZW50IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShlbGVtZW50LCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGVsZW1lbnRzID0gZWxlbWVudCBpbnN0YW5jZW9mIE5vZGVMaXN0ID8gdG9BcnJheShlbGVtZW50KSA6IGVsZW1lbnQ7XG4gICAgICAgIGZvckVhY2guY2FsbChlbGVtZW50cy5yZXZlcnNlKCksIHByZXBlbmQuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIF9lYWNoKHRoaXMsIHByZXBlbmQsIGVsZW1lbnQpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQbGFjZSBlbGVtZW50KHMpIGJlZm9yZSBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8Tm9kZXxOb2RlTGlzdHxPYmplY3R9IGVsZW1lbnQgV2hhdCB0byBwbGFjZSBhcyBzaWJsaW5nKHMpIGJlZm9yZSB0byB0aGUgZWxlbWVudChzKS5cbiAqIENsb25lcyBlbGVtZW50cyBhcyBuZWNlc3NhcnkuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB3cmFwcGVkIGNvbGxlY3Rpb25cbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKiAgICAgJCgnLml0ZW1zJykuYmVmb3JlKCc8cD5wcmVmaXg8L3A+Jyk7XG4gKi9cblxuZXhwb3J0IGNvbnN0IGJlZm9yZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgaWYodGhpcyBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICBpZih0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmViZWdpbicsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihlbGVtZW50IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBlbGVtZW50IGluc3RhbmNlb2YgTm9kZUxpc3QgPyB0b0FycmF5KGVsZW1lbnQpIDogZWxlbWVudDtcbiAgICAgICAgZm9yRWFjaC5jYWxsKGVsZW1lbnRzLCBiZWZvcmUuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIF9lYWNoKHRoaXMsIGJlZm9yZSwgZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFBsYWNlIGVsZW1lbnQocykgYWZ0ZXIgZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE5vZGV8Tm9kZUxpc3R8T2JqZWN0fSBlbGVtZW50IFdoYXQgdG8gcGxhY2UgYXMgc2libGluZyhzKSBhZnRlciB0byB0aGUgZWxlbWVudChzKS4gQ2xvbmVzIGVsZW1lbnRzIGFzIG5lY2Vzc2FyeS5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHdyYXBwZWQgY29sbGVjdGlvblxuICogQGNoYWluYWJsZVxuICogQGV4YW1wbGVcbiAqICAgICAkKCcuaXRlbXMnKS5hZnRlcignPHNwYW4+c3VmPC9zcGFuPjxzcGFuPmZpeDwvc3Bhbj4nKTtcbiAqL1xuXG5leHBvcnQgY29uc3QgYWZ0ZXIgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGlmKHRoaXMgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgaWYodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJlbmQnLCBlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoZWxlbWVudCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCB0aGlzLm5leHRTaWJsaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZWxlbWVudCBpbnN0YW5jZW9mIE5vZGVMaXN0ID8gdG9BcnJheShlbGVtZW50KSA6IGVsZW1lbnQ7XG4gICAgICAgIGZvckVhY2guY2FsbChlbGVtZW50cy5yZXZlcnNlKCksIGFmdGVyLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBfZWFjaCh0aGlzLCBhZnRlciwgZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb25lIGEgd3JhcHBlZCBvYmplY3QuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBXcmFwcGVkIGNvbGxlY3Rpb24gb2YgY2xvbmVkIG5vZGVzLlxuICogQGV4YW1wbGVcbiAqICAgICAkKGVsZW1lbnQpLmNsb25lKCk7XG4gKi9cblxuZXhwb3J0IGNvbnN0IGNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAkKF9jbG9uZSh0aGlzKSk7XG59O1xuXG4vKipcbiAqIENsb25lIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE5vZGV8Tm9kZUxpc3R8QXJyYXl9IGVsZW1lbnQgVGhlIGVsZW1lbnQocykgdG8gY2xvbmUuXG4gKiBAcmV0dXJuIHtTdHJpbmd8Tm9kZXxOb2RlTGlzdHxBcnJheX0gVGhlIGNsb25lZCBlbGVtZW50KHMpXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBjb25zdCBfY2xvbmUgPSBlbGVtZW50ID0+IHtcbiAgaWYodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gZWxzZSBpZihlbGVtZW50IGluc3RhbmNlb2YgTm9kZSkge1xuICAgIHJldHVybiBlbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgfSBlbHNlIGlmKCdsZW5ndGgnIGluIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gW10ubWFwLmNhbGwoZWxlbWVudCwgZWwgPT4gZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogU3BlY2lhbGl6ZWQgaXRlcmF0aW9uLCBhcHBseWluZyBgZm5gIGluIHJldmVyc2VkIG1hbm5lciB0byBhIGNsb25lIG9mIGVhY2ggZWxlbWVudCwgYnV0IHRoZSBwcm92aWRlZCBvbmUuXG4gKlxuICogQHBhcmFtIHtOb2RlTGlzdHxBcnJheX0gY29sbGVjdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7Tm9kZX0gZWxlbWVudFxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgY29uc3QgX2VhY2ggPSAoY29sbGVjdGlvbiwgZm4sIGVsZW1lbnQpID0+IHtcbiAgbGV0IGwgPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgd2hpbGUobC0tKSB7XG4gICAgY29uc3QgZWxtID0gbCA9PT0gMCA/IGVsZW1lbnQgOiBfY2xvbmUoZWxlbWVudCk7XG4gICAgZm4uY2FsbChjb2xsZWN0aW9uW2xdLCBlbG0pO1xuICB9XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/dom/index.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/event/index.js":
/*!***************************************************!*\
  !*** ./node_modules/domtastic/src/event/index.js ***!
  \***************************************************/
/*! exports provided: on, off, one, getHandlers, clearHandlers, proxyHandler, delegateHandler, bind, unbind */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"on\", function() { return on; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"off\", function() { return off; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"one\", function() { return one; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getHandlers\", function() { return getHandlers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearHandlers\", function() { return clearHandlers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"proxyHandler\", function() { return proxyHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"delegateHandler\", function() { return delegateHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bind\", function() { return bind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unbind\", function() { return unbind; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/domtastic/src/util.js\");\n/* harmony import */ var _selector_closest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector/closest */ \"./node_modules/domtastic/src/selector/closest.js\");\n/**\n * @module Events\n */\n\n\n\n\n/**\n * Shorthand for `addEventListener`. Supports event delegation if a filter (`selector`) is provided.\n *\n * @param {String} eventNames List of space-separated event types to be added to the element(s)\n * @param {String} [selector] Selector to filter descendants that delegate the event to this element.\n * @param {Function} handler Event handler\n * @param {Boolean} useCapture=false\n * @param {Boolean} once=false\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.item').on('click', callback);\n *     $('.container').on('click focus', '.item', handler);\n */\n\nconst on = function(eventNames, selector, handler, useCapture, once) {\n\n  if(typeof selector === 'function') {\n    handler = selector;\n    selector = null;\n  }\n\n  let parts,\n    namespace,\n    eventListener;\n\n  eventNames.split(' ').forEach(eventName => {\n\n    parts = eventName.split('.');\n    eventName = parts[0] || null;\n    namespace = parts[1] || null;\n\n    eventListener = proxyHandler(handler);\n\n    Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => {\n\n      if(selector) {\n        eventListener = delegateHandler.bind(element, selector, eventListener);\n      }\n\n      if(once) {\n        const listener = eventListener;\n        eventListener = event => {\n          off.call(element, eventNames, selector, handler, useCapture);\n          listener.call(element, event);\n        };\n      }\n\n      element.addEventListener(eventName, eventListener, useCapture || false);\n\n      getHandlers(element).push({\n        eventName,\n        handler,\n        eventListener,\n        selector,\n        namespace\n      });\n    });\n\n  }, this);\n\n  return this;\n};\n\n/**\n * Shorthand for `removeEventListener`.\n *\n * @param {String} eventNames List of space-separated event types to be removed from the element(s)\n * @param {String} [selector] Selector to filter descendants that undelegate the event to this element.\n * @param {Function} handler Event handler\n * @param {Boolean} useCapture=false\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.item').off('click', callback);\n *     $('#my-element').off('myEvent myOtherEvent');\n *     $('.item').off();\n */\n\nconst off = function(eventNames = '', selector, handler, useCapture) {\n\n  if(typeof selector === 'function') {\n    handler = selector;\n    selector = null;\n  }\n\n  let parts,\n    namespace,\n    handlers;\n\n  eventNames.split(' ').forEach(eventName => {\n\n    parts = eventName.split('.');\n    eventName = parts[0] || null;\n    namespace = parts[1] || null;\n\n    return Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => {\n\n      handlers = getHandlers(element);\n\n      Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(handlers.filter(item => {\n        return (\n          (!eventName || item.eventName === eventName) &&\n          (!namespace || item.namespace === namespace) &&\n          (!handler || item.handler === handler) &&\n          (!selector || item.selector === selector)\n        );\n      }), item => {\n        element.removeEventListener(item.eventName, item.eventListener, useCapture || false);\n        handlers.splice(handlers.indexOf(item), 1);\n      });\n\n      if(!eventName && !namespace && !selector && !handler) {\n        clearHandlers(element);\n      } else if(handlers.length === 0) {\n        clearHandlers(element);\n      }\n\n    });\n\n  }, this);\n\n  return this;\n};\n\n/**\n * Add event listener and execute the handler at most once per element.\n *\n * @param eventNames\n * @param selector\n * @param handler\n * @param useCapture\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.item').one('click', callback);\n */\n\nconst one = function(eventNames, selector, handler, useCapture) {\n  return on.call(this, eventNames, selector, handler, useCapture, 1);\n};\n\n/**\n * Get event handlers from an element\n *\n * @private\n * @param {Node} element\n * @return {Array}\n */\n\nconst eventKeyProp = '__domtastic_event__';\nlet id = 1;\nlet handlers = {};\nlet unusedKeys = [];\n\nconst getHandlers = element => {\n  if(!element[eventKeyProp]) {\n    element[eventKeyProp] = unusedKeys.length === 0 ? ++id : unusedKeys.pop();\n  }\n  const key = element[eventKeyProp];\n  return handlers[key] || (handlers[key] = []);\n};\n\n/**\n * Clear event handlers for an element\n *\n * @private\n * @param {Node} element\n */\n\nconst clearHandlers = element => {\n  const key = element[eventKeyProp];\n  if(handlers[key]) {\n    handlers[key] = null;\n    element[eventKeyProp] = null;\n    unusedKeys.push(key);\n  }\n};\n\n/**\n * Function to create a handler that augments the event object with some extra methods,\n * and executes the callback with the event and the event data (i.e. `event.detail`).\n *\n * @private\n * @param handler Callback to execute as `handler(event, data)`\n * @return {Function}\n */\n\nconst proxyHandler = handler => function(event) {\n  return handler.call(this, augmentEvent(event));\n};\n\nconst eventMethods = {\n  preventDefault: 'isDefaultPrevented',\n  stopImmediatePropagation: 'isImmediatePropagationStopped',\n  stopPropagation: 'isPropagationStopped'\n};\nconst returnTrue = () => true;\nconst returnFalse = () => false;\n\n/**\n * Attempt to augment events and implement something closer to DOM Level 3 Events.\n *\n * @private\n * @param {Object} event\n * @return {Function}\n */\n\nconst augmentEvent = event => {\n  if(!event.isDefaultPrevented || event.stopImmediatePropagation || event.stopPropagation) {\n    for(const methodName in eventMethods) {\n      (function(methodName, testMethodName, originalMethod) {\n        event[methodName] = function() {\n          this[testMethodName] = returnTrue;\n          return originalMethod && originalMethod.apply(this, arguments);\n        };\n        event[testMethodName] = returnFalse;\n      }(methodName, eventMethods[methodName], event[methodName]));\n    }\n    if(event._preventDefault) {\n      event.preventDefault();\n    }\n  }\n  return event;\n};\n\n/**\n * Function to test whether delegated events match the provided `selector` (filter),\n * if the event propagation was stopped, and then actually call the provided event handler.\n * Use `this` instead of `event.currentTarget` on the event object.\n *\n * @private\n * @param {String} selector Selector to filter descendants that undelegate the event to this element.\n * @param {Function} handler Event handler\n * @param {Event} event\n */\n\nconst delegateHandler = function(selector, handler, event) {\n  const eventTarget = event._target || event.target;\n  const currentTarget = _selector_closest__WEBPACK_IMPORTED_MODULE_1__[\"closest\"].call([eventTarget], selector, this)[0];\n  if(currentTarget && currentTarget !== this) {\n    if(currentTarget === eventTarget || !(event.isPropagationStopped && event.isPropagationStopped())) {\n      handler.call(currentTarget, event);\n    }\n  }\n};\n\nconst bind = on;\nconst unbind = off;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9ldmVudC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb210YXN0aWMvc3JjL2V2ZW50L2luZGV4LmpzPzg1M2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIEV2ZW50c1xuICovXG5cbmltcG9ydCB7IGVhY2ggfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB7IGNsb3Nlc3QgfSBmcm9tICcuLi9zZWxlY3Rvci9jbG9zZXN0JztcblxuLyoqXG4gKiBTaG9ydGhhbmQgZm9yIGBhZGRFdmVudExpc3RlbmVyYC4gU3VwcG9ydHMgZXZlbnQgZGVsZWdhdGlvbiBpZiBhIGZpbHRlciAoYHNlbGVjdG9yYCkgaXMgcHJvdmlkZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZXMgTGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgdHlwZXMgdG8gYmUgYWRkZWQgdG8gdGhlIGVsZW1lbnQocylcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3JdIFNlbGVjdG9yIHRvIGZpbHRlciBkZXNjZW5kYW50cyB0aGF0IGRlbGVnYXRlIHRoZSBldmVudCB0byB0aGlzIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlQ2FwdHVyZT1mYWxzZVxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlPWZhbHNlXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB3cmFwcGVkIGNvbGxlY3Rpb25cbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKiAgICAgJCgnLml0ZW0nKS5vbignY2xpY2snLCBjYWxsYmFjayk7XG4gKiAgICAgJCgnLmNvbnRhaW5lcicpLm9uKCdjbGljayBmb2N1cycsICcuaXRlbScsIGhhbmRsZXIpO1xuICovXG5cbmV4cG9ydCBjb25zdCBvbiA9IGZ1bmN0aW9uKGV2ZW50TmFtZXMsIHNlbGVjdG9yLCBoYW5kbGVyLCB1c2VDYXB0dXJlLCBvbmNlKSB7XG5cbiAgaWYodHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaGFuZGxlciA9IHNlbGVjdG9yO1xuICAgIHNlbGVjdG9yID0gbnVsbDtcbiAgfVxuXG4gIGxldCBwYXJ0cyxcbiAgICBuYW1lc3BhY2UsXG4gICAgZXZlbnRMaXN0ZW5lcjtcblxuICBldmVudE5hbWVzLnNwbGl0KCcgJykuZm9yRWFjaChldmVudE5hbWUgPT4ge1xuXG4gICAgcGFydHMgPSBldmVudE5hbWUuc3BsaXQoJy4nKTtcbiAgICBldmVudE5hbWUgPSBwYXJ0c1swXSB8fCBudWxsO1xuICAgIG5hbWVzcGFjZSA9IHBhcnRzWzFdIHx8IG51bGw7XG5cbiAgICBldmVudExpc3RlbmVyID0gcHJveHlIYW5kbGVyKGhhbmRsZXIpO1xuXG4gICAgZWFjaCh0aGlzLCBlbGVtZW50ID0+IHtcblxuICAgICAgaWYoc2VsZWN0b3IpIHtcbiAgICAgICAgZXZlbnRMaXN0ZW5lciA9IGRlbGVnYXRlSGFuZGxlci5iaW5kKGVsZW1lbnQsIHNlbGVjdG9yLCBldmVudExpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYob25jZSkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGV2ZW50TGlzdGVuZXI7XG4gICAgICAgIGV2ZW50TGlzdGVuZXIgPSBldmVudCA9PiB7XG4gICAgICAgICAgb2ZmLmNhbGwoZWxlbWVudCwgZXZlbnROYW1lcywgc2VsZWN0b3IsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICAgIGxpc3RlbmVyLmNhbGwoZWxlbWVudCwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudExpc3RlbmVyLCB1c2VDYXB0dXJlIHx8IGZhbHNlKTtcblxuICAgICAgZ2V0SGFuZGxlcnMoZWxlbWVudCkucHVzaCh7XG4gICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgaGFuZGxlcixcbiAgICAgICAgZXZlbnRMaXN0ZW5lcixcbiAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgfSwgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNob3J0aGFuZCBmb3IgYHJlbW92ZUV2ZW50TGlzdGVuZXJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVzIExpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIGV2ZW50IHR5cGVzIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudChzKVxuICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3Rvcl0gU2VsZWN0b3IgdG8gZmlsdGVyIGRlc2NlbmRhbnRzIHRoYXQgdW5kZWxlZ2F0ZSB0aGUgZXZlbnQgdG8gdGhpcyBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBFdmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHVzZUNhcHR1cmU9ZmFsc2VcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHdyYXBwZWQgY29sbGVjdGlvblxuICogQGNoYWluYWJsZVxuICogQGV4YW1wbGVcbiAqICAgICAkKCcuaXRlbScpLm9mZignY2xpY2snLCBjYWxsYmFjayk7XG4gKiAgICAgJCgnI215LWVsZW1lbnQnKS5vZmYoJ215RXZlbnQgbXlPdGhlckV2ZW50Jyk7XG4gKiAgICAgJCgnLml0ZW0nKS5vZmYoKTtcbiAqL1xuXG5leHBvcnQgY29uc3Qgb2ZmID0gZnVuY3Rpb24oZXZlbnROYW1lcyA9ICcnLCBzZWxlY3RvciwgaGFuZGxlciwgdXNlQ2FwdHVyZSkge1xuXG4gIGlmKHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGhhbmRsZXIgPSBzZWxlY3RvcjtcbiAgICBzZWxlY3RvciA9IG51bGw7XG4gIH1cblxuICBsZXQgcGFydHMsXG4gICAgbmFtZXNwYWNlLFxuICAgIGhhbmRsZXJzO1xuXG4gIGV2ZW50TmFtZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG5cbiAgICBwYXJ0cyA9IGV2ZW50TmFtZS5zcGxpdCgnLicpO1xuICAgIGV2ZW50TmFtZSA9IHBhcnRzWzBdIHx8IG51bGw7XG4gICAgbmFtZXNwYWNlID0gcGFydHNbMV0gfHwgbnVsbDtcblxuICAgIHJldHVybiBlYWNoKHRoaXMsIGVsZW1lbnQgPT4ge1xuXG4gICAgICBoYW5kbGVycyA9IGdldEhhbmRsZXJzKGVsZW1lbnQpO1xuXG4gICAgICBlYWNoKGhhbmRsZXJzLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoIWV2ZW50TmFtZSB8fCBpdGVtLmV2ZW50TmFtZSA9PT0gZXZlbnROYW1lKSAmJlxuICAgICAgICAgICghbmFtZXNwYWNlIHx8IGl0ZW0ubmFtZXNwYWNlID09PSBuYW1lc3BhY2UpICYmXG4gICAgICAgICAgKCFoYW5kbGVyIHx8IGl0ZW0uaGFuZGxlciA9PT0gaGFuZGxlcikgJiZcbiAgICAgICAgICAoIXNlbGVjdG9yIHx8IGl0ZW0uc2VsZWN0b3IgPT09IHNlbGVjdG9yKVxuICAgICAgICApO1xuICAgICAgfSksIGl0ZW0gPT4ge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoaXRlbS5ldmVudE5hbWUsIGl0ZW0uZXZlbnRMaXN0ZW5lciwgdXNlQ2FwdHVyZSB8fCBmYWxzZSk7XG4gICAgICAgIGhhbmRsZXJzLnNwbGljZShoYW5kbGVycy5pbmRleE9mKGl0ZW0pLCAxKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZighZXZlbnROYW1lICYmICFuYW1lc3BhY2UgJiYgIXNlbGVjdG9yICYmICFoYW5kbGVyKSB7XG4gICAgICAgIGNsZWFySGFuZGxlcnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYoaGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNsZWFySGFuZGxlcnMoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9LCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGV2ZW50IGxpc3RlbmVyIGFuZCBleGVjdXRlIHRoZSBoYW5kbGVyIGF0IG1vc3Qgb25jZSBwZXIgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gZXZlbnROYW1lc1xuICogQHBhcmFtIHNlbGVjdG9yXG4gKiBAcGFyYW0gaGFuZGxlclxuICogQHBhcmFtIHVzZUNhcHR1cmVcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHdyYXBwZWQgY29sbGVjdGlvblxuICogQGNoYWluYWJsZVxuICogQGV4YW1wbGVcbiAqICAgICAkKCcuaXRlbScpLm9uZSgnY2xpY2snLCBjYWxsYmFjayk7XG4gKi9cblxuZXhwb3J0IGNvbnN0IG9uZSA9IGZ1bmN0aW9uKGV2ZW50TmFtZXMsIHNlbGVjdG9yLCBoYW5kbGVyLCB1c2VDYXB0dXJlKSB7XG4gIHJldHVybiBvbi5jYWxsKHRoaXMsIGV2ZW50TmFtZXMsIHNlbGVjdG9yLCBoYW5kbGVyLCB1c2VDYXB0dXJlLCAxKTtcbn07XG5cbi8qKlxuICogR2V0IGV2ZW50IGhhbmRsZXJzIGZyb20gYW4gZWxlbWVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge05vZGV9IGVsZW1lbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmNvbnN0IGV2ZW50S2V5UHJvcCA9ICdfX2RvbXRhc3RpY19ldmVudF9fJztcbmxldCBpZCA9IDE7XG5sZXQgaGFuZGxlcnMgPSB7fTtcbmxldCB1bnVzZWRLZXlzID0gW107XG5cbmV4cG9ydCBjb25zdCBnZXRIYW5kbGVycyA9IGVsZW1lbnQgPT4ge1xuICBpZighZWxlbWVudFtldmVudEtleVByb3BdKSB7XG4gICAgZWxlbWVudFtldmVudEtleVByb3BdID0gdW51c2VkS2V5cy5sZW5ndGggPT09IDAgPyArK2lkIDogdW51c2VkS2V5cy5wb3AoKTtcbiAgfVxuICBjb25zdCBrZXkgPSBlbGVtZW50W2V2ZW50S2V5UHJvcF07XG4gIHJldHVybiBoYW5kbGVyc1trZXldIHx8IChoYW5kbGVyc1trZXldID0gW10pO1xufTtcblxuLyoqXG4gKiBDbGVhciBldmVudCBoYW5kbGVycyBmb3IgYW4gZWxlbWVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge05vZGV9IGVsZW1lbnRcbiAqL1xuXG5leHBvcnQgY29uc3QgY2xlYXJIYW5kbGVycyA9IGVsZW1lbnQgPT4ge1xuICBjb25zdCBrZXkgPSBlbGVtZW50W2V2ZW50S2V5UHJvcF07XG4gIGlmKGhhbmRsZXJzW2tleV0pIHtcbiAgICBoYW5kbGVyc1trZXldID0gbnVsbDtcbiAgICBlbGVtZW50W2V2ZW50S2V5UHJvcF0gPSBudWxsO1xuICAgIHVudXNlZEtleXMucHVzaChrZXkpO1xuICB9XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGhhbmRsZXIgdGhhdCBhdWdtZW50cyB0aGUgZXZlbnQgb2JqZWN0IHdpdGggc29tZSBleHRyYSBtZXRob2RzLFxuICogYW5kIGV4ZWN1dGVzIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBldmVudCBhbmQgdGhlIGV2ZW50IGRhdGEgKGkuZS4gYGV2ZW50LmRldGFpbGApLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gaGFuZGxlciBDYWxsYmFjayB0byBleGVjdXRlIGFzIGBoYW5kbGVyKGV2ZW50LCBkYXRhKWBcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmV4cG9ydCBjb25zdCBwcm94eUhhbmRsZXIgPSBoYW5kbGVyID0+IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgYXVnbWVudEV2ZW50KGV2ZW50KSk7XG59O1xuXG5jb25zdCBldmVudE1ldGhvZHMgPSB7XG4gIHByZXZlbnREZWZhdWx0OiAnaXNEZWZhdWx0UHJldmVudGVkJyxcbiAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiAnaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQnLFxuICBzdG9wUHJvcGFnYXRpb246ICdpc1Byb3BhZ2F0aW9uU3RvcHBlZCdcbn07XG5jb25zdCByZXR1cm5UcnVlID0gKCkgPT4gdHJ1ZTtcbmNvbnN0IHJldHVybkZhbHNlID0gKCkgPT4gZmFsc2U7XG5cbi8qKlxuICogQXR0ZW1wdCB0byBhdWdtZW50IGV2ZW50cyBhbmQgaW1wbGVtZW50IHNvbWV0aGluZyBjbG9zZXIgdG8gRE9NIExldmVsIDMgRXZlbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmNvbnN0IGF1Z21lbnRFdmVudCA9IGV2ZW50ID0+IHtcbiAgaWYoIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCB8fCBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gfHwgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgZm9yKGNvbnN0IG1ldGhvZE5hbWUgaW4gZXZlbnRNZXRob2RzKSB7XG4gICAgICAoZnVuY3Rpb24obWV0aG9kTmFtZSwgdGVzdE1ldGhvZE5hbWUsIG9yaWdpbmFsTWV0aG9kKSB7XG4gICAgICAgIGV2ZW50W21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpc1t0ZXN0TWV0aG9kTmFtZV0gPSByZXR1cm5UcnVlO1xuICAgICAgICAgIHJldHVybiBvcmlnaW5hbE1ldGhvZCAmJiBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICBldmVudFt0ZXN0TWV0aG9kTmFtZV0gPSByZXR1cm5GYWxzZTtcbiAgICAgIH0obWV0aG9kTmFtZSwgZXZlbnRNZXRob2RzW21ldGhvZE5hbWVdLCBldmVudFttZXRob2ROYW1lXSkpO1xuICAgIH1cbiAgICBpZihldmVudC5fcHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBldmVudDtcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gdGVzdCB3aGV0aGVyIGRlbGVnYXRlZCBldmVudHMgbWF0Y2ggdGhlIHByb3ZpZGVkIGBzZWxlY3RvcmAgKGZpbHRlciksXG4gKiBpZiB0aGUgZXZlbnQgcHJvcGFnYXRpb24gd2FzIHN0b3BwZWQsIGFuZCB0aGVuIGFjdHVhbGx5IGNhbGwgdGhlIHByb3ZpZGVkIGV2ZW50IGhhbmRsZXIuXG4gKiBVc2UgYHRoaXNgIGluc3RlYWQgb2YgYGV2ZW50LmN1cnJlbnRUYXJnZXRgIG9uIHRoZSBldmVudCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byBmaWx0ZXIgZGVzY2VuZGFudHMgdGhhdCB1bmRlbGVnYXRlIHRoZSBldmVudCB0byB0aGlzIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKi9cblxuZXhwb3J0IGNvbnN0IGRlbGVnYXRlSGFuZGxlciA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBoYW5kbGVyLCBldmVudCkge1xuICBjb25zdCBldmVudFRhcmdldCA9IGV2ZW50Ll90YXJnZXQgfHwgZXZlbnQudGFyZ2V0O1xuICBjb25zdCBjdXJyZW50VGFyZ2V0ID0gY2xvc2VzdC5jYWxsKFtldmVudFRhcmdldF0sIHNlbGVjdG9yLCB0aGlzKVswXTtcbiAgaWYoY3VycmVudFRhcmdldCAmJiBjdXJyZW50VGFyZ2V0ICE9PSB0aGlzKSB7XG4gICAgaWYoY3VycmVudFRhcmdldCA9PT0gZXZlbnRUYXJnZXQgfHwgIShldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCAmJiBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSkge1xuICAgICAgaGFuZGxlci5jYWxsKGN1cnJlbnRUYXJnZXQsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBiaW5kID0gb247XG5leHBvcnQgY29uc3QgdW5iaW5kID0gb2ZmO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/event/index.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/event/ready.js":
/*!***************************************************!*\
  !*** ./node_modules/domtastic/src/event/ready.js ***!
  \***************************************************/
/*! exports provided: ready */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ready\", function() { return ready; });\n/**\n * @module Ready\n */\n\n/**\n * Execute callback when `DOMContentLoaded` fires for `document`, or immediately if called afterwards.\n *\n * @param handler Callback to execute when initial DOM content is loaded.\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $(document).ready(callback);\n */\n\nconst ready = function(handler) {\n  if(/complete|loaded|interactive/.test(document.readyState) && document.body) {\n    handler();\n  } else {\n    document.addEventListener('DOMContentLoaded', handler, false);\n  }\n  return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9ldmVudC9yZWFkeS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb210YXN0aWMvc3JjL2V2ZW50L3JlYWR5LmpzP2UyNTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIFJlYWR5XG4gKi9cblxuLyoqXG4gKiBFeGVjdXRlIGNhbGxiYWNrIHdoZW4gYERPTUNvbnRlbnRMb2FkZWRgIGZpcmVzIGZvciBgZG9jdW1lbnRgLCBvciBpbW1lZGlhdGVseSBpZiBjYWxsZWQgYWZ0ZXJ3YXJkcy5cbiAqXG4gKiBAcGFyYW0gaGFuZGxlciBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gaW5pdGlhbCBET00gY29udGVudCBpcyBsb2FkZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB3cmFwcGVkIGNvbGxlY3Rpb25cbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKiAgICAgJChkb2N1bWVudCkucmVhZHkoY2FsbGJhY2spO1xuICovXG5cbmV4cG9ydCBjb25zdCByZWFkeSA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgaWYoL2NvbXBsZXRlfGxvYWRlZHxpbnRlcmFjdGl2ZS8udGVzdChkb2N1bWVudC5yZWFkeVN0YXRlKSAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgaGFuZGxlcigpO1xuICB9IGVsc2Uge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/event/ready.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/event/trigger.js":
/*!*****************************************************!*\
  !*** ./node_modules/domtastic/src/event/trigger.js ***!
  \*****************************************************/
/*! exports provided: trigger, triggerHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"trigger\", function() { return trigger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"triggerHandler\", function() { return triggerHandler; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/domtastic/src/util.js\");\n/* harmony import */ var _dom_contains__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom/contains */ \"./node_modules/domtastic/src/dom/contains.js\");\n/**\n * @module trigger\n */\n\n\n\n\nconst reMouseEvent = /^(mouse(down|up|over|out|enter|leave|move)|contextmenu|(dbl)?click)$/;\nconst reKeyEvent = /^key(down|press|up)$/;\n\n/**\n * Trigger event at element(s)\n *\n * @param {String} type Type of the event\n * @param {Object} data Data to be sent with the event (`params.detail` will be set to this).\n * @param {Object} [params] Event parameters (optional)\n * @param {Boolean} params.bubbles=true Does the event bubble up through the DOM or not.\n * @param {Boolean} params.cancelable=true Is the event cancelable or not.\n * @param {Mixed} params.detail=undefined Additional information about the event.\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     $('.item').trigger('anyEventType');\n */\n\nconst trigger = function(type, data, {bubbles = true, cancelable = true, preventDefault = false} = {}) {\n\n  const EventConstructor = getEventConstructor(type);\n  const event = new EventConstructor(type, {\n    bubbles,\n    cancelable,\n    preventDefault,\n    detail: data\n  });\n\n  event._preventDefault = preventDefault;\n\n  return Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => {\n    if(!bubbles || isEventBubblingInDetachedTree || isAttachedToDocument(element)) {\n      dispatchEvent(element, event);\n    } else {\n      triggerForPath(element, type, {\n        bubbles,\n        cancelable,\n        preventDefault,\n        detail: data\n      });\n    }\n  });\n};\n\nconst getEventConstructor = type => isSupportsOtherEventConstructors ? (reMouseEvent.test(type) ? MouseEvent : (reKeyEvent.test(type) ? KeyboardEvent : CustomEvent)) : CustomEvent;\n\n/**\n * Trigger event at first element in the collection. Similar to `trigger()`, except:\n *\n * - Event does not bubble\n * - Default event behavior is prevented\n * - Only triggers handler for first matching element\n *\n * @param {String} type Type of the event\n * @param {Object} data Data to be sent with the event\n * @example\n *     $('form').triggerHandler('submit');\n */\n\nconst triggerHandler = function(type, data) {\n  if(this[0]) {\n    trigger.call(this[0], type, data, {\n      bubbles: false,\n      preventDefault: true\n    });\n  }\n};\n\n/**\n * Check whether the element is attached to or detached from) the document\n *\n * @private\n * @param {Node} element Element to test\n * @return {Boolean}\n */\n\nconst isAttachedToDocument = element => {\n  if(element === window || element === document) {\n    return true;\n  }\n  return Object(_dom_contains__WEBPACK_IMPORTED_MODULE_1__[\"contains\"])(element.ownerDocument.documentElement, element);\n};\n\n/**\n * Dispatch the event at the element and its ancestors.\n * Required to support delegated events in browsers that don't bubble events in detached DOM trees.\n *\n * @private\n * @param {Node} element First element to dispatch the event at\n * @param {String} type Type of the event\n * @param {Object} [params] Event parameters (optional)\n * @param {Boolean} params.bubbles=true Does the event bubble up through the DOM or not.\n * Will be set to false (but shouldn't matter since events don't bubble anyway).\n * @param {Boolean} params.cancelable=true Is the event cancelable or not.\n * @param {Mixed} params.detail=undefined Additional information about the event.\n */\n\nconst triggerForPath = (element, type, params = {}) => {\n  params.bubbles = false;\n  const event = new CustomEvent(type, params);\n  event._target = element;\n  do {\n    dispatchEvent(element, event);\n  } while(element = element.parentNode); // eslint-disable-line no-cond-assign\n};\n\n/**\n * Dispatch event to element, but call direct event methods instead if available\n * (e.g. \"blur()\", \"submit()\") and if the event is non-cancelable.\n *\n * @private\n * @param {Node} element Element to dispatch the event at\n * @param {Object} event Event to dispatch\n */\n\nconst directEventMethods = ['blur', 'focus', 'select', 'submit'];\n\nconst dispatchEvent = (element, event) => {\n  if(directEventMethods.indexOf(event.type) !== -1 && typeof element[event.type] === 'function' && !event._preventDefault && !event.cancelable) {\n    element[event.type]();\n  } else {\n    element.dispatchEvent(event);\n  }\n};\n\n/**\n * Polyfill for CustomEvent, borrowed from [MDN](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill).\n * Needed to support IE (9, 10, 11) & PhantomJS\n */\n\n(() => {\n  const CustomEvent = function(event, params = {\n    bubbles: false,\n    cancelable: false,\n    detail: undefined\n  }) {\n    let customEvent = document.createEvent('CustomEvent');\n    customEvent.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return customEvent;\n  };\n\n  CustomEvent.prototype = _util__WEBPACK_IMPORTED_MODULE_0__[\"win\"].CustomEvent && _util__WEBPACK_IMPORTED_MODULE_0__[\"win\"].CustomEvent.prototype;\n  _util__WEBPACK_IMPORTED_MODULE_0__[\"win\"].CustomEvent = CustomEvent;\n\n})();\n\n/*\n * Are events bubbling in detached DOM trees?\n * @private\n */\n\nconst isEventBubblingInDetachedTree = (() =>{\n  let isBubbling = false;\n  const doc = _util__WEBPACK_IMPORTED_MODULE_0__[\"win\"].document;\n  if(doc) {\n    const parent = doc.createElement('div');\n    const child = parent.cloneNode();\n    parent.appendChild(child);\n    parent.addEventListener('e', function() {\n      isBubbling = true;\n    });\n    child.dispatchEvent(new CustomEvent('e', {bubbles: true}));\n  }\n  return isBubbling;\n})();\n\nconst isSupportsOtherEventConstructors = (() => {\n  try {\n    new MouseEvent('click');\n  } catch(e) {\n    return false;\n  }\n  return true;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9ldmVudC90cmlnZ2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbXRhc3RpYy9zcmMvZXZlbnQvdHJpZ2dlci5qcz81ZDFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSB0cmlnZ2VyXG4gKi9cblxuaW1wb3J0IHsgd2luLCBlYWNoIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgeyBjb250YWlucyB9IGZyb20gJy4uL2RvbS9jb250YWlucyc7XG5cbmNvbnN0IHJlTW91c2VFdmVudCA9IC9eKG1vdXNlKGRvd258dXB8b3ZlcnxvdXR8ZW50ZXJ8bGVhdmV8bW92ZSl8Y29udGV4dG1lbnV8KGRibCk/Y2xpY2spJC87XG5jb25zdCByZUtleUV2ZW50ID0gL15rZXkoZG93bnxwcmVzc3x1cCkkLztcblxuLyoqXG4gKiBUcmlnZ2VyIGV2ZW50IGF0IGVsZW1lbnQocylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIHRoZSBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgRGF0YSB0byBiZSBzZW50IHdpdGggdGhlIGV2ZW50IChgcGFyYW1zLmRldGFpbGAgd2lsbCBiZSBzZXQgdG8gdGhpcykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gRXZlbnQgcGFyYW1ldGVycyAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5idWJibGVzPXRydWUgRG9lcyB0aGUgZXZlbnQgYnViYmxlIHVwIHRocm91Z2ggdGhlIERPTSBvciBub3QuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5jYW5jZWxhYmxlPXRydWUgSXMgdGhlIGV2ZW50IGNhbmNlbGFibGUgb3Igbm90LlxuICogQHBhcmFtIHtNaXhlZH0gcGFyYW1zLmRldGFpbD11bmRlZmluZWQgQWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB3cmFwcGVkIGNvbGxlY3Rpb25cbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKiAgICAgJCgnLml0ZW0nKS50cmlnZ2VyKCdhbnlFdmVudFR5cGUnKTtcbiAqL1xuXG5leHBvcnQgY29uc3QgdHJpZ2dlciA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEsIHtidWJibGVzID0gdHJ1ZSwgY2FuY2VsYWJsZSA9IHRydWUsIHByZXZlbnREZWZhdWx0ID0gZmFsc2V9ID0ge30pIHtcblxuICBjb25zdCBFdmVudENvbnN0cnVjdG9yID0gZ2V0RXZlbnRDb25zdHJ1Y3Rvcih0eXBlKTtcbiAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnRDb25zdHJ1Y3Rvcih0eXBlLCB7XG4gICAgYnViYmxlcyxcbiAgICBjYW5jZWxhYmxlLFxuICAgIHByZXZlbnREZWZhdWx0LFxuICAgIGRldGFpbDogZGF0YVxuICB9KTtcblxuICBldmVudC5fcHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDtcblxuICByZXR1cm4gZWFjaCh0aGlzLCBlbGVtZW50ID0+IHtcbiAgICBpZighYnViYmxlcyB8fCBpc0V2ZW50QnViYmxpbmdJbkRldGFjaGVkVHJlZSB8fCBpc0F0dGFjaGVkVG9Eb2N1bWVudChlbGVtZW50KSkge1xuICAgICAgZGlzcGF0Y2hFdmVudChlbGVtZW50LCBldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJGb3JQYXRoKGVsZW1lbnQsIHR5cGUsIHtcbiAgICAgICAgYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZSxcbiAgICAgICAgcHJldmVudERlZmF1bHQsXG4gICAgICAgIGRldGFpbDogZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cbmNvbnN0IGdldEV2ZW50Q29uc3RydWN0b3IgPSB0eXBlID0+IGlzU3VwcG9ydHNPdGhlckV2ZW50Q29uc3RydWN0b3JzID8gKHJlTW91c2VFdmVudC50ZXN0KHR5cGUpID8gTW91c2VFdmVudCA6IChyZUtleUV2ZW50LnRlc3QodHlwZSkgPyBLZXlib2FyZEV2ZW50IDogQ3VzdG9tRXZlbnQpKSA6IEN1c3RvbUV2ZW50O1xuXG4vKipcbiAqIFRyaWdnZXIgZXZlbnQgYXQgZmlyc3QgZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbi4gU2ltaWxhciB0byBgdHJpZ2dlcigpYCwgZXhjZXB0OlxuICpcbiAqIC0gRXZlbnQgZG9lcyBub3QgYnViYmxlXG4gKiAtIERlZmF1bHQgZXZlbnQgYmVoYXZpb3IgaXMgcHJldmVudGVkXG4gKiAtIE9ubHkgdHJpZ2dlcnMgaGFuZGxlciBmb3IgZmlyc3QgbWF0Y2hpbmcgZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb2YgdGhlIGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSBEYXRhIHRvIGJlIHNlbnQgd2l0aCB0aGUgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiAgICAgJCgnZm9ybScpLnRyaWdnZXJIYW5kbGVyKCdzdWJtaXQnKTtcbiAqL1xuXG5leHBvcnQgY29uc3QgdHJpZ2dlckhhbmRsZXIgPSBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gIGlmKHRoaXNbMF0pIHtcbiAgICB0cmlnZ2VyLmNhbGwodGhpc1swXSwgdHlwZSwgZGF0YSwge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYXR0YWNoZWQgdG8gb3IgZGV0YWNoZWQgZnJvbSkgdGhlIGRvY3VtZW50XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Tm9kZX0gZWxlbWVudCBFbGVtZW50IHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuY29uc3QgaXNBdHRhY2hlZFRvRG9jdW1lbnQgPSBlbGVtZW50ID0+IHtcbiAgaWYoZWxlbWVudCA9PT0gd2luZG93IHx8IGVsZW1lbnQgPT09IGRvY3VtZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGNvbnRhaW5zKGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGVsZW1lbnQpO1xufTtcblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgYXQgdGhlIGVsZW1lbnQgYW5kIGl0cyBhbmNlc3RvcnMuXG4gKiBSZXF1aXJlZCB0byBzdXBwb3J0IGRlbGVnYXRlZCBldmVudHMgaW4gYnJvd3NlcnMgdGhhdCBkb24ndCBidWJibGUgZXZlbnRzIGluIGRldGFjaGVkIERPTSB0cmVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOb2RlfSBlbGVtZW50IEZpcnN0IGVsZW1lbnQgdG8gZGlzcGF0Y2ggdGhlIGV2ZW50IGF0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIHRoZSBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIEV2ZW50IHBhcmFtZXRlcnMgKG9wdGlvbmFsKVxuICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuYnViYmxlcz10cnVlIERvZXMgdGhlIGV2ZW50IGJ1YmJsZSB1cCB0aHJvdWdoIHRoZSBET00gb3Igbm90LlxuICogV2lsbCBiZSBzZXQgdG8gZmFsc2UgKGJ1dCBzaG91bGRuJ3QgbWF0dGVyIHNpbmNlIGV2ZW50cyBkb24ndCBidWJibGUgYW55d2F5KS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLmNhbmNlbGFibGU9dHJ1ZSBJcyB0aGUgZXZlbnQgY2FuY2VsYWJsZSBvciBub3QuXG4gKiBAcGFyYW0ge01peGVkfSBwYXJhbXMuZGV0YWlsPXVuZGVmaW5lZCBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBldmVudC5cbiAqL1xuXG5jb25zdCB0cmlnZ2VyRm9yUGF0aCA9IChlbGVtZW50LCB0eXBlLCBwYXJhbXMgPSB7fSkgPT4ge1xuICBwYXJhbXMuYnViYmxlcyA9IGZhbHNlO1xuICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCh0eXBlLCBwYXJhbXMpO1xuICBldmVudC5fdGFyZ2V0ID0gZWxlbWVudDtcbiAgZG8ge1xuICAgIGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgZXZlbnQpO1xuICB9IHdoaWxlKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmQtYXNzaWduXG59O1xuXG4vKipcbiAqIERpc3BhdGNoIGV2ZW50IHRvIGVsZW1lbnQsIGJ1dCBjYWxsIGRpcmVjdCBldmVudCBtZXRob2RzIGluc3RlYWQgaWYgYXZhaWxhYmxlXG4gKiAoZS5nLiBcImJsdXIoKVwiLCBcInN1Ym1pdCgpXCIpIGFuZCBpZiB0aGUgZXZlbnQgaXMgbm9uLWNhbmNlbGFibGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Tm9kZX0gZWxlbWVudCBFbGVtZW50IHRvIGRpc3BhdGNoIHRoZSBldmVudCBhdFxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEV2ZW50IHRvIGRpc3BhdGNoXG4gKi9cblxuY29uc3QgZGlyZWN0RXZlbnRNZXRob2RzID0gWydibHVyJywgJ2ZvY3VzJywgJ3NlbGVjdCcsICdzdWJtaXQnXTtcblxuY29uc3QgZGlzcGF0Y2hFdmVudCA9IChlbGVtZW50LCBldmVudCkgPT4ge1xuICBpZihkaXJlY3RFdmVudE1ldGhvZHMuaW5kZXhPZihldmVudC50eXBlKSAhPT0gLTEgJiYgdHlwZW9mIGVsZW1lbnRbZXZlbnQudHlwZV0gPT09ICdmdW5jdGlvbicgJiYgIWV2ZW50Ll9wcmV2ZW50RGVmYXVsdCAmJiAhZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgIGVsZW1lbnRbZXZlbnQudHlwZV0oKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG59O1xuXG4vKipcbiAqIFBvbHlmaWxsIGZvciBDdXN0b21FdmVudCwgYm9ycm93ZWQgZnJvbSBbTUROXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnQjUG9seWZpbGwpLlxuICogTmVlZGVkIHRvIHN1cHBvcnQgSUUgKDksIDEwLCAxMSkgJiBQaGFudG9tSlNcbiAqL1xuXG4oKCkgPT4ge1xuICBjb25zdCBDdXN0b21FdmVudCA9IGZ1bmN0aW9uKGV2ZW50LCBwYXJhbXMgPSB7XG4gICAgYnViYmxlczogZmFsc2UsXG4gICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgZGV0YWlsOiB1bmRlZmluZWRcbiAgfSkge1xuICAgIGxldCBjdXN0b21FdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgIGN1c3RvbUV2ZW50LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICByZXR1cm4gY3VzdG9tRXZlbnQ7XG4gIH07XG5cbiAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luLkN1c3RvbUV2ZW50ICYmIHdpbi5DdXN0b21FdmVudC5wcm90b3R5cGU7XG4gIHdpbi5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50O1xuXG59KSgpO1xuXG4vKlxuICogQXJlIGV2ZW50cyBidWJibGluZyBpbiBkZXRhY2hlZCBET00gdHJlZXM/XG4gKiBAcHJpdmF0ZVxuICovXG5cbmNvbnN0IGlzRXZlbnRCdWJibGluZ0luRGV0YWNoZWRUcmVlID0gKCgpID0+e1xuICBsZXQgaXNCdWJibGluZyA9IGZhbHNlO1xuICBjb25zdCBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gIGlmKGRvYykge1xuICAgIGNvbnN0IHBhcmVudCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jbG9uZU5vZGUoKTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIHBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdlJywgZnVuY3Rpb24oKSB7XG4gICAgICBpc0J1YmJsaW5nID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBjaGlsZC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZScsIHtidWJibGVzOiB0cnVlfSkpO1xuICB9XG4gIHJldHVybiBpc0J1YmJsaW5nO1xufSkoKTtcblxuY29uc3QgaXNTdXBwb3J0c090aGVyRXZlbnRDb25zdHJ1Y3RvcnMgPSAoKCkgPT4ge1xuICB0cnkge1xuICAgIG5ldyBNb3VzZUV2ZW50KCdjbGljaycpO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/event/trigger.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/index.js":
/*!*********************************************!*\
  !*** ./node_modules/domtastic/src/index.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./node_modules/domtastic/src/util.js\");\n/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ \"./node_modules/domtastic/src/array.js\");\n/* harmony import */ var _baseClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./baseClass */ \"./node_modules/domtastic/src/baseClass.js\");\n/* harmony import */ var _css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./css */ \"./node_modules/domtastic/src/css.js\");\n/* harmony import */ var _dom_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom/index */ \"./node_modules/domtastic/src/dom/index.js\");\n/* harmony import */ var _dom_attr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dom/attr */ \"./node_modules/domtastic/src/dom/attr.js\");\n/* harmony import */ var _dom_class__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dom/class */ \"./node_modules/domtastic/src/dom/class.js\");\n/* harmony import */ var _dom_contains__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dom/contains */ \"./node_modules/domtastic/src/dom/contains.js\");\n/* harmony import */ var _dom_data__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dom/data */ \"./node_modules/domtastic/src/dom/data.js\");\n/* harmony import */ var _dom_extra__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./dom/extra */ \"./node_modules/domtastic/src/dom/extra.js\");\n/* harmony import */ var _dom_html__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./dom/html */ \"./node_modules/domtastic/src/dom/html.js\");\n/* harmony import */ var _event_index__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./event/index */ \"./node_modules/domtastic/src/event/index.js\");\n/* harmony import */ var _event_trigger__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./event/trigger */ \"./node_modules/domtastic/src/event/trigger.js\");\n/* harmony import */ var _event_ready__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./event/ready */ \"./node_modules/domtastic/src/event/ready.js\");\n/* harmony import */ var _noconflict__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./noconflict */ \"./node_modules/domtastic/src/noconflict.js\");\n/* harmony import */ var _selector_index__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./selector/index */ \"./node_modules/domtastic/src/selector/index.js\");\n/* harmony import */ var _selector_closest__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./selector/closest */ \"./node_modules/domtastic/src/selector/closest.js\");\n/* harmony import */ var _selector_extra__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./selector/extra */ \"./node_modules/domtastic/src/selector/extra.js\");\n/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./type */ \"./node_modules/domtastic/src/type.js\");\n/**\n * @module API\n */\n\n\n\nconst api = {};\nlet $ = {};\n\n// Import modules to build up the API\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif(typeof _selector_index__WEBPACK_IMPORTED_MODULE_15__ !== 'undefined') {\n  $ = _selector_index__WEBPACK_IMPORTED_MODULE_15__[\"$\"];\n  $.matches = _selector_index__WEBPACK_IMPORTED_MODULE_15__[\"matches\"];\n  api.find = _selector_index__WEBPACK_IMPORTED_MODULE_15__[\"find\"];\n}\n\nObject(_util__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])($, _dom_contains__WEBPACK_IMPORTED_MODULE_7__, _noconflict__WEBPACK_IMPORTED_MODULE_14__, _type__WEBPACK_IMPORTED_MODULE_18__);\nObject(_util__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])(api, _array__WEBPACK_IMPORTED_MODULE_1__, _css__WEBPACK_IMPORTED_MODULE_3__, _dom_attr__WEBPACK_IMPORTED_MODULE_5__, _dom_index__WEBPACK_IMPORTED_MODULE_4__, _dom_class__WEBPACK_IMPORTED_MODULE_6__, _dom_data__WEBPACK_IMPORTED_MODULE_8__, _dom_extra__WEBPACK_IMPORTED_MODULE_9__, _dom_html__WEBPACK_IMPORTED_MODULE_10__, _event_index__WEBPACK_IMPORTED_MODULE_11__, _event_trigger__WEBPACK_IMPORTED_MODULE_12__, _event_ready__WEBPACK_IMPORTED_MODULE_13__, _selector_closest__WEBPACK_IMPORTED_MODULE_16__, _selector_extra__WEBPACK_IMPORTED_MODULE_17__);\n\n$.fn = api;\n\n// Version\n\n$.version = '__VERSION__';\n\n// Util\n\n$.extend = _util__WEBPACK_IMPORTED_MODULE_0__[\"extend\"];\n\n// Provide base class to extend from\n\nif(typeof _baseClass__WEBPACK_IMPORTED_MODULE_2__[\"default\"] !== 'undefined') {\n  $.BaseClass = Object(_baseClass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])($.fn);\n}\n\n// Export interface\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ($);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb210YXN0aWMvc3JjL2luZGV4LmpzP2ZjZjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIEFQSVxuICovXG5cbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IGFwaSA9IHt9O1xubGV0ICQgPSB7fTtcblxuLy8gSW1wb3J0IG1vZHVsZXMgdG8gYnVpbGQgdXAgdGhlIEFQSVxuXG5pbXBvcnQgKiBhcyBhcnJheSBmcm9tICcuL2FycmF5JztcbmltcG9ydCBCYXNlQ2xhc3MgZnJvbSAnLi9iYXNlQ2xhc3MnO1xuaW1wb3J0ICogYXMgY3NzIGZyb20gJy4vY3NzJztcbmltcG9ydCAqIGFzIGRvbSBmcm9tICcuL2RvbS9pbmRleCc7XG5pbXBvcnQgKiBhcyBkb21fYXR0ciBmcm9tICcuL2RvbS9hdHRyJztcbmltcG9ydCAqIGFzIGRvbV9jbGFzcyBmcm9tICcuL2RvbS9jbGFzcyc7XG5pbXBvcnQgKiBhcyBkb21fY29udGFpbnMgZnJvbSAnLi9kb20vY29udGFpbnMnO1xuaW1wb3J0ICogYXMgZG9tX2RhdGEgZnJvbSAnLi9kb20vZGF0YSc7XG5pbXBvcnQgKiBhcyBkb21fZXh0cmEgZnJvbSAnLi9kb20vZXh0cmEnO1xuaW1wb3J0ICogYXMgZG9tX2h0bWwgZnJvbSAnLi9kb20vaHRtbCc7XG5pbXBvcnQgKiBhcyBldmVudCBmcm9tICcuL2V2ZW50L2luZGV4JztcbmltcG9ydCAqIGFzIGV2ZW50X3RyaWdnZXIgZnJvbSAnLi9ldmVudC90cmlnZ2VyJztcbmltcG9ydCAqIGFzIGV2ZW50X3JlYWR5IGZyb20gJy4vZXZlbnQvcmVhZHknO1xuaW1wb3J0ICogYXMgbm9jb25mbGljdCBmcm9tICcuL25vY29uZmxpY3QnO1xuaW1wb3J0ICogYXMgc2VsZWN0b3IgZnJvbSAnLi9zZWxlY3Rvci9pbmRleCc7XG5pbXBvcnQgKiBhcyBzZWxlY3Rvcl9jbG9zZXN0IGZyb20gJy4vc2VsZWN0b3IvY2xvc2VzdCc7XG5pbXBvcnQgKiBhcyBzZWxlY3Rvcl9leHRyYSBmcm9tICcuL3NlbGVjdG9yL2V4dHJhJztcbmltcG9ydCAqIGFzIHR5cGUgZnJvbSAnLi90eXBlJztcblxuaWYodHlwZW9mIHNlbGVjdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAkID0gc2VsZWN0b3IuJDtcbiAgJC5tYXRjaGVzID0gc2VsZWN0b3IubWF0Y2hlcztcbiAgYXBpLmZpbmQgPSBzZWxlY3Rvci5maW5kO1xufVxuXG5leHRlbmQoJCwgZG9tX2NvbnRhaW5zLCBub2NvbmZsaWN0LCB0eXBlKTtcbmV4dGVuZChhcGksIGFycmF5LCBjc3MsIGRvbV9hdHRyLCBkb20sIGRvbV9jbGFzcywgZG9tX2RhdGEsIGRvbV9leHRyYSwgZG9tX2h0bWwsIGV2ZW50LCBldmVudF90cmlnZ2VyLCBldmVudF9yZWFkeSwgc2VsZWN0b3JfY2xvc2VzdCwgc2VsZWN0b3JfZXh0cmEpO1xuXG4kLmZuID0gYXBpO1xuXG4vLyBWZXJzaW9uXG5cbiQudmVyc2lvbiA9ICdfX1ZFUlNJT05fXyc7XG5cbi8vIFV0aWxcblxuJC5leHRlbmQgPSBleHRlbmQ7XG5cbi8vIFByb3ZpZGUgYmFzZSBjbGFzcyB0byBleHRlbmQgZnJvbVxuXG5pZih0eXBlb2YgQmFzZUNsYXNzICE9PSAndW5kZWZpbmVkJykge1xuICAkLkJhc2VDbGFzcyA9IEJhc2VDbGFzcygkLmZuKTtcbn1cblxuLy8gRXhwb3J0IGludGVyZmFjZVxuXG5leHBvcnQgZGVmYXVsdCAkO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/index.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/noconflict.js":
/*!**************************************************!*\
  !*** ./node_modules/domtastic/src/noconflict.js ***!
  \**************************************************/
/*! exports provided: noConflict */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"noConflict\", function() { return noConflict; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./node_modules/domtastic/src/util.js\");\n/**\n * @module noConflict\n */\n\n\n\n/*\n * Save the previous value of the global `$` variable, so that it can be restored later on.\n * @private\n */\n\nconst previousLib = _util__WEBPACK_IMPORTED_MODULE_0__[\"win\"].$;\n\n/**\n * In case another library sets the global `$` variable before DOMtastic does,\n * this method can be used to return the global `$` to that other library.\n *\n * @return {Object} Reference to DOMtastic.\n * @example\n *     var domtastic = $.noConflict();\n */\n\nconst noConflict = function() {\n  _util__WEBPACK_IMPORTED_MODULE_0__[\"win\"].$ = previousLib;\n  return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9ub2NvbmZsaWN0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbXRhc3RpYy9zcmMvbm9jb25mbGljdC5qcz9jZWQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBub0NvbmZsaWN0XG4gKi9cblxuaW1wb3J0IHsgd2luIH0gZnJvbSAnLi91dGlsJztcblxuLypcbiAqIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBnbG9iYWwgYCRgIHZhcmlhYmxlLCBzbyB0aGF0IGl0IGNhbiBiZSByZXN0b3JlZCBsYXRlciBvbi5cbiAqIEBwcml2YXRlXG4gKi9cblxuY29uc3QgcHJldmlvdXNMaWIgPSB3aW4uJDtcblxuLyoqXG4gKiBJbiBjYXNlIGFub3RoZXIgbGlicmFyeSBzZXRzIHRoZSBnbG9iYWwgYCRgIHZhcmlhYmxlIGJlZm9yZSBET010YXN0aWMgZG9lcyxcbiAqIHRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIHJldHVybiB0aGUgZ2xvYmFsIGAkYCB0byB0aGF0IG90aGVyIGxpYnJhcnkuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBSZWZlcmVuY2UgdG8gRE9NdGFzdGljLlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgZG9tdGFzdGljID0gJC5ub0NvbmZsaWN0KCk7XG4gKi9cblxuZXhwb3J0IGNvbnN0IG5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgd2luLiQgPSBwcmV2aW91c0xpYjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/noconflict.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/selector/closest.js":
/*!********************************************************!*\
  !*** ./node_modules/domtastic/src/selector/closest.js ***!
  \********************************************************/
/*! exports provided: closest */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"closest\", function() { return closest; });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ \"./node_modules/domtastic/src/selector/index.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ \"./node_modules/domtastic/src/util.js\");\n/**\n * @module closest\n */\n\n\n\n\n/**\n * Return the closest element matching the selector (starting by itself) for each element in the collection.\n *\n * @param {String} selector Filter\n * @param {Object} [context] If provided, matching elements must be a descendant of this element\n * @return {Object} New wrapped collection (containing zero or one element)\n * @chainable\n * @example\n *     $('.selector').closest('.container');\n */\n\nconst closest = (() => {\n\n  const closest = function(selector, context) {\n    const nodes = [];\n    Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"each\"])(this, node => {\n      while(node && node !== context) {\n        if(Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"matches\"])(node, selector)) {\n          nodes.push(node);\n          break;\n        }\n        node = node.parentElement;\n      }\n    });\n    return Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"uniq\"])(nodes));\n  };\n\n  return typeof Element === 'undefined' || !Element.prototype.closest ? closest : function(selector, context) {\n    if(!context) {\n      const nodes = [];\n      Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"each\"])(this, node => {\n        const n = node.closest(selector);\n        if(n) {\n          nodes.push(n);\n        }\n      });\n      return Object(_index__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"uniq\"])(nodes));\n    } else {\n      return closest.call(this, selector, context);\n    }\n  };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9zZWxlY3Rvci9jbG9zZXN0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbXRhc3RpYy9zcmMvc2VsZWN0b3IvY2xvc2VzdC5qcz82NDJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBjbG9zZXN0XG4gKi9cblxuaW1wb3J0IHsgJCwgbWF0Y2hlcyB9IGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHsgZWFjaCwgdW5pcSB9IGZyb20gJy4uL3V0aWwnO1xuXG4vKipcbiAqIFJldHVybiB0aGUgY2xvc2VzdCBlbGVtZW50IG1hdGNoaW5nIHRoZSBzZWxlY3RvciAoc3RhcnRpbmcgYnkgaXRzZWxmKSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciBGaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gSWYgcHJvdmlkZWQsIG1hdGNoaW5nIGVsZW1lbnRzIG11c3QgYmUgYSBkZXNjZW5kYW50IG9mIHRoaXMgZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0fSBOZXcgd3JhcHBlZCBjb2xsZWN0aW9uIChjb250YWluaW5nIHplcm8gb3Igb25lIGVsZW1lbnQpXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5zZWxlY3RvcicpLmNsb3Nlc3QoJy5jb250YWluZXInKTtcbiAqL1xuXG5leHBvcnQgY29uc3QgY2xvc2VzdCA9ICgoKSA9PiB7XG5cbiAgY29uc3QgY2xvc2VzdCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBlYWNoKHRoaXMsIG5vZGUgPT4ge1xuICAgICAgd2hpbGUobm9kZSAmJiBub2RlICE9PSBjb250ZXh0KSB7XG4gICAgICAgIGlmKG1hdGNoZXMobm9kZSwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAkKHVuaXEobm9kZXMpKTtcbiAgfTtcblxuICByZXR1cm4gdHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICFFbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0ID8gY2xvc2VzdCA6IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgaWYoIWNvbnRleHQpIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgICBlYWNoKHRoaXMsIG5vZGUgPT4ge1xuICAgICAgICBjb25zdCBuID0gbm9kZS5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgICAgICAgaWYobikge1xuICAgICAgICAgIG5vZGVzLnB1c2gobik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICQodW5pcShub2RlcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2xvc2VzdC5jYWxsKHRoaXMsIHNlbGVjdG9yLCBjb250ZXh0KTtcbiAgICB9XG4gIH07XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/selector/closest.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/selector/extra.js":
/*!******************************************************!*\
  !*** ./node_modules/domtastic/src/selector/extra.js ***!
  \******************************************************/
/*! exports provided: children, concat, contents, eq, first, get, parent, siblings, slice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"children\", function() { return children; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"concat\", function() { return concat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"contents\", function() { return contents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"eq\", function() { return eq; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"first\", function() { return first; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get\", function() { return get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parent\", function() { return parent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"siblings\", function() { return siblings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"slice\", function() { return slice; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/domtastic/src/util.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ \"./node_modules/domtastic/src/selector/index.js\");\n/**\n * @module Selector (extra)\n */\n\n\n\n\n/**\n * Return children of each element in the collection, optionally filtered by a selector.\n *\n * @param {String} [selector] Filter\n * @return {Object} New wrapped collection\n * @chainable\n * @example\n *     $('.selector').children();\n *     $('.selector').children('.filter');\n */\n\nconst children = function(selector) {\n  const nodes = [];\n  Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => {\n    if(element.children) {\n      Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(element.children, child => {\n        if(!selector || (selector && Object(_index__WEBPACK_IMPORTED_MODULE_1__[\"matches\"])(child, selector))) {\n          nodes.push(child);\n        }\n      });\n    }\n  });\n  return Object(_index__WEBPACK_IMPORTED_MODULE_1__[\"$\"])(nodes);\n};\n\n/**\n * Add the elements of a wrapped collection to another.\n *\n * @param {String|Node|NodeList|Array} selector Query selector, `Node`, `NodeList`, array of elements, or HTML fragment string.\n * @return {Object} The extended wrapped collection\n * @example\n *     $('.items').concat($('.more-items));\n *     $('.items').concat('.more-items);\n *     $('.items').concat('<div>more</div>');\n */\n\nconst concat = function(selector) {\n  Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(Object(_index__WEBPACK_IMPORTED_MODULE_1__[\"$\"])(selector), element => {\n    if([].indexOf.call(this, element) === -1) {\n      [].push.call(this, element);\n    }\n  });\n  return this;\n};\n\n/**\n * Return child nodes of each element in the collection, including text and comment nodes.\n *\n * @return {Object} New wrapped collection\n * @example\n *     $('.selector').contents();\n */\n\nconst contents = function() {\n  const nodes = [];\n  Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => nodes.push.apply(nodes, Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(element.childNodes)));\n  return Object(_index__WEBPACK_IMPORTED_MODULE_1__[\"$\"])(nodes);\n};\n\n/**\n * Return a collection containing only the one at the specified index.\n *\n * @param {Number} index\n * @return {Object} New wrapped collection\n * @chainable\n * @example\n *     $('.items').eq(1)\n *     // The second item; result is the same as doing $($('.items')[1]);\n */\n\nconst eq = function(index) {\n  return slice.call(this, index, index + 1);\n};\n\n/**\n * Return a collection containing only the first item.\n *\n * @return {Object} New wrapped collection\n * @chainable\n * @example\n *     $('.items').first()\n *     // The first item; result is the same as doing $($('.items')[0]);\n */\n\nconst first = function() {\n  return slice.call(this, 0, 1);\n};\n\n/**\n * Return the DOM element at the specified index.\n *\n * @param {Number} index\n * @return {Node} Element at the specified index\n * @example\n *     $('.items').get(1)\n *     // The second element; result is the same as doing $('.items')[1];\n */\n\nconst get = function(index) {\n  return this[index];\n};\n\n/**\n * Return the parent elements of each element in the collection, optionally filtered by a selector.\n *\n * @param {String} [selector] Filter\n * @return {Object} New wrapped collection\n * @chainable\n * @example\n *     $('.selector').parent();\n *     $('.selector').parent('.filter');\n */\n\nconst parent = function(selector) {\n  const nodes = [];\n  Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => {\n    if(!selector || (selector && Object(_index__WEBPACK_IMPORTED_MODULE_1__[\"matches\"])(element.parentNode, selector))) {\n      nodes.push(element.parentNode);\n    }\n  });\n  return Object(_index__WEBPACK_IMPORTED_MODULE_1__[\"$\"])(nodes);\n};\n\n/**\n * Return the sibling elements of each element in the collection, optionally filtered by a selector.\n *\n * @param {String} [selector] Filter\n * @return {Object} New wrapped collection\n * @chainable\n * @example\n *     $('.selector').siblings();\n *     $('.selector').siblings('.filter');\n */\n\nconst siblings = function(selector) {\n  const nodes = [];\n  Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, element => Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(element.parentNode.children, sibling => {\n    if(sibling !== element && (!selector || (selector && Object(_index__WEBPACK_IMPORTED_MODULE_1__[\"matches\"])(sibling, selector)))) {\n      nodes.push(sibling);\n    }\n  }));\n  return Object(_index__WEBPACK_IMPORTED_MODULE_1__[\"$\"])(nodes);\n};\n\n/**\n * Create a new, sliced collection.\n *\n * @param {Number} start\n * @param {Number} end\n * @return {Object} New wrapped collection\n * @example\n *     $('.items').slice(1, 3)\n *     // New wrapped collection containing the second, third, and fourth element.\n */\n\nconst slice = function(start, end) { // eslint-disable-line no-unused-vars\n  return Object(_index__WEBPACK_IMPORTED_MODULE_1__[\"$\"])([].slice.apply(this, arguments));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9zZWxlY3Rvci9leHRyYS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb210YXN0aWMvc3JjL3NlbGVjdG9yL2V4dHJhLmpzPzYxYTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIFNlbGVjdG9yIChleHRyYSlcbiAqL1xuXG5pbXBvcnQgeyBlYWNoLCB0b0FycmF5IH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgeyAkLCBtYXRjaGVzIH0gZnJvbSAnLi9pbmRleCc7XG5cbi8qKlxuICogUmV0dXJuIGNoaWxkcmVuIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbiwgb3B0aW9uYWxseSBmaWx0ZXJlZCBieSBhIHNlbGVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3JdIEZpbHRlclxuICogQHJldHVybiB7T2JqZWN0fSBOZXcgd3JhcHBlZCBjb2xsZWN0aW9uXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5zZWxlY3RvcicpLmNoaWxkcmVuKCk7XG4gKiAgICAgJCgnLnNlbGVjdG9yJykuY2hpbGRyZW4oJy5maWx0ZXInKTtcbiAqL1xuXG5leHBvcnQgY29uc3QgY2hpbGRyZW4gPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBlYWNoKHRoaXMsIGVsZW1lbnQgPT4ge1xuICAgIGlmKGVsZW1lbnQuY2hpbGRyZW4pIHtcbiAgICAgIGVhY2goZWxlbWVudC5jaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgICBpZighc2VsZWN0b3IgfHwgKHNlbGVjdG9yICYmIG1hdGNoZXMoY2hpbGQsIHNlbGVjdG9yKSkpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuICQobm9kZXMpO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGVsZW1lbnRzIG9mIGEgd3JhcHBlZCBjb2xsZWN0aW9uIHRvIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8Tm9kZXxOb2RlTGlzdHxBcnJheX0gc2VsZWN0b3IgUXVlcnkgc2VsZWN0b3IsIGBOb2RlYCwgYE5vZGVMaXN0YCwgYXJyYXkgb2YgZWxlbWVudHMsIG9yIEhUTUwgZnJhZ21lbnQgc3RyaW5nLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZXh0ZW5kZWQgd3JhcHBlZCBjb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5pdGVtcycpLmNvbmNhdCgkKCcubW9yZS1pdGVtcykpO1xuICogICAgICQoJy5pdGVtcycpLmNvbmNhdCgnLm1vcmUtaXRlbXMpO1xuICogICAgICQoJy5pdGVtcycpLmNvbmNhdCgnPGRpdj5tb3JlPC9kaXY+Jyk7XG4gKi9cblxuZXhwb3J0IGNvbnN0IGNvbmNhdCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIGVhY2goJChzZWxlY3RvciksIGVsZW1lbnQgPT4ge1xuICAgIGlmKFtdLmluZGV4T2YuY2FsbCh0aGlzLCBlbGVtZW50KSA9PT0gLTEpIHtcbiAgICAgIFtdLnB1c2guY2FsbCh0aGlzLCBlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGNoaWxkIG5vZGVzIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbiwgaW5jbHVkaW5nIHRleHQgYW5kIGNvbW1lbnQgbm9kZXMuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBOZXcgd3JhcHBlZCBjb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5zZWxlY3RvcicpLmNvbnRlbnRzKCk7XG4gKi9cblxuZXhwb3J0IGNvbnN0IGNvbnRlbnRzID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGVhY2godGhpcywgZWxlbWVudCA9PiBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCB0b0FycmF5KGVsZW1lbnQuY2hpbGROb2RlcykpKTtcbiAgcmV0dXJuICQobm9kZXMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBjb2xsZWN0aW9uIGNvbnRhaW5pbmcgb25seSB0aGUgb25lIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJuIHtPYmplY3R9IE5ldyB3cmFwcGVkIGNvbGxlY3Rpb25cbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKiAgICAgJCgnLml0ZW1zJykuZXEoMSlcbiAqICAgICAvLyBUaGUgc2Vjb25kIGl0ZW07IHJlc3VsdCBpcyB0aGUgc2FtZSBhcyBkb2luZyAkKCQoJy5pdGVtcycpWzFdKTtcbiAqL1xuXG5leHBvcnQgY29uc3QgZXEgPSBmdW5jdGlvbihpbmRleCkge1xuICByZXR1cm4gc2xpY2UuY2FsbCh0aGlzLCBpbmRleCwgaW5kZXggKyAxKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgY29sbGVjdGlvbiBjb250YWluaW5nIG9ubHkgdGhlIGZpcnN0IGl0ZW0uXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBOZXcgd3JhcHBlZCBjb2xsZWN0aW9uXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5pdGVtcycpLmZpcnN0KClcbiAqICAgICAvLyBUaGUgZmlyc3QgaXRlbTsgcmVzdWx0IGlzIHRoZSBzYW1lIGFzIGRvaW5nICQoJCgnLml0ZW1zJylbMF0pO1xuICovXG5cbmV4cG9ydCBjb25zdCBmaXJzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gc2xpY2UuY2FsbCh0aGlzLCAwLCAxKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBET00gZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7Tm9kZX0gRWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5pdGVtcycpLmdldCgxKVxuICogICAgIC8vIFRoZSBzZWNvbmQgZWxlbWVudDsgcmVzdWx0IGlzIHRoZSBzYW1lIGFzIGRvaW5nICQoJy5pdGVtcycpWzFdO1xuICovXG5cbmV4cG9ydCBjb25zdCBnZXQgPSBmdW5jdGlvbihpbmRleCkge1xuICByZXR1cm4gdGhpc1tpbmRleF07XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGVsZW1lbnRzIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbiwgb3B0aW9uYWxseSBmaWx0ZXJlZCBieSBhIHNlbGVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3JdIEZpbHRlclxuICogQHJldHVybiB7T2JqZWN0fSBOZXcgd3JhcHBlZCBjb2xsZWN0aW9uXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICogICAgICQoJy5zZWxlY3RvcicpLnBhcmVudCgpO1xuICogICAgICQoJy5zZWxlY3RvcicpLnBhcmVudCgnLmZpbHRlcicpO1xuICovXG5cbmV4cG9ydCBjb25zdCBwYXJlbnQgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBlYWNoKHRoaXMsIGVsZW1lbnQgPT4ge1xuICAgIGlmKCFzZWxlY3RvciB8fCAoc2VsZWN0b3IgJiYgbWF0Y2hlcyhlbGVtZW50LnBhcmVudE5vZGUsIHNlbGVjdG9yKSkpIHtcbiAgICAgIG5vZGVzLnB1c2goZWxlbWVudC5wYXJlbnROb2RlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gJChub2Rlcyk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgc2libGluZyBlbGVtZW50cyBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb24sIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgYSBzZWxlY3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3NlbGVjdG9yXSBGaWx0ZXJcbiAqIEByZXR1cm4ge09iamVjdH0gTmV3IHdyYXBwZWQgY29sbGVjdGlvblxuICogQGNoYWluYWJsZVxuICogQGV4YW1wbGVcbiAqICAgICAkKCcuc2VsZWN0b3InKS5zaWJsaW5ncygpO1xuICogICAgICQoJy5zZWxlY3RvcicpLnNpYmxpbmdzKCcuZmlsdGVyJyk7XG4gKi9cblxuZXhwb3J0IGNvbnN0IHNpYmxpbmdzID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgZWFjaCh0aGlzLCBlbGVtZW50ID0+IGVhY2goZWxlbWVudC5wYXJlbnROb2RlLmNoaWxkcmVuLCBzaWJsaW5nID0+IHtcbiAgICBpZihzaWJsaW5nICE9PSBlbGVtZW50ICYmICghc2VsZWN0b3IgfHwgKHNlbGVjdG9yICYmIG1hdGNoZXMoc2libGluZywgc2VsZWN0b3IpKSkpIHtcbiAgICAgIG5vZGVzLnB1c2goc2libGluZyk7XG4gICAgfVxuICB9KSk7XG4gIHJldHVybiAkKG5vZGVzKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3LCBzbGljZWQgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBlbmRcbiAqIEByZXR1cm4ge09iamVjdH0gTmV3IHdyYXBwZWQgY29sbGVjdGlvblxuICogQGV4YW1wbGVcbiAqICAgICAkKCcuaXRlbXMnKS5zbGljZSgxLCAzKVxuICogICAgIC8vIE5ldyB3cmFwcGVkIGNvbGxlY3Rpb24gY29udGFpbmluZyB0aGUgc2Vjb25kLCB0aGlyZCwgYW5kIGZvdXJ0aCBlbGVtZW50LlxuICovXG5cbmV4cG9ydCBjb25zdCBzbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJChbXS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/selector/extra.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/selector/index.js":
/*!******************************************************!*\
  !*** ./node_modules/domtastic/src/selector/index.js ***!
  \******************************************************/
/*! exports provided: $, find, matches, DOMtastic */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"$\", function() { return $; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"find\", function() { return find; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"matches\", function() { return matches; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DOMtastic\", function() { return DOMtastic; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/domtastic/src/util.js\");\n/**\n * @module Selector\n */\n\n\n\nlet isPrototypeSet = false;\n\nconst reFragment = /^\\s*<(\\w+|!)[^>]*>/;\nconst reSingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/;\nconst reSimpleSelector = /^[.#]?[\\w-]*$/;\n\n/*\n * Versatile wrapper for `querySelectorAll`.\n *\n * @param {String|Node|NodeList|Array} selector Query selector, `Node`, `NodeList`, array of elements, or HTML fragment string.\n * @param {String|Node|NodeList} context=document The context for the selector to query elements.\n * @return {Object} The wrapped collection\n * @chainable\n * @example\n *     var $items = $(.items');\n * @example\n *     var $element = $(domElement);\n * @example\n *     var $list = $(nodeList, document.body);\n * @example\n *     var $element = $('<p>evergreen</p>');\n */\n\nconst domtastic = function domtastic(selector, context = document) {\n\n  let collection;\n\n  if(!selector) {\n\n    collection = document.querySelectorAll(null);\n\n  } else if(selector instanceof DOMtastic) {\n\n    return selector;\n\n  } else if(typeof selector !== 'string') {\n\n    collection = selector.nodeType || selector === window ? [selector] : selector;\n\n  } else if(reFragment.test(selector)) {\n\n    collection = createFragment(selector);\n\n  } else {\n\n    context = typeof context === 'string' ? document.querySelector(context) : context.length ? context[0] : context;\n\n    collection = querySelector(selector, context);\n\n  }\n\n  return wrap(collection);\n\n};\n\nconst $ = domtastic;\n\n/*\n * Find descendants matching the provided `selector` for each element in the collection.\n *\n * @param {String|Node|NodeList|Array} selector Query selector, `Node`, `NodeList`, array of elements, or HTML fragment string.\n * @return {Object} The wrapped collection\n * @example\n *     $('.selector').find('.deep').$('.deepest');\n */\n\nconst find = function(selector) {\n  const nodes = [];\n  Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this, node => Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(querySelector(selector, node), child => {\n    if(nodes.indexOf(child) === -1) {\n      nodes.push(child);\n    }\n  }));\n  return $(nodes);\n};\n\n/*\n * Returns `true` if the element would be selected by the specified selector string; otherwise, returns `false`.\n *\n * @param {Node} element Element to test\n * @param {String} selector Selector to match against element\n * @return {Boolean}\n *\n * @example\n *     $.matches(element, '.match');\n */\n\nconst matches = (() => {\n  const context = typeof Element !== 'undefined' ? Element.prototype : _util__WEBPACK_IMPORTED_MODULE_0__[\"win\"];\n  const _matches = context.matches || context.matchesSelector || context.mozMatchesSelector || context.msMatchesSelector || context.oMatchesSelector || context.webkitMatchesSelector;\n  return (element, selector) => _matches.call(element, selector);\n})();\n\n/*\n * Use the faster `getElementById`, `getElementsByClassName` or `getElementsByTagName` over `querySelectorAll` if possible.\n *\n * @private\n * @param {String} selector Query selector.\n * @param {Node} context The context for the selector to query elements.\n * @return {Object} NodeList, HTMLCollection, or Array of matching elements (depending on method used).\n */\n\nconst querySelector = (selector, context) => {\n\n  const isSimpleSelector = reSimpleSelector.test(selector);\n\n  if(isSimpleSelector) {\n    if(selector[0] === '#') {\n      const element = (context.getElementById ? context : document).getElementById(selector.slice(1));\n      return element ? [element] : [];\n    }\n    if(selector[0] === '.') {\n      return context.getElementsByClassName(selector.slice(1));\n    }\n    return context.getElementsByTagName(selector);\n  }\n\n  return context.querySelectorAll(selector);\n\n};\n\n/*\n * Create DOM fragment from an HTML string\n *\n * @private\n * @param {String} html String representing HTML.\n * @return {NodeList}\n */\n\nconst createFragment = html => {\n\n  if(reSingleTag.test(html)) {\n    return [document.createElement(RegExp.$1)];\n  }\n\n  const elements = [];\n  const container = document.createElement('div');\n  const children = container.childNodes;\n\n  container.innerHTML = html;\n\n  for(let i = 0, l = children.length; i < l; i++) {\n    elements.push(children[i]);\n  }\n\n  return elements;\n};\n\n/*\n * Calling `$(selector)` returns a wrapped collection of elements.\n *\n * @private\n * @param {NodeList|Array} collection Element(s) to wrap.\n * @return Object) The wrapped collection\n */\n\nconst wrap = collection => {\n\n  if(!isPrototypeSet) {\n    DOMtastic.prototype = $.fn;\n    DOMtastic.prototype.constructor = DOMtastic;\n    isPrototypeSet = true;\n  }\n\n  return new DOMtastic(collection);\n};\n\n/*\n * Constructor for the Object.prototype strategy\n *\n * @constructor\n * @private\n * @param {NodeList|Array} collection Element(s) to wrap.\n */\n\nconst DOMtastic = function DOMtastic(collection) {\n  let i = 0;\n  const length = collection.length;\n  for(; i < length;) {\n    this[i] = collection[i++];\n  }\n  this.length = length;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy9zZWxlY3Rvci9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb210YXN0aWMvc3JjL3NlbGVjdG9yL2luZGV4LmpzPzk4ZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIFNlbGVjdG9yXG4gKi9cblxuaW1wb3J0IHsgd2luLCBlYWNoIH0gZnJvbSAnLi4vdXRpbCc7XG5cbmxldCBpc1Byb3RvdHlwZVNldCA9IGZhbHNlO1xuXG5jb25zdCByZUZyYWdtZW50ID0gL15cXHMqPChcXHcrfCEpW14+XSo+LztcbmNvbnN0IHJlU2luZ2xlVGFnID0gL148KFxcdyspXFxzKlxcLz8+KD86PFxcL1xcMT58KSQvO1xuY29uc3QgcmVTaW1wbGVTZWxlY3RvciA9IC9eWy4jXT9bXFx3LV0qJC87XG5cbi8qXG4gKiBWZXJzYXRpbGUgd3JhcHBlciBmb3IgYHF1ZXJ5U2VsZWN0b3JBbGxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE5vZGV8Tm9kZUxpc3R8QXJyYXl9IHNlbGVjdG9yIFF1ZXJ5IHNlbGVjdG9yLCBgTm9kZWAsIGBOb2RlTGlzdGAsIGFycmF5IG9mIGVsZW1lbnRzLCBvciBIVE1MIGZyYWdtZW50IHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfE5vZGV8Tm9kZUxpc3R9IGNvbnRleHQ9ZG9jdW1lbnQgVGhlIGNvbnRleHQgZm9yIHRoZSBzZWxlY3RvciB0byBxdWVyeSBlbGVtZW50cy5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHdyYXBwZWQgY29sbGVjdGlvblxuICogQGNoYWluYWJsZVxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgJGl0ZW1zID0gJCguaXRlbXMnKTtcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyICRlbGVtZW50ID0gJChkb21FbGVtZW50KTtcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyICRsaXN0ID0gJChub2RlTGlzdCwgZG9jdW1lbnQuYm9keSk7XG4gKiBAZXhhbXBsZVxuICogICAgIHZhciAkZWxlbWVudCA9ICQoJzxwPmV2ZXJncmVlbjwvcD4nKTtcbiAqL1xuXG5jb25zdCBkb210YXN0aWMgPSBmdW5jdGlvbiBkb210YXN0aWMoc2VsZWN0b3IsIGNvbnRleHQgPSBkb2N1bWVudCkge1xuXG4gIGxldCBjb2xsZWN0aW9uO1xuXG4gIGlmKCFzZWxlY3Rvcikge1xuXG4gICAgY29sbGVjdGlvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwobnVsbCk7XG5cbiAgfSBlbHNlIGlmKHNlbGVjdG9yIGluc3RhbmNlb2YgRE9NdGFzdGljKSB7XG5cbiAgICByZXR1cm4gc2VsZWN0b3I7XG5cbiAgfSBlbHNlIGlmKHR5cGVvZiBzZWxlY3RvciAhPT0gJ3N0cmluZycpIHtcblxuICAgIGNvbGxlY3Rpb24gPSBzZWxlY3Rvci5ub2RlVHlwZSB8fCBzZWxlY3RvciA9PT0gd2luZG93ID8gW3NlbGVjdG9yXSA6IHNlbGVjdG9yO1xuXG4gIH0gZWxzZSBpZihyZUZyYWdtZW50LnRlc3Qoc2VsZWN0b3IpKSB7XG5cbiAgICBjb2xsZWN0aW9uID0gY3JlYXRlRnJhZ21lbnQoc2VsZWN0b3IpO1xuXG4gIH0gZWxzZSB7XG5cbiAgICBjb250ZXh0ID0gdHlwZW9mIGNvbnRleHQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250ZXh0KSA6IGNvbnRleHQubGVuZ3RoID8gY29udGV4dFswXSA6IGNvbnRleHQ7XG5cbiAgICBjb2xsZWN0aW9uID0gcXVlcnlTZWxlY3RvcihzZWxlY3RvciwgY29udGV4dCk7XG5cbiAgfVxuXG4gIHJldHVybiB3cmFwKGNvbGxlY3Rpb24pO1xuXG59O1xuXG5leHBvcnQgY29uc3QgJCA9IGRvbXRhc3RpYztcblxuLypcbiAqIEZpbmQgZGVzY2VuZGFudHMgbWF0Y2hpbmcgdGhlIHByb3ZpZGVkIGBzZWxlY3RvcmAgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOb2RlfE5vZGVMaXN0fEFycmF5fSBzZWxlY3RvciBRdWVyeSBzZWxlY3RvciwgYE5vZGVgLCBgTm9kZUxpc3RgLCBhcnJheSBvZiBlbGVtZW50cywgb3IgSFRNTCBmcmFnbWVudCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB3cmFwcGVkIGNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiAgICAgJCgnLnNlbGVjdG9yJykuZmluZCgnLmRlZXAnKS4kKCcuZGVlcGVzdCcpO1xuICovXG5cbmV4cG9ydCBjb25zdCBmaW5kID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgZWFjaCh0aGlzLCBub2RlID0+IGVhY2gocXVlcnlTZWxlY3RvcihzZWxlY3Rvciwgbm9kZSksIGNoaWxkID0+IHtcbiAgICBpZihub2Rlcy5pbmRleE9mKGNoaWxkKSA9PT0gLTEpIHtcbiAgICAgIG5vZGVzLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfSkpO1xuICByZXR1cm4gJChub2Rlcyk7XG59O1xuXG4vKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQgd291bGQgYmUgc2VsZWN0ZWQgYnkgdGhlIHNwZWNpZmllZCBzZWxlY3RvciBzdHJpbmc7IG90aGVyd2lzZSwgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gZWxlbWVudCBFbGVtZW50IHRvIHRlc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byBtYXRjaCBhZ2FpbnN0IGVsZW1lbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAkLm1hdGNoZXMoZWxlbWVudCwgJy5tYXRjaCcpO1xuICovXG5cbmV4cG9ydCBjb25zdCBtYXRjaGVzID0gKCgpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJyA/IEVsZW1lbnQucHJvdG90eXBlIDogd2luO1xuICBjb25zdCBfbWF0Y2hlcyA9IGNvbnRleHQubWF0Y2hlcyB8fCBjb250ZXh0Lm1hdGNoZXNTZWxlY3RvciB8fCBjb250ZXh0Lm1vek1hdGNoZXNTZWxlY3RvciB8fCBjb250ZXh0Lm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGNvbnRleHQub01hdGNoZXNTZWxlY3RvciB8fCBjb250ZXh0LndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcbiAgcmV0dXJuIChlbGVtZW50LCBzZWxlY3RvcikgPT4gX21hdGNoZXMuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG59KSgpO1xuXG4vKlxuICogVXNlIHRoZSBmYXN0ZXIgYGdldEVsZW1lbnRCeUlkYCwgYGdldEVsZW1lbnRzQnlDbGFzc05hbWVgIG9yIGBnZXRFbGVtZW50c0J5VGFnTmFtZWAgb3ZlciBgcXVlcnlTZWxlY3RvckFsbGAgaWYgcG9zc2libGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciBRdWVyeSBzZWxlY3Rvci5cbiAqIEBwYXJhbSB7Tm9kZX0gY29udGV4dCBUaGUgY29udGV4dCBmb3IgdGhlIHNlbGVjdG9yIHRvIHF1ZXJ5IGVsZW1lbnRzLlxuICogQHJldHVybiB7T2JqZWN0fSBOb2RlTGlzdCwgSFRNTENvbGxlY3Rpb24sIG9yIEFycmF5IG9mIG1hdGNoaW5nIGVsZW1lbnRzIChkZXBlbmRpbmcgb24gbWV0aG9kIHVzZWQpLlxuICovXG5cbmNvbnN0IHF1ZXJ5U2VsZWN0b3IgPSAoc2VsZWN0b3IsIGNvbnRleHQpID0+IHtcblxuICBjb25zdCBpc1NpbXBsZVNlbGVjdG9yID0gcmVTaW1wbGVTZWxlY3Rvci50ZXN0KHNlbGVjdG9yKTtcblxuICBpZihpc1NpbXBsZVNlbGVjdG9yKSB7XG4gICAgaWYoc2VsZWN0b3JbMF0gPT09ICcjJykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IChjb250ZXh0LmdldEVsZW1lbnRCeUlkID8gY29udGV4dCA6IGRvY3VtZW50KS5nZXRFbGVtZW50QnlJZChzZWxlY3Rvci5zbGljZSgxKSk7XG4gICAgICByZXR1cm4gZWxlbWVudCA/IFtlbGVtZW50XSA6IFtdO1xuICAgIH1cbiAgICBpZihzZWxlY3RvclswXSA9PT0gJy4nKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHNlbGVjdG9yLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoc2VsZWN0b3IpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cbn07XG5cbi8qXG4gKiBDcmVhdGUgRE9NIGZyYWdtZW50IGZyb20gYW4gSFRNTCBzdHJpbmdcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWwgU3RyaW5nIHJlcHJlc2VudGluZyBIVE1MLlxuICogQHJldHVybiB7Tm9kZUxpc3R9XG4gKi9cblxuY29uc3QgY3JlYXRlRnJhZ21lbnQgPSBodG1sID0+IHtcblxuICBpZihyZVNpbmdsZVRhZy50ZXN0KGh0bWwpKSB7XG4gICAgcmV0dXJuIFtkb2N1bWVudC5jcmVhdGVFbGVtZW50KFJlZ0V4cC4kMSldO1xuICB9XG5cbiAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnN0IGNoaWxkcmVuID0gY29udGFpbmVyLmNoaWxkTm9kZXM7XG5cbiAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgZm9yKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGVsZW1lbnRzLnB1c2goY2hpbGRyZW5baV0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRzO1xufTtcblxuLypcbiAqIENhbGxpbmcgYCQoc2VsZWN0b3IpYCByZXR1cm5zIGEgd3JhcHBlZCBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge05vZGVMaXN0fEFycmF5fSBjb2xsZWN0aW9uIEVsZW1lbnQocykgdG8gd3JhcC5cbiAqIEByZXR1cm4gT2JqZWN0KSBUaGUgd3JhcHBlZCBjb2xsZWN0aW9uXG4gKi9cblxuY29uc3Qgd3JhcCA9IGNvbGxlY3Rpb24gPT4ge1xuXG4gIGlmKCFpc1Byb3RvdHlwZVNldCkge1xuICAgIERPTXRhc3RpYy5wcm90b3R5cGUgPSAkLmZuO1xuICAgIERPTXRhc3RpYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBET010YXN0aWM7XG4gICAgaXNQcm90b3R5cGVTZXQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBET010YXN0aWMoY29sbGVjdGlvbik7XG59O1xuXG4vKlxuICogQ29uc3RydWN0b3IgZm9yIHRoZSBPYmplY3QucHJvdG90eXBlIHN0cmF0ZWd5XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOb2RlTGlzdHxBcnJheX0gY29sbGVjdGlvbiBFbGVtZW50KHMpIHRvIHdyYXAuXG4gKi9cblxuZXhwb3J0IGNvbnN0IERPTXRhc3RpYyA9IGZ1bmN0aW9uIERPTXRhc3RpYyhjb2xsZWN0aW9uKSB7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gIGZvcig7IGkgPCBsZW5ndGg7KSB7XG4gICAgdGhpc1tpXSA9IGNvbGxlY3Rpb25baSsrXTtcbiAgfVxuICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/selector/index.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/type.js":
/*!********************************************!*\
  !*** ./node_modules/domtastic/src/type.js ***!
  \********************************************/
/*! exports provided: isFunction, isArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isFunction\", function() { return isFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isArray\", function() { return isArray; });\n/**\n * @module Type\n */\n\n/*\n * Determine if the argument passed is a Javascript function object.\n *\n * @param {Object} [obj] Object to test whether or not it is a function.\n * @return {boolean}\n * @example\n *     $.isFunction(function(){}); // true\n * @example\n *     $.isFunction({}); // false\n */\n\nconst isFunction = obj => typeof obj === 'function';\n\n/*\n * Determine whether the argument is an array.\n *\n * @param {Object} [obj] Object to test whether or not it is an array.\n * @return {boolean}\n * @example\n *     $.isArray([]); // true\n * @example\n *     $.isArray({}); // false\n */\n\nconst isArray = Array.isArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy90eXBlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbXRhc3RpYy9zcmMvdHlwZS5qcz9jZjNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBUeXBlXG4gKi9cblxuLypcbiAqIERldGVybWluZSBpZiB0aGUgYXJndW1lbnQgcGFzc2VkIGlzIGEgSmF2YXNjcmlwdCBmdW5jdGlvbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmpdIE9iamVjdCB0byB0ZXN0IHdoZXRoZXIgb3Igbm90IGl0IGlzIGEgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogQGV4YW1wbGVcbiAqICAgICAkLmlzRnVuY3Rpb24oZnVuY3Rpb24oKXt9KTsgLy8gdHJ1ZVxuICogQGV4YW1wbGVcbiAqICAgICAkLmlzRnVuY3Rpb24oe30pOyAvLyBmYWxzZVxuICovXG5cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gb2JqID0+IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG5cbi8qXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmpdIE9iamVjdCB0byB0ZXN0IHdoZXRoZXIgb3Igbm90IGl0IGlzIGFuIGFycmF5LlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqIEBleGFtcGxlXG4gKiAgICAgJC5pc0FycmF5KFtdKTsgLy8gdHJ1ZVxuICogQGV4YW1wbGVcbiAqICAgICAkLmlzQXJyYXkoe30pOyAvLyBmYWxzZVxuICovXG5cbmV4cG9ydCBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/type.js\n");

/***/ }),

/***/ "./node_modules/domtastic/src/util.js":
/*!********************************************!*\
  !*** ./node_modules/domtastic/src/util.js ***!
  \********************************************/
/*! exports provided: win, toArray, each, extend, uniq */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"win\", function() { return win; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toArray\", function() { return toArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"each\", function() { return each; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extend\", function() { return extend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uniq\", function() { return uniq; });\n/*\n * @module Util\n */\n\n/*\n * Reference to the window object\n * @private\n */\n\nconst win = typeof window !== 'undefined' ? window : {};\n\n/**\n * Convert `NodeList` to `Array`.\n *\n * @param {NodeList|Array} collection\n * @return {Array}\n * @private\n */\n\nconst toArray = collection => {\n  const length = collection.length;\n  const result = new Array(length);\n  for(let i = 0; i < length; i++) {\n    result[i] = collection[i];\n  }\n  return result;\n};\n\n/**\n * Faster alternative to [].forEach method\n *\n * @param {Node|NodeList|Array} collection\n * @param {Function} callback\n * @return {Node|NodeList|Array}\n * @private\n */\n\nconst each = (collection, callback, thisArg) => {\n  const length = collection.length;\n  if(length !== undefined && collection.nodeType === undefined) {\n    for(let i = 0; i < length; i++) {\n      callback.call(thisArg, collection[i], i, collection);\n    }\n  } else {\n    callback.call(thisArg, collection, 0, collection);\n  }\n  return collection;\n};\n\n/**\n * Assign enumerable properties from source object(s) to target object\n *\n * @method extend\n * @param {Object} target Object to extend\n * @param {Object} [source] Object to extend from\n * @return {Object} Extended object\n * @example\n *     $.extend({a: 1}, {b: 2}); // {a: 1, b: 2}\n * @example\n *     $.extend({a: 1}, {b: 2}, {a: 3}); // {a: 3, b: 2}\n */\n\nconst extend = (target, ...sources) => {\n  sources.forEach(src => {\n    for(let prop in src) {\n      target[prop] = src[prop];\n    }\n  });\n  return target;\n};\n\n/**\n * Return the collection without duplicates\n *\n * @param collection Collection to remove duplicates from\n * @return {Node|NodeList|Array}\n * @private\n */\n\nconst uniq = collection => collection.filter((item, index) => collection.indexOf(item) === index);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tdGFzdGljL3NyYy91dGlsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbXRhc3RpYy9zcmMvdXRpbC5qcz8yNDk1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBAbW9kdWxlIFV0aWxcbiAqL1xuXG4vKlxuICogUmVmZXJlbmNlIHRvIHRoZSB3aW5kb3cgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBjb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9O1xuXG4vKipcbiAqIENvbnZlcnQgYE5vZGVMaXN0YCB0byBgQXJyYXlgLlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgY29uc3QgdG9BcnJheSA9IGNvbGxlY3Rpb24gPT4ge1xuICBjb25zdCBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvcihsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IGNvbGxlY3Rpb25baV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRmFzdGVyIGFsdGVybmF0aXZlIHRvIFtdLmZvckVhY2ggbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOb2RlfE5vZGVMaXN0fEFycmF5fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7Tm9kZXxOb2RlTGlzdHxBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGNvbnN0IGVhY2ggPSAoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpID0+IHtcbiAgY29uc3QgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gIGlmKGxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIGNvbGxlY3Rpb24ubm9kZVR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBjb2xsZWN0aW9uW2ldLCBpLCBjb2xsZWN0aW9uKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBjb2xsZWN0aW9uLCAwLCBjb2xsZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gY29sbGVjdGlvbjtcbn07XG5cbi8qKlxuICogQXNzaWduIGVudW1lcmFibGUgcHJvcGVydGllcyBmcm9tIHNvdXJjZSBvYmplY3QocykgdG8gdGFyZ2V0IG9iamVjdFxuICpcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IE9iamVjdCB0byBleHRlbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc291cmNlXSBPYmplY3QgdG8gZXh0ZW5kIGZyb21cbiAqIEByZXR1cm4ge09iamVjdH0gRXh0ZW5kZWQgb2JqZWN0XG4gKiBAZXhhbXBsZVxuICogICAgICQuZXh0ZW5kKHthOiAxfSwge2I6IDJ9KTsgLy8ge2E6IDEsIGI6IDJ9XG4gKiBAZXhhbXBsZVxuICogICAgICQuZXh0ZW5kKHthOiAxfSwge2I6IDJ9LCB7YTogM30pOyAvLyB7YTogMywgYjogMn1cbiAqL1xuXG5leHBvcnQgY29uc3QgZXh0ZW5kID0gKHRhcmdldCwgLi4uc291cmNlcykgPT4ge1xuICBzb3VyY2VzLmZvckVhY2goc3JjID0+IHtcbiAgICBmb3IobGV0IHByb3AgaW4gc3JjKSB7XG4gICAgICB0YXJnZXRbcHJvcF0gPSBzcmNbcHJvcF07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBjb2xsZWN0aW9uIHdpdGhvdXQgZHVwbGljYXRlc1xuICpcbiAqIEBwYXJhbSBjb2xsZWN0aW9uIENvbGxlY3Rpb24gdG8gcmVtb3ZlIGR1cGxpY2F0ZXMgZnJvbVxuICogQHJldHVybiB7Tm9kZXxOb2RlTGlzdHxBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGNvbnN0IHVuaXEgPSBjb2xsZWN0aW9uID0+IGNvbGxlY3Rpb24uZmlsdGVyKChpdGVtLCBpbmRleCkgPT4gY29sbGVjdGlvbi5pbmRleE9mKGl0ZW0pID09PSBpbmRleCk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/domtastic/src/util.js\n");

/***/ }),

/***/ "./node_modules/smoothscroll/smoothscroll.js":
/*!***************************************************!*\
  !*** ./node_modules/smoothscroll/smoothscroll.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, smoothScroll) {\n  'use strict';\n\n  // Support RequireJS and CommonJS/NodeJS module formats.\n  // Attach smoothScroll to the `window` when executed as a <script>.\n\n  // RequireJS\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (smoothScroll),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n  // CommonJS\n  } else {}\n\n})(this, function(){\n'use strict';\n\n// Do not initialize smoothScroll when running server side, handle it in client:\nif (typeof window !== 'object') return;\n\n// We do not want this script to be applied in browsers that do not support those\n// That means no smoothscroll on IE9 and below.\nif(document.querySelectorAll === void 0 || window.pageYOffset === void 0 || history.pushState === void 0) { return; }\n\n// Get the top position of an element in the document\nvar getTop = function(element, start) {\n    // return value of html.getBoundingClientRect().top ... IE : 0, other browsers : -pageYOffset\n    if(element.nodeName === 'HTML') return -start\n    return element.getBoundingClientRect().top + start\n}\n// ease in out function thanks to:\n// http://blog.greweb.fr/2012/02/bezier-curve-based-easing-functions-from-concept-to-implementation/\nvar easeInOutCubic = function (t) { return t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1 }\n\n// calculate the scroll position we should be in\n// given the start and end point of the scroll\n// the time elapsed from the beginning of the scroll\n// and the total duration of the scroll (default 500ms)\nvar position = function(start, end, elapsed, duration) {\n    if (elapsed > duration) return end;\n    return start + (end - start) * easeInOutCubic(elapsed / duration); // <-- you can change the easing funtion there\n    // return start + (end - start) * (elapsed / duration); // <-- this would give a linear scroll\n}\n\n// we use requestAnimationFrame to be called by the browser before every repaint\n// if the first argument is an element then scroll to the top of this element\n// if the first argument is numeric then scroll to this location\n// if the callback exist, it is called when the scrolling is finished\n// if context is set then scroll that element, else scroll window\nvar smoothScroll = function(el, duration, callback, context){\n    duration = duration || 500;\n    context = context || window;\n    var start = context.scrollTop || window.pageYOffset;\n\n    if (typeof el === 'number') {\n      var end = parseInt(el);\n    } else {\n      var end = getTop(el, start);\n    }\n\n    var clock = Date.now();\n    var requestAnimationFrame = window.requestAnimationFrame ||\n        window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame ||\n        function(fn){window.setTimeout(fn, 15);};\n\n    var step = function(){\n        var elapsed = Date.now() - clock;\n        if (context !== window) {\n          context.scrollTop = position(start, end, elapsed, duration);\n        }\n        else {\n          window.scroll(0, position(start, end, elapsed, duration));\n        }\n\n        if (elapsed > duration) {\n            if (typeof callback === 'function') {\n                callback(el);\n            }\n        } else {\n            requestAnimationFrame(step);\n        }\n    }\n    step();\n}\n\nvar linkHandler = function(ev) {\n    if (!ev.defaultPrevented) {\n        ev.preventDefault();\n\n        if (location.hash !== this.hash) window.history.pushState(null, null, this.hash)\n        // using the history api to solve issue #1 - back doesn't work\n        // most browser don't update :target when the history api is used:\n        // THIS IS A BUG FROM THE BROWSERS.\n        // change the scrolling duration in this call\n        var node = document.getElementById(this.hash.substring(1))\n        if (!node) return; // Do not scroll to non-existing node\n\n        smoothScroll(node, 500, function (el) {\n            location.replace('#' + el.id)\n            // this will cause the :target to be activated.\n        });\n    }\n}\n\n// We look for all the internal links in the documents and attach the smoothscroll function\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    var internal = document.querySelectorAll('a[href^=\"#\"]:not([href=\"#\"])'), a;\n    for(var i=internal.length; a=internal[--i];){\n        a.addEventListener(\"click\", linkHandler, false);\n    }\n});\n\n// return smoothscroll API\nreturn smoothScroll;\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc21vb3Roc2Nyb2xsL3Ntb290aHNjcm9sbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zbW9vdGhzY3JvbGwvc21vb3Roc2Nyb2xsLmpzPzc0NzEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChyb290LCBzbW9vdGhTY3JvbGwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFN1cHBvcnQgUmVxdWlyZUpTIGFuZCBDb21tb25KUy9Ob2RlSlMgbW9kdWxlIGZvcm1hdHMuXG4gIC8vIEF0dGFjaCBzbW9vdGhTY3JvbGwgdG8gdGhlIGB3aW5kb3dgIHdoZW4gZXhlY3V0ZWQgYXMgYSA8c2NyaXB0Pi5cblxuICAvLyBSZXF1aXJlSlNcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShzbW9vdGhTY3JvbGwpO1xuXG4gIC8vIENvbW1vbkpTXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzbW9vdGhTY3JvbGwoKTtcblxuICB9IGVsc2Uge1xuICAgIHJvb3Quc21vb3RoU2Nyb2xsID0gc21vb3RoU2Nyb2xsKCk7XG4gIH1cblxufSkodGhpcywgZnVuY3Rpb24oKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gRG8gbm90IGluaXRpYWxpemUgc21vb3RoU2Nyb2xsIHdoZW4gcnVubmluZyBzZXJ2ZXIgc2lkZSwgaGFuZGxlIGl0IGluIGNsaWVudDpcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JykgcmV0dXJuO1xuXG4vLyBXZSBkbyBub3Qgd2FudCB0aGlzIHNjcmlwdCB0byBiZSBhcHBsaWVkIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgdGhvc2Vcbi8vIFRoYXQgbWVhbnMgbm8gc21vb3Roc2Nyb2xsIG9uIElFOSBhbmQgYmVsb3cuXG5pZihkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsID09PSB2b2lkIDAgfHwgd2luZG93LnBhZ2VZT2Zmc2V0ID09PSB2b2lkIDAgfHwgaGlzdG9yeS5wdXNoU3RhdGUgPT09IHZvaWQgMCkgeyByZXR1cm47IH1cblxuLy8gR2V0IHRoZSB0b3AgcG9zaXRpb24gb2YgYW4gZWxlbWVudCBpbiB0aGUgZG9jdW1lbnRcbnZhciBnZXRUb3AgPSBmdW5jdGlvbihlbGVtZW50LCBzdGFydCkge1xuICAgIC8vIHJldHVybiB2YWx1ZSBvZiBodG1sLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAuLi4gSUUgOiAwLCBvdGhlciBicm93c2VycyA6IC1wYWdlWU9mZnNldFxuICAgIGlmKGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJykgcmV0dXJuIC1zdGFydFxuICAgIHJldHVybiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHN0YXJ0XG59XG4vLyBlYXNlIGluIG91dCBmdW5jdGlvbiB0aGFua3MgdG86XG4vLyBodHRwOi8vYmxvZy5ncmV3ZWIuZnIvMjAxMi8wMi9iZXppZXItY3VydmUtYmFzZWQtZWFzaW5nLWZ1bmN0aW9ucy1mcm9tLWNvbmNlcHQtdG8taW1wbGVtZW50YXRpb24vXG52YXIgZWFzZUluT3V0Q3ViaWMgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDwuNSA/IDQqdCp0KnQgOiAodC0xKSooMip0LTIpKigyKnQtMikrMSB9XG5cbi8vIGNhbGN1bGF0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHdlIHNob3VsZCBiZSBpblxuLy8gZ2l2ZW4gdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnQgb2YgdGhlIHNjcm9sbFxuLy8gdGhlIHRpbWUgZWxhcHNlZCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNjcm9sbFxuLy8gYW5kIHRoZSB0b3RhbCBkdXJhdGlvbiBvZiB0aGUgc2Nyb2xsIChkZWZhdWx0IDUwMG1zKVxudmFyIHBvc2l0aW9uID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgZWxhcHNlZCwgZHVyYXRpb24pIHtcbiAgICBpZiAoZWxhcHNlZCA+IGR1cmF0aW9uKSByZXR1cm4gZW5kO1xuICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBlYXNlSW5PdXRDdWJpYyhlbGFwc2VkIC8gZHVyYXRpb24pOyAvLyA8LS0geW91IGNhbiBjaGFuZ2UgdGhlIGVhc2luZyBmdW50aW9uIHRoZXJlXG4gICAgLy8gcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIChlbGFwc2VkIC8gZHVyYXRpb24pOyAvLyA8LS0gdGhpcyB3b3VsZCBnaXZlIGEgbGluZWFyIHNjcm9sbFxufVxuXG4vLyB3ZSB1c2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRvIGJlIGNhbGxlZCBieSB0aGUgYnJvd3NlciBiZWZvcmUgZXZlcnkgcmVwYWludFxuLy8gaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIGVsZW1lbnQgdGhlbiBzY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGlzIGVsZW1lbnRcbi8vIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBudW1lcmljIHRoZW4gc2Nyb2xsIHRvIHRoaXMgbG9jYXRpb25cbi8vIGlmIHRoZSBjYWxsYmFjayBleGlzdCwgaXQgaXMgY2FsbGVkIHdoZW4gdGhlIHNjcm9sbGluZyBpcyBmaW5pc2hlZFxuLy8gaWYgY29udGV4dCBpcyBzZXQgdGhlbiBzY3JvbGwgdGhhdCBlbGVtZW50LCBlbHNlIHNjcm9sbCB3aW5kb3dcbnZhciBzbW9vdGhTY3JvbGwgPSBmdW5jdGlvbihlbCwgZHVyYXRpb24sIGNhbGxiYWNrLCBjb250ZXh0KXtcbiAgICBkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDUwMDtcbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCB3aW5kb3c7XG4gICAgdmFyIHN0YXJ0ID0gY29udGV4dC5zY3JvbGxUb3AgfHwgd2luZG93LnBhZ2VZT2Zmc2V0O1xuXG4gICAgaWYgKHR5cGVvZiBlbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciBlbmQgPSBwYXJzZUludChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbmQgPSBnZXRUb3AoZWwsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICB2YXIgY2xvY2sgPSBEYXRlLm5vdygpO1xuICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICBmdW5jdGlvbihmbil7d2luZG93LnNldFRpbWVvdXQoZm4sIDE1KTt9O1xuXG4gICAgdmFyIHN0ZXAgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgZWxhcHNlZCA9IERhdGUubm93KCkgLSBjbG9jaztcbiAgICAgICAgaWYgKGNvbnRleHQgIT09IHdpbmRvdykge1xuICAgICAgICAgIGNvbnRleHQuc2Nyb2xsVG9wID0gcG9zaXRpb24oc3RhcnQsIGVuZCwgZWxhcHNlZCwgZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGwoMCwgcG9zaXRpb24oc3RhcnQsIGVuZCwgZWxhcHNlZCwgZHVyYXRpb24pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGFwc2VkID4gZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RlcCgpO1xufVxuXG52YXIgbGlua0hhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgIGlmICghZXYuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmIChsb2NhdGlvbi5oYXNoICE9PSB0aGlzLmhhc2gpIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShudWxsLCBudWxsLCB0aGlzLmhhc2gpXG4gICAgICAgIC8vIHVzaW5nIHRoZSBoaXN0b3J5IGFwaSB0byBzb2x2ZSBpc3N1ZSAjMSAtIGJhY2sgZG9lc24ndCB3b3JrXG4gICAgICAgIC8vIG1vc3QgYnJvd3NlciBkb24ndCB1cGRhdGUgOnRhcmdldCB3aGVuIHRoZSBoaXN0b3J5IGFwaSBpcyB1c2VkOlxuICAgICAgICAvLyBUSElTIElTIEEgQlVHIEZST00gVEhFIEJST1dTRVJTLlxuICAgICAgICAvLyBjaGFuZ2UgdGhlIHNjcm9sbGluZyBkdXJhdGlvbiBpbiB0aGlzIGNhbGxcbiAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmhhc2guc3Vic3RyaW5nKDEpKVxuICAgICAgICBpZiAoIW5vZGUpIHJldHVybjsgLy8gRG8gbm90IHNjcm9sbCB0byBub24tZXhpc3Rpbmcgbm9kZVxuXG4gICAgICAgIHNtb290aFNjcm9sbChub2RlLCA1MDAsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgbG9jYXRpb24ucmVwbGFjZSgnIycgKyBlbC5pZClcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBjYXVzZSB0aGUgOnRhcmdldCB0byBiZSBhY3RpdmF0ZWQuXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLy8gV2UgbG9vayBmb3IgYWxsIHRoZSBpbnRlcm5hbCBsaW5rcyBpbiB0aGUgZG9jdW1lbnRzIGFuZCBhdHRhY2ggdGhlIHNtb290aHNjcm9sbCBmdW5jdGlvblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnRlcm5hbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2FbaHJlZl49XCIjXCJdOm5vdChbaHJlZj1cIiNcIl0pJyksIGE7XG4gICAgZm9yKHZhciBpPWludGVybmFsLmxlbmd0aDsgYT1pbnRlcm5hbFstLWldOyl7XG4gICAgICAgIGEuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGxpbmtIYW5kbGVyLCBmYWxzZSk7XG4gICAgfVxufSk7XG5cbi8vIHJldHVybiBzbW9vdGhzY3JvbGwgQVBJXG5yZXR1cm4gc21vb3RoU2Nyb2xsO1xuXG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0EsV0FLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/smoothscroll/smoothscroll.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvICsgXCIgXCIgKyBvcHRpb25zLmluc2VydEF0LmJlZm9yZSk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcz9mNmQzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/urls.js\n");

/***/ }),

/***/ "./node_modules/velocity-animate/velocity.js":
/*!***************************************************!*\
  !*** ./node_modules/velocity-animate/velocity.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! VelocityJS.org (2.0.2) (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */\n(function(root, factory) {\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}(this, function() {\n\nvar __assign = this && this.__assign || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n};\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Constants and defaults. These values should never change without a MINOR\n * version bump.\n */\n//[\"completeCall\", \"CSS\", \"State\", \"getEasing\", \"Easings\", \"data\", \"debug\", \"defaults\", \"hook\", \"init\", \"mock\", \"pauseAll\", \"queue\", \"dequeue\", \"freeAnimationCall\", \"Redirects\", \"RegisterEffect\", \"resumeAll\", \"RunSequence\", \"lastTick\", \"tick\", \"timestamp\", \"expandTween\", \"version\"]\nvar PUBLIC_MEMBERS = [ \"version\", \"RegisterEffect\", \"style\", \"patch\", \"timestamp\" ];\n\n/**\n * Without this it will only un-prefix properties that have a valid \"normal\"\n * version.\n */ var ALL_VENDOR_PREFIXES = true;\n\nvar DURATION_FAST = 200;\n\nvar DURATION_NORMAL = 400;\n\nvar DURATION_SLOW = 600;\n\nvar FUZZY_MS_PER_SECOND = 980;\n\nvar DEFAULT_CACHE = true;\n\nvar DEFAULT_DELAY = 0;\n\nvar DEFAULT_DURATION = DURATION_NORMAL;\n\nvar DEFAULT_EASING = \"swing\";\n\nvar DEFAULT_FPSLIMIT = 60;\n\nvar DEFAULT_LOOP = 0;\n\nvar DEFAULT_PROMISE = true;\n\nvar DEFAULT_PROMISE_REJECT_EMPTY = true;\n\nvar DEFAULT_QUEUE = \"\";\n\nvar DEFAULT_REPEAT = 0;\n\nvar DEFAULT_SPEED = 1;\n\nvar DEFAULT_SYNC = true;\n\nvar TWEEN_NUMBER_REGEX = /[\\d\\.-]/;\n\nvar CLASSNAME = \"velocity-animating\";\n\nvar Duration = {\n    fast: DURATION_FAST,\n    normal: DURATION_NORMAL,\n    slow: DURATION_SLOW\n};\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Runtime type checking methods.\n */ function isBoolean(variable) {\n    return variable === true || variable === false;\n}\n\nfunction isNumber(variable) {\n    return typeof variable === \"number\";\n}\n\n/**\n * Faster way to parse a string/number as a number https://jsperf.com/number-vs-parseint-vs-plus/3\n * @param variable The given string or number\n * @returns {variable is number} Returns boolean true if it is a number, false otherwise\n */ function isNumberWhenParsed(variable) {\n    return !isNaN(Number(variable));\n}\n\nfunction isString(variable) {\n    return typeof variable === \"string\";\n}\n\nfunction isFunction(variable) {\n    return Object.prototype.toString.call(variable) === \"[object Function]\";\n}\n\nfunction isNode(variable) {\n    return !!(variable && variable.nodeType);\n}\n\nfunction isVelocityResult(variable) {\n    return variable && isNumber(variable.length) && isFunction(variable.velocity);\n}\n\nfunction propertyIsEnumerable(object, property) {\n    return Object.prototype.propertyIsEnumerable.call(object, property);\n}\n\n/* Determine if variable is an array-like wrapped jQuery, Zepto or similar element, or even a NodeList etc. */\n/* NOTE: HTMLFormElements also have a length. */ function isWrapped(variable) {\n    return variable && variable !== window && isNumber(variable.length) && !isString(variable) && !isFunction(variable) && !isNode(variable) && (variable.length === 0 || isNode(variable[0]));\n}\n\nfunction isSVG(variable) {\n    return SVGElement && variable instanceof SVGElement;\n}\n\nfunction isPlainObject(variable) {\n    if (!variable || typeof variable !== \"object\" || variable.nodeType || Object.prototype.toString.call(variable) !== \"[object Object]\") {\n        return false;\n    }\n    var proto = Object.getPrototypeOf(variable);\n    return !proto || proto.hasOwnProperty(\"constructor\") && proto.constructor === Object;\n}\n\nfunction isEmptyObject(variable) {\n    for (var name_1 in variable) {\n        if (variable.hasOwnProperty(name_1)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */\n/**\n * Creates an empty object without any prototype chain.\n */ function createEmptyObject() {\n    return Object.create(null);\n}\n\n/**\n * The <strong><code>defineProperty()</code></strong> function provides a\n * shortcut to defining a property that cannot be accidentally iterated across.\n */ function defineProperty(proto, name, value) {\n    if (proto) {\n        Object.defineProperty(proto, name, {\n            configurable: true,\n            writable: true,\n            value: value\n        });\n    }\n}\n\n/**\n * Shim to get the current milliseconds - on anything except old IE it'll use\n * Date.now() and save creating an object. If that doesn't exist then it'll\n * create one that gets GC.\n */ var _now = Date.now ? Date.now : function() {\n    return new Date().getTime();\n};\n\n/**\n * Check whether a value belongs to an array\n * https://jsperf.com/includes-vs-indexof-vs-while-loop/6\n * @param array The given array\n * @param value The given element to check if it is part of the array\n * @returns {boolean} True if it exists, false otherwise\n */ function _inArray(array, value) {\n    var i = 0;\n    while (i < array.length) {\n        if (array[i++] === value) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Convert an element or array-like element list into an array if needed.\n */ function sanitizeElements(elements) {\n    if (isNode(elements)) {\n        return [ elements ];\n    }\n    return elements;\n}\n\nfunction getValue(args) {\n    for (var i = 0, _args = arguments; i < _args.length; i++) {\n        var _arg = _args[i];\n        if (_arg !== undefined && _arg === _arg) {\n            return _arg;\n        }\n    }\n}\n\n/**\n * Add a single className to an Element.\n */ function addClass(element, className) {\n    if (element instanceof Element) {\n        if (element.classList) {\n            element.classList.add(className);\n        } else {\n            removeClass(element, className);\n            element.className += (element.className.length ? \" \" : \"\") + className;\n        }\n    }\n}\n\n/**\n * Remove a single className from an Element.\n */ function removeClass(element, className) {\n    if (element instanceof Element) {\n        if (element.classList) {\n            element.classList.remove(className);\n        } else {\n            // TODO: Need some jsperf tests on performance - can we get rid of the regex and maybe use split / array manipulation?\n            element.className = element.className.toString().replace(new RegExp(\"(^|\\\\s)\" + className + \"(\\\\s|$)\", \"gi\"), \" \");\n        }\n    }\n}\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Actions that can be performed by passing a string instead of a propertiesMap.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * Actions cannot be replaced if they are internal (hasOwnProperty is false\n     * but they still exist). Otherwise they can be replaced by users.\n     *\n     * All external method calls should be using actions rather than sub-calls\n     * of Velocity itself.\n     */\n    VelocityStatic.Actions = createEmptyObject();\n    /**\n     * Used to register an action. This should never be called by users\n     * directly, instead it should be called via  an action:<br/>\n     * <code>Velocity(\"registerAction\", \"name\", VelocityActionFn);</code>\n     *\n     * @private\n     */    function registerAction(args, internal) {\n        var name = args[0], callback = args[1];\n        if (!isString(name)) {\n            console.warn(\"VelocityJS: Trying to set 'registerAction' name to an invalid value:\", name);\n        } else if (!isFunction(callback)) {\n            console.warn(\"VelocityJS: Trying to set 'registerAction' callback to an invalid value:\", name, callback);\n        } else if (VelocityStatic.Actions[name] && !propertyIsEnumerable(VelocityStatic.Actions, name)) {\n            console.warn(\"VelocityJS: Trying to override internal 'registerAction' callback\", name);\n        } else if (internal === true) {\n            defineProperty(VelocityStatic.Actions, name, callback);\n        } else {\n            VelocityStatic.Actions[name] = callback;\n        }\n    }\n    VelocityStatic.registerAction = registerAction;\n    registerAction([ \"registerAction\", registerAction ], true);\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"actions.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Default action.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * When the stop action is triggered, the elements' currently active call is immediately stopped. The active call might have\n     * been applied to multiple elements, in which case all of the call's elements will be stopped. When an element\n     * is stopped, the next item in its animation queue is immediately triggered.\n     * An additional argument may be passed in to clear an element's remaining queued calls. Either true (which defaults to the \"fx\" queue)\n     * or a custom queue string can be passed in.\n     * Note: The stop command runs prior to Velocity's Queueing phase since its behavior is intended to take effect *immediately*,\n     * regardless of the element's current queue state.\n     *\n     * @param {HTMLorSVGElement[]} elements The collection of HTML or SVG elements\n     * @param {StrictVelocityOptions} The strict Velocity options\n     * @param {Promise<HTMLorSVGElement[]>} An optional promise if the user uses promises\n     * @param {(value?: (HTMLorSVGElement[] | VelocityResult)) => void} resolver The resolve method of the promise\n     */\n    function defaultAction(args, elements, promiseHandler, action) {\n        // TODO: default is wrong, should be runSequence based, and needs all arguments\n        if (isString(action) && VelocityStatic.Redirects[action]) {\n            var options = isPlainObject(args[0]) ? args[0] : {}, opts_1 = __assign({}, options), durationOriginal_1 = parseFloat(options.duration), delayOriginal_1 = parseFloat(options.delay) || 0;\n            /* If the backwards option was passed in, reverse the element set so that elements animate from the last to the first. */            if (opts_1.backwards === true) {\n                elements = elements.reverse();\n            }\n            /* Individually trigger the redirect for each element in the set to prevent users from having to handle iteration logic in their redirect. */            elements.forEach(function(element, elementIndex) {\n                /* If the stagger option was passed in, successively delay each element by the stagger value (in ms). Retain the original delay value. */\n                if (parseFloat(opts_1.stagger)) {\n                    opts_1.delay = delayOriginal_1 + parseFloat(opts_1.stagger) * elementIndex;\n                } else if (isFunction(opts_1.stagger)) {\n                    opts_1.delay = delayOriginal_1 + opts_1.stagger.call(element, elementIndex, elements.length);\n                }\n                /* If the drag option was passed in, successively increase/decrease (depending on the presense of opts.backwards)\n                 the duration of each element's animation, using floors to prevent producing very short durations. */                if (opts_1.drag) {\n                    /* Default the duration of UI pack effects (callouts and transitions) to 1000ms instead of the usual default duration of 400ms. */\n                    opts_1.duration = durationOriginal_1 || (/^(callout|transition)/.test(action) ? 1e3 : DEFAULT_DURATION);\n                    /* For each element, take the greater duration of: A) animation completion percentage relative to the original duration,\n                     B) 75% of the original duration, or C) a 200ms fallback (in case duration is already set to a low value).\n                     The end result is a baseline of 75% of the redirect's duration that increases/decreases as the end of the element set is approached. */                    opts_1.duration = Math.max(opts_1.duration * (opts_1.backwards ? 1 - elementIndex / elements.length : (elementIndex + 1) / elements.length), opts_1.duration * .75, 200);\n                }\n                /* Pass in the call's opts object so that the redirect can optionally extend it. It defaults to an empty object instead of null to\n                 reduce the opts checking logic required inside the redirect. */                VelocityStatic.Redirects[action].call(element, element, opts_1, elementIndex, elements.length, elements, promiseHandler && promiseHandler._resolver);\n            });\n            /* Since the animation logic resides within the redirect's own code, abort the remainder of this call.\n             (The performance overhead up to this point is virtually non-existant.) */\n            /* Note: The jQuery call chain is kept intact by returning the complete element set. */        } else {\n            var abortError = \"Velocity: First argument (\" + action + \") was not a property map, a known action, or a registered redirect. Aborting.\";\n            if (promiseHandler) {\n                promiseHandler._rejecter(new Error(abortError));\n            } else if (window.console) {\n                console.log(abortError);\n            }\n        }\n    }\n    VelocityStatic.registerAction([ \"default\", defaultAction ], true);\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"actions.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Finish all animation.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * Check if an animation should be finished, and if so we set the tweens to\n     * the final value for it, then call complete.\n     */\n    function checkAnimationShouldBeFinished(animation, queueName, defaultQueue) {\n        VelocityStatic.validateTweens(animation);\n        if (queueName === undefined || queueName === getValue(animation.queue, animation.options.queue, defaultQueue)) {\n            if (!(animation._flags & 4 /* STARTED */)) {\n                // Copied from tick.ts - ensure that the animation is completely\n                // valid and run begin() before complete().\n                var options = animation.options;\n                // The begin callback is fired once per call, not once per\n                // element, and is passed the full raw DOM element set as both\n                // its context and its first argument.\n                                if (options._started++ === 0) {\n                    options._first = animation;\n                    if (options.begin) {\n                        // Pass to an external fn with a try/catch block for optimisation\n                        VelocityStatic.callBegin(animation);\n                        // Only called once, even if reversed or repeated\n                                                options.begin = undefined;\n                    }\n                }\n                animation._flags |= 4 /* STARTED */;\n            }\n            for (var property in animation.tweens) {\n                var tween_1 = animation.tweens[property], pattern = tween_1.pattern;\n                var currentValue = \"\", i = 0;\n                if (pattern) {\n                    for (;i < pattern.length; i++) {\n                        var endValue = tween_1.end[i];\n                        currentValue += endValue == null ? pattern[i] : endValue;\n                    }\n                }\n                VelocityStatic.CSS.setPropertyValue(animation.element, property, currentValue, tween_1.fn);\n            }\n            VelocityStatic.completeCall(animation);\n        }\n    }\n    /**\n     * When the finish action is triggered, the elements' currently active call is\n     * immediately finished. When an element is finished, the next item in its\n     * animation queue is immediately triggered. If passed via a chained call\n     * then this will only target the animations in that call, and not the\n     * elements linked to it.\n     *\n     * A queue name may be passed in to specify that only animations on the\n     * named queue are finished. The default queue is named \"\". In addition the\n     * value of `false` is allowed for the queue name.\n     *\n     * An final argument may be passed in to clear an element's remaining queued\n     * calls. This may only be the value `true`.\n     */    function finish(args, elements, promiseHandler) {\n        var queueName = validateQueue(args[0], true), defaultQueue = VelocityStatic.defaults.queue, finishAll = args[queueName === undefined ? 0 : 1] === true;\n        if (isVelocityResult(elements) && elements.velocity.animations) {\n            for (var i = 0, animations = elements.velocity.animations; i < animations.length; i++) {\n                checkAnimationShouldBeFinished(animations[i], queueName, defaultQueue);\n            }\n        } else {\n            var activeCall = VelocityStatic.State.first, nextCall = void 0;\n            while (activeCall = VelocityStatic.State.firstNew) {\n                VelocityStatic.validateTweens(activeCall);\n            }\n            for (activeCall = VelocityStatic.State.first; activeCall && (finishAll || activeCall !== VelocityStatic.State.firstNew); activeCall = nextCall || VelocityStatic.State.firstNew) {\n                nextCall = activeCall._next;\n                if (!elements || _inArray(elements, activeCall.element)) {\n                    checkAnimationShouldBeFinished(activeCall, queueName, defaultQueue);\n                }\n            }\n        }\n        if (promiseHandler) {\n            if (isVelocityResult(elements) && elements.velocity.animations && elements.then) {\n                elements.then(promiseHandler._resolver);\n            } else {\n                promiseHandler._resolver(elements);\n            }\n        }\n    }\n    VelocityStatic.registerAction([ \"finish\", finish ], true);\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"actions.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Get or set a value from one or more running animations.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * Used to map getters for the various AnimationFlags.\n     */\n    var animationFlags = {\n        isExpanded: 1 /* EXPANDED */ ,\n        isReady: 2 /* READY */ ,\n        isStarted: 4 /* STARTED */ ,\n        isStopped: 8 /* STOPPED */ ,\n        isPaused: 16 /* PAUSED */ ,\n        isSync: 32 /* SYNC */ ,\n        isReverse: 64\n /* REVERSE */    };\n    /**\n     * Get or set an option or running AnimationCall data value. If there is no\n     * value passed then it will get, otherwise we will set.\n     *\n     * NOTE: When using \"get\" this will not touch the Promise as it is never\n     * returned to the user.\n     */    function option(args, elements, promiseHandler, action) {\n        var key = args[0], queue = action.indexOf(\".\") >= 0 ? action.replace(/^.*\\./, \"\") : undefined, queueName = queue === \"false\" ? false : validateQueue(queue, true);\n        var animations, value = args[1];\n        if (!key) {\n            console.warn(\"VelocityJS: Cannot access a non-existant key!\");\n            return null;\n        }\n        // If we're chaining the return value from Velocity then we are only\n        // interested in the values related to that call\n                if (isVelocityResult(elements) && elements.velocity.animations) {\n            animations = elements.velocity.animations;\n        } else {\n            animations = [];\n            for (var activeCall = VelocityStatic.State.first; activeCall; activeCall = activeCall._next) {\n                if (elements.indexOf(activeCall.element) >= 0 && getValue(activeCall.queue, activeCall.options.queue) === queueName) {\n                    animations.push(activeCall);\n                }\n            }\n            // If we're dealing with multiple elements that are pointing at a\n            // single running animation, then instead treat them as a single\n            // animation.\n                        if (elements.length > 1 && animations.length > 1) {\n                var i = 1, options = animations[0].options;\n                while (i < animations.length) {\n                    if (animations[i++].options !== options) {\n                        options = null;\n                        break;\n                    }\n                }\n                // TODO: this needs to check that they're actually a sync:true animation to merge the results, otherwise the individual values may be different\n                                if (options) {\n                    animations = [ animations[0] ];\n                }\n            }\n        }\n        // GET\n                if (value === undefined) {\n            var result = [], flag = animationFlags[key];\n            for (var i = 0; i < animations.length; i++) {\n                if (flag === undefined) {\n                    // A normal key to get.\n                    result.push(getValue(animations[i][key], animations[i].options[key]));\n                } else {\n                    // A flag that we're checking against.\n                    result.push((animations[i]._flags & flag) === 0);\n                }\n            }\n            if (elements.length === 1 && animations.length === 1) {\n                // If only a single animation is found and we're only targetting a\n                // single element, then return the value directly\n                return result[0];\n            }\n            return result;\n        }\n        // SET\n                var isPercentComplete;\n        switch (key) {\n          case \"cache\":\n            value = validateCache(value);\n            break;\n\n          case \"begin\":\n            value = validateBegin(value);\n            break;\n\n          case \"complete\":\n            value = validateComplete(value);\n            break;\n\n          case \"delay\":\n            value = validateDelay(value);\n            break;\n\n          case \"duration\":\n            value = validateDuration(value);\n            break;\n\n          case \"fpsLimit\":\n            value = validateFpsLimit(value);\n            break;\n\n          case \"loop\":\n            value = validateLoop(value);\n            break;\n\n          case \"percentComplete\":\n            isPercentComplete = true;\n            value = parseFloat(value);\n            break;\n\n          case \"repeat\":\n          case \"repeatAgain\":\n            value = validateRepeat(value);\n            break;\n\n          default:\n            if (key[0] !== \"_\") {\n                var num = parseFloat(value);\n                if (value == num) {\n                    value = num;\n                }\n                break;\n            }\n\n            // deliberate fallthrough\n                      case \"queue\":\n          case \"promise\":\n          case \"promiseRejectEmpty\":\n          case \"easing\":\n          case \"started\":\n            console.warn(\"VelocityJS: Trying to set a read-only key:\", key);\n            return;\n        }\n        if (value === undefined || value !== value) {\n            console.warn(\"VelocityJS: Trying to set an invalid value:\", key, \"=\", value, \"(\" + args[1] + \")\");\n            return null;\n        }\n        for (var i = 0; i < animations.length; i++) {\n            var animation = animations[i];\n            if (isPercentComplete) {\n                animation.timeStart = VelocityStatic.lastTick - getValue(animation.duration, animation.options.duration, VelocityStatic.defaults.duration) * value;\n            } else {\n                animation[key] = value;\n            }\n        }\n        if (promiseHandler) {\n            if (isVelocityResult(elements) && elements.velocity.animations && elements.then) {\n                elements.then(promiseHandler._resolver);\n            } else {\n                promiseHandler._resolver(elements);\n            }\n        }\n    }\n    VelocityStatic.registerAction([ \"option\", option ], true);\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"actions.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Pause and resume animation.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * Check if an animation should be paused / resumed.\n     */\n    function checkAnimation(animation, queueName, defaultQueue, isPaused) {\n        if (queueName === undefined || queueName === getValue(animation.queue, animation.options.queue, defaultQueue)) {\n            if (isPaused) {\n                animation._flags |= 16 /* PAUSED */;\n            } else {\n                animation._flags &= ~16 /* PAUSED */;\n            }\n        }\n    }\n    /**\n     * Pause and Resume are call-wide (not on a per element basis). Thus, calling pause or resume on a\n     * single element will cause any calls that contain tweens for that element to be paused/resumed\n     * as well.\n     */\n    function pauseResume(args, elements, promiseHandler, action) {\n        var isPaused = action.indexOf(\"pause\") === 0, queue = action.indexOf(\".\") >= 0 ? action.replace(/^.*\\./, \"\") : undefined, queueName = queue === \"false\" ? false : validateQueue(args[0]), defaultQueue = VelocityStatic.defaults.queue;\n        if (isVelocityResult(elements) && elements.velocity.animations) {\n            for (var i = 0, animations = elements.velocity.animations; i < animations.length; i++) {\n                checkAnimation(animations[i], queueName, defaultQueue, isPaused);\n            }\n        } else {\n            var activeCall = VelocityStatic.State.first;\n            while (activeCall) {\n                if (!elements || _inArray(elements, activeCall.element)) {\n                    checkAnimation(activeCall, queueName, defaultQueue, isPaused);\n                }\n                activeCall = activeCall._next;\n            }\n        }\n        if (promiseHandler) {\n            if (isVelocityResult(elements) && elements.velocity.animations && elements.then) {\n                elements.then(promiseHandler._resolver);\n            } else {\n                promiseHandler._resolver(elements);\n            }\n        }\n    }\n    VelocityStatic.registerAction([ \"pause\", pauseResume ], true);\n    VelocityStatic.registerAction([ \"resume\", pauseResume ], true);\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"actions.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Actions that can be performed by passing a string instead of a propertiesMap.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    VelocityStatic.registerAction([ \"reverse\", function(args, elements, promiseHandler, action) {\n        // TODO: Code needs to split out before here - but this is needed to prevent it being overridden\n        throw new SyntaxError(\"VelocityJS: The 'reverse' action is private.\");\n    } ], true);\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"actions.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Stop animation.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * Check if an animation should be stopped, and if so then set the STOPPED\n     * flag on it, then call complete.\n     */\n    function checkAnimationShouldBeStopped(animation, queueName, defaultQueue) {\n        VelocityStatic.validateTweens(animation);\n        if (queueName === undefined || queueName === getValue(animation.queue, animation.options.queue, defaultQueue)) {\n            animation._flags |= 8 /* STOPPED */;\n            VelocityStatic.completeCall(animation);\n        }\n    }\n    /**\n     * When the stop action is triggered, the elements' currently active call is\n     * immediately stopped. When an element is stopped, the next item in its\n     * animation queue is immediately triggered. If passed via a chained call\n     * then this will only target the animations in that call, and not the\n     * elements linked to it.\n     *\n     * A queue name may be passed in to specify that only animations on the\n     * named queue are stopped. The default queue is named \"\". In addition the\n     * value of `false` is allowed for the queue name.\n     *\n     * An final argument may be passed in to clear an element's remaining queued\n     * calls. This may only be the value `true`.\n     *\n     * Note: The stop command runs prior to Velocity's Queueing phase since its\n     * behavior is intended to take effect *immediately*, regardless of the\n     * element's current queue state.\n     */    function stop(args, elements, promiseHandler, action) {\n        var queueName = validateQueue(args[0], true), defaultQueue = VelocityStatic.defaults.queue, finishAll = args[queueName === undefined ? 0 : 1] === true;\n        if (isVelocityResult(elements) && elements.velocity.animations) {\n            for (var i = 0, animations = elements.velocity.animations; i < animations.length; i++) {\n                checkAnimationShouldBeStopped(animations[i], queueName, defaultQueue);\n            }\n        } else {\n            var activeCall = VelocityStatic.State.first, nextCall = void 0;\n            while (activeCall = VelocityStatic.State.firstNew) {\n                VelocityStatic.validateTweens(activeCall);\n            }\n            for (activeCall = VelocityStatic.State.first; activeCall && (finishAll || activeCall !== VelocityStatic.State.firstNew); activeCall = nextCall || VelocityStatic.State.firstNew) {\n                nextCall = activeCall._next;\n                if (!elements || _inArray(elements, activeCall.element)) {\n                    checkAnimationShouldBeStopped(activeCall, queueName, defaultQueue);\n                }\n            }\n        }\n        if (promiseHandler) {\n            if (isVelocityResult(elements) && elements.velocity.animations && elements.then) {\n                elements.then(promiseHandler._resolver);\n            } else {\n                promiseHandler._resolver(elements);\n            }\n        }\n    }\n    VelocityStatic.registerAction([ \"stop\", stop ], true);\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"actions.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Get or set a property from one or more elements.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    function style(elements, property, value) {\n        return styleAction([ property, value ], elements);\n    }\n    VelocityStatic.style = style;\n    /**\n     * Get or set a style of Nomralised property value on one or more elements.\n     * If there is no value passed then it will get, otherwise we will set.\n     *\n     * NOTE: When using \"get\" this will not touch the Promise as it is never\n     * returned to the user.\n     *\n     * This can fail to set, and will reject the Promise if it does so.\n     *\n     * Velocity(elements, \"style\", \"property\", \"value\") => elements;\n     * Velocity(elements, \"style\", {\"property\": \"value\", ...}) => elements;\n     * Velocity(element, \"style\", \"property\") => \"value\";\n     * Velocity(elements, \"style\", \"property\") => [\"value\", ...];\n     */    function styleAction(args, elements, promiseHandler, action) {\n        var property = args[0], value = args[1];\n        if (!property) {\n            console.warn(\"VelocityJS: Cannot access a non-existant property!\");\n            return null;\n        }\n        // GET\n                if (value === undefined && !isPlainObject(property)) {\n            // If only a single animation is found and we're only targetting a\n            // single element, then return the value directly\n            if (elements.length === 1) {\n                return VelocityStatic.CSS.fixColors(VelocityStatic.CSS.getPropertyValue(elements[0], property));\n            }\n            var result = [];\n            for (var i = 0; i < elements.length; i++) {\n                result.push(VelocityStatic.CSS.fixColors(VelocityStatic.CSS.getPropertyValue(elements[i], property)));\n            }\n            return result;\n        }\n        // SET\n                var error;\n        if (isPlainObject(property)) {\n            for (var propertyName in property) {\n                for (var i = 0; i < elements.length; i++) {\n                    var value_1 = property[propertyName];\n                    if (isString(value_1) || isNumber(value_1)) {\n                        VelocityStatic.CSS.setPropertyValue(elements[i], propertyName, property[propertyName]);\n                    } else {\n                        error = (error ? error + \", \" : \"\") + \"Cannot set a property '\" + propertyName + \"' to an unknown type: \" + typeof value_1;\n                        console.warn(\"VelocityJS: Cannot set a property '\" + propertyName + \"' to an unknown type:\", value_1);\n                    }\n                }\n            }\n        } else if (isString(value) || isNumber(value)) {\n            for (var i = 0; i < elements.length; i++) {\n                VelocityStatic.CSS.setPropertyValue(elements[i], property, String(value));\n            }\n        } else {\n            error = \"Cannot set a property '\" + property + \"' to an unknown type: \" + typeof value;\n            console.warn(\"VelocityJS: Cannot set a property '\" + property + \"' to an unknown type:\", value);\n        }\n        if (promiseHandler) {\n            if (error) {\n                promiseHandler._rejecter(error);\n            } else if (isVelocityResult(elements) && elements.velocity.animations && elements.then) {\n                elements.then(promiseHandler._resolver);\n            } else {\n                promiseHandler._resolver(elements);\n            }\n        }\n    }\n    VelocityStatic.registerAction([ \"style\", styleAction ], true);\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"actions.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Get or set a property from one or more elements.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    function tween(elements, percentComplete, properties, property, easing) {\n        return tweenAction(arguments, elements);\n    }\n    VelocityStatic.tween = tween;\n    /**\n     *\n     */    function tweenAction(args, elements, promiseHandler, action) {\n        var requireForcefeeding;\n        if (!elements) {\n            if (!args.length) {\n                console.info('Velocity(<element>, \"tween\", percentComplete, property, end | [end, <easing>, <start>], <easing>) => value\\n' + 'Velocity(<element>, \"tween\", percentComplete, {property: end | [end, <easing>, <start>], ...}, <easing>) => {property: value, ...}');\n                return null;\n            }\n            elements = [ document.body ];\n            requireForcefeeding = true;\n        } else if (elements.length !== 1) {\n            // TODO: Allow more than a single element to return an array of results\n            throw new Error(\"VelocityJS: Cannot tween more than one element!\");\n        }\n        var percentComplete = args[0], fakeAnimation = {\n            elements: elements,\n            element: elements[0],\n            queue: false,\n            options: {\n                duration: 1e3\n            },\n            tweens: null\n        }, result = {};\n        var properties = args[1], singleResult, easing = args[2], count = 0;\n        if (isString(args[1])) {\n            singleResult = true;\n            properties = (_a = {}, _a[args[1]] = args[2], _a);\n            easing = args[3];\n        } else if (Array.isArray(args[1])) {\n            singleResult = true;\n            properties = {\n                tween: args[1]\n            };\n            easing = args[2];\n        }\n        if (!isNumber(percentComplete) || percentComplete < 0 || percentComplete > 1) {\n            throw new Error(\"VelocityJS: Must tween a percentage from 0 to 1!\");\n        }\n        if (!isPlainObject(properties)) {\n            throw new Error(\"VelocityJS: Cannot tween an invalid property!\");\n        }\n        if (requireForcefeeding) {\n            for (var property in properties) {\n                if (properties.hasOwnProperty(property) && (!Array.isArray(properties[property]) || properties[property].length < 2)) {\n                    throw new Error(\"VelocityJS: When not supplying an element you must force-feed values: \" + property);\n                }\n            }\n        }\n        var activeEasing = validateEasing(getValue(easing, VelocityStatic.defaults.easing), 1e3);\n        VelocityStatic.expandProperties(fakeAnimation, properties);\n        for (var property in fakeAnimation.tweens) {\n            // For every element, iterate through each property.\n            var tween_2 = fakeAnimation.tweens[property], easing_1 = tween_2.easing || activeEasing, pattern = tween_2.pattern;\n            var currentValue = \"\";\n            count++;\n            if (pattern) {\n                for (var i = 0; i < pattern.length; i++) {\n                    var startValue = tween_2.start[i];\n                    if (startValue == null) {\n                        currentValue += pattern[i];\n                    } else {\n                        var result_1 = easing_1(percentComplete, startValue, tween_2.end[i], property);\n                        currentValue += pattern[i] === true ? Math.round(result_1) : result_1;\n                    }\n                }\n            }\n            result[property] = currentValue;\n        }\n        if (singleResult && count === 1) {\n            for (var property in result) {\n                if (result.hasOwnProperty(property)) {\n                    return result[property];\n                }\n            }\n        }\n        return result;\n        var _a;\n    }\n    VelocityStatic.registerAction([ \"tween\", tweenAction ], true);\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * Container for page-wide Velocity state data.\n     */\n    var State;\n    (function(State) {\n        /**\n         * Detect if this is a NodeJS or web browser\n         */\n        State.isClient = window && window === window.window,\n        /**\n         * Detect mobile devices to determine if mobileHA should be turned\n         * on.\n         */\n        State.isMobile = State.isClient && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),\n        /**\n         * The mobileHA option's behavior changes on older Android devices\n         * (Gingerbread, versions 2.3.3-2.3.7).\n         */\n        State.isAndroid = State.isClient && /Android/i.test(navigator.userAgent),\n        /**\n         * The mobileHA option's behavior changes on older Android devices\n         * (Gingerbread, versions 2.3.3-2.3.7).\n         */\n        State.isGingerbread = State.isClient && /Android 2\\.3\\.[3-7]/i.test(navigator.userAgent),\n        /**\n         * Chrome browser\n         */\n        State.isChrome = State.isClient && window.chrome,\n        /**\n         * Firefox browser\n         */\n        State.isFirefox = State.isClient && /Firefox/i.test(navigator.userAgent),\n        /**\n         * Create a cached element for re-use when checking for CSS property\n         * prefixes.\n         */\n        State.prefixElement = State.isClient && document.createElement(\"div\"),\n        /**\n         * Retrieve the appropriate scroll anchor and property name for the\n         * browser: https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY\n         */\n        State.windowScrollAnchor = State.isClient && window.pageYOffset !== undefined,\n        /**\n         * Cache the anchor used for animating window scrolling.\n         */\n        State.scrollAnchor = State.windowScrollAnchor ? window : !State.isClient || document.documentElement || document.body.parentNode || document.body,\n        /**\n         * Cache the browser-specific property names associated with the\n         * scroll anchor.\n         */\n        State.scrollPropertyLeft = State.windowScrollAnchor ? \"pageXOffset\" : \"scrollLeft\",\n        /**\n         * Cache the browser-specific property names associated with the\n         * scroll anchor.\n         */\n        State.scrollPropertyTop = State.windowScrollAnchor ? \"pageYOffset\" : \"scrollTop\",\n        /**\n         * The className we add / remove when animating.\n         */\n        State.className = CLASSNAME,\n        /**\n         * Keep track of whether our RAF tick is running.\n         */\n        State.isTicking = false;\n    })(State = VelocityStatic.State || (VelocityStatic.State = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"../state.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    var CSS;\n    (function(CSS) {\n        /**\n         * Cache every camelCase match to avoid repeating lookups.\n         */\n        var cache = createEmptyObject();\n        /**\n         * Camelcase a property name into its JavaScript notation (e.g.\n         * \"background-color\" ==> \"backgroundColor\"). Camelcasing is used to\n         * normalize property names between and across calls.\n         */        function camelCase(property) {\n            var fixed = cache[property];\n            if (fixed) {\n                return fixed;\n            }\n            return cache[property] = property.replace(/-([a-z])/g, function($, letter) {\n                return letter.toUpperCase();\n            });\n        }\n        CSS.camelCase = camelCase;\n    })(CSS = VelocityStatic.CSS || (VelocityStatic.CSS = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    var CSS;\n    (function(CSS) {\n        /**\n         * This is the list of color names -> rgb values. The object is in here so\n         * that the actual name conversion can be in a separate file and not\n         * included for custom builds.\n         */\n        CSS.ColorNames = createEmptyObject();\n        /**\n         * Convert a hex list to an rgba value. Designed to be used in replace.\n         */        function makeRGBA(ignore, r, g, b) {\n            return \"rgba(\" + parseInt(r, 16) + \",\" + parseInt(g, 16) + \",\" + parseInt(b, 16) + \",1)\";\n        }\n        var rxColor6 = /#([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})/gi, rxColor3 = /#([a-f\\d])([a-f\\d])([a-f\\d])/gi, rxColorName = /(rgba?\\(\\s*)?(\\b[a-z]+\\b)/g, rxRGB = /rgb(a?)\\(([^\\)]+)\\)/gi, rxSpaces = /\\s+/g;\n        /**\n         * Replace any css colour name with its rgba() value. It is possible to use\n         * the name within an \"rgba(blue, 0.4)\" string this way.\n         */        function fixColors(str) {\n            return str.replace(rxColor6, makeRGBA).replace(rxColor3, function($0, r, g, b) {\n                return makeRGBA($0, r + r, g + g, b + b);\n            }).replace(rxColorName, function($0, $1, $2) {\n                if (CSS.ColorNames[$2]) {\n                    return ($1 ? $1 : \"rgba(\") + CSS.ColorNames[$2] + ($1 ? \"\" : \",1)\");\n                }\n                return $0;\n            }).replace(rxRGB, function($0, $1, $2) {\n                return \"rgba(\" + $2.replace(rxSpaces, \"\") + ($1 ? \"\" : \",1\") + \")\";\n            });\n        }\n        CSS.fixColors = fixColors;\n    })(CSS = VelocityStatic.CSS || (VelocityStatic.CSS = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"fixColors.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    var CSS;\n    (function(CSS) {\n        // Converting from hex as it makes for a smaller file.\n        // TODO: When build system changes to webpack, make this one optional.\n        var colorValues = {\n            aliceblue: 15792383,\n            antiquewhite: 16444375,\n            aqua: 65535,\n            aquamarine: 8388564,\n            azure: 15794175,\n            beige: 16119260,\n            bisque: 16770244,\n            black: 0,\n            blanchedalmond: 16772045,\n            blue: 255,\n            blueviolet: 9055202,\n            brown: 10824234,\n            burlywood: 14596231,\n            cadetblue: 6266528,\n            chartreuse: 8388352,\n            chocolate: 13789470,\n            coral: 16744272,\n            cornflowerblue: 6591981,\n            cornsilk: 16775388,\n            crimson: 14423100,\n            cyan: 65535,\n            darkblue: 139,\n            darkcyan: 35723,\n            darkgoldenrod: 12092939,\n            darkgray: 11119017,\n            darkgrey: 11119017,\n            darkgreen: 25600,\n            darkkhaki: 12433259,\n            darkmagenta: 9109643,\n            darkolivegreen: 5597999,\n            darkorange: 16747520,\n            darkorchid: 10040012,\n            darkred: 9109504,\n            darksalmon: 15308410,\n            darkseagreen: 9419919,\n            darkslateblue: 4734347,\n            darkslategray: 3100495,\n            darkslategrey: 3100495,\n            darkturquoise: 52945,\n            darkviolet: 9699539,\n            deeppink: 16716947,\n            deepskyblue: 49151,\n            dimgray: 6908265,\n            dimgrey: 6908265,\n            dodgerblue: 2003199,\n            firebrick: 11674146,\n            floralwhite: 16775920,\n            forestgreen: 2263842,\n            fuchsia: 16711935,\n            gainsboro: 14474460,\n            ghostwhite: 16316671,\n            gold: 16766720,\n            goldenrod: 14329120,\n            gray: 8421504,\n            grey: 8421504,\n            green: 32768,\n            greenyellow: 11403055,\n            honeydew: 15794160,\n            hotpink: 16738740,\n            indianred: 13458524,\n            indigo: 4915330,\n            ivory: 16777200,\n            khaki: 15787660,\n            lavender: 15132410,\n            lavenderblush: 16773365,\n            lawngreen: 8190976,\n            lemonchiffon: 16775885,\n            lightblue: 11393254,\n            lightcoral: 15761536,\n            lightcyan: 14745599,\n            lightgoldenrodyellow: 16448210,\n            lightgray: 13882323,\n            lightgrey: 13882323,\n            lightgreen: 9498256,\n            lightpink: 16758465,\n            lightsalmon: 16752762,\n            lightseagreen: 2142890,\n            lightskyblue: 8900346,\n            lightslategray: 7833753,\n            lightslategrey: 7833753,\n            lightsteelblue: 11584734,\n            lightyellow: 16777184,\n            lime: 65280,\n            limegreen: 3329330,\n            linen: 16445670,\n            magenta: 16711935,\n            maroon: 8388608,\n            mediumaquamarine: 6737322,\n            mediumblue: 205,\n            mediumorchid: 12211667,\n            mediumpurple: 9662683,\n            mediumseagreen: 3978097,\n            mediumslateblue: 8087790,\n            mediumspringgreen: 64154,\n            mediumturquoise: 4772300,\n            mediumvioletred: 13047173,\n            midnightblue: 1644912,\n            mintcream: 16121850,\n            mistyrose: 16770273,\n            moccasin: 16770229,\n            navajowhite: 16768685,\n            navy: 128,\n            oldlace: 16643558,\n            olive: 8421376,\n            olivedrab: 7048739,\n            orange: 16753920,\n            orangered: 16729344,\n            orchid: 14315734,\n            palegoldenrod: 15657130,\n            palegreen: 10025880,\n            paleturquoise: 11529966,\n            palevioletred: 14381203,\n            papayawhip: 16773077,\n            peachpuff: 16767673,\n            peru: 13468991,\n            pink: 16761035,\n            plum: 14524637,\n            powderblue: 11591910,\n            purple: 8388736,\n            rebeccapurple: 6697881,\n            red: 16711680,\n            rosybrown: 12357519,\n            royalblue: 4286945,\n            saddlebrown: 9127187,\n            salmon: 16416882,\n            sandybrown: 16032864,\n            seagreen: 3050327,\n            seashell: 16774638,\n            sienna: 10506797,\n            silver: 12632256,\n            skyblue: 8900331,\n            slateblue: 6970061,\n            slategray: 7372944,\n            slategrey: 7372944,\n            snow: 16775930,\n            springgreen: 65407,\n            steelblue: 4620980,\n            tan: 13808780,\n            teal: 32896,\n            thistle: 14204888,\n            tomato: 16737095,\n            turquoise: 4251856,\n            violet: 15631086,\n            wheat: 16113331,\n            white: 16777215,\n            whitesmoke: 16119285,\n            yellow: 16776960,\n            yellowgreen: 10145074\n        };\n        for (var name_2 in colorValues) {\n            if (colorValues.hasOwnProperty(name_2)) {\n                var color = colorValues[name_2];\n                CSS.ColorNames[name_2] = Math.floor(color / 65536) + \",\" + Math.floor(color / 256 % 256) + \",\" + color % 256;\n            }\n        }\n    })(CSS = VelocityStatic.CSS || (VelocityStatic.CSS = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    var CSS;\n    (function(CSS) {\n        // TODO: This is still a complete mess\n        function computePropertyValue(element, property) {\n            var data = Data(element),\n            // If computedStyle is cached, use it.\n            computedStyle = data && data.computedStyle ? data.computedStyle : window.getComputedStyle(element, null);\n            var computedValue = 0;\n            if (data && !data.computedStyle) {\n                data.computedStyle = computedStyle;\n            }\n            if (property === \"width\" || property === \"height\") {\n                // Browsers do not return height and width values for elements\n                // that are set to display:\"none\". Thus, we temporarily toggle\n                // display to the element type's default value.\n                var toggleDisplay = getPropertyValue(element, \"display\") === \"none\";\n                // When box-sizing isn't set to border-box, height and width\n                // style values are incorrectly computed when an element's\n                // scrollbars are visible (which expands the element's\n                // dimensions). Thus, we defer to the more accurate\n                // offsetHeight/Width property, which includes the total\n                // dimensions for interior, border, padding, and scrollbar. We\n                // subtract border and padding to get the sum of interior +\n                // scrollbar.\n                // TODO: offsetHeight does not exist on SVGElement\n                                if (toggleDisplay) {\n                    CSS.setPropertyValue(element, \"display\", \"auto\");\n                }\n                computedValue = VelocityStatic.augmentDimension(element, property, true);\n                if (toggleDisplay) {\n                    CSS.setPropertyValue(element, \"display\", \"none\");\n                }\n                return String(computedValue);\n            }\n            /* IE and Firefox do not return a value for the generic borderColor -- they only return individual values for each border side's color.\n             Also, in all browsers, when border colors aren't all the same, a compound value is returned that Velocity isn't setup to parse.\n             So, as a polyfill for querying individual border side colors, we just return the top border's color and animate all borders from that value. */\n            /* TODO: There is a borderColor normalisation in legacy/ - figure out where this is needed... */            computedValue = computedStyle[property];\n            /* Fall back to the property's style value (if defined) when computedValue returns nothing,\n             which can happen when the element hasn't been painted. */            if (!computedValue) {\n                computedValue = element.style[property];\n            }\n            /* For top, right, bottom, and left (TRBL) values that are set to \"auto\" on elements of \"fixed\" or \"absolute\" position,\n             defer to jQuery for converting \"auto\" to a numeric value. (For elements with a \"static\" or \"relative\" position, \"auto\" has the same\n             effect as being set to 0, so no conversion is necessary.) */\n            /* An example of why numeric conversion is necessary: When an element with \"position:absolute\" has an untouched \"left\"\n             property, which reverts to \"auto\", left's value is 0 relative to its parent element, but is often non-zero relative\n             to its *containing* (not parent) element, which is the nearest \"position:relative\" ancestor or the viewport (and always the viewport in the case of \"position:fixed\"). */            if (computedValue === \"auto\") {\n                switch (property) {\n                  case \"top\":\n                  case \"left\":\n                    var topLeft = true;\n\n                  case \"right\":\n                  case \"bottom\":\n                    var position = getPropertyValue(element, \"position\");\n /* GET */                    if (position === \"fixed\" || topLeft && position === \"absolute\") {\n                        // Note: this has no pixel unit on its returned values,\n                        // we re-add it here to conform with\n                        // computePropertyValue's behavior.\n                        computedValue = element.getBoundingClientRect[property] + \"px\";\n /* GET */                        break;\n                    }\n\n                    // Deliberate fallthrough!\n                                      default:\n                    computedValue = \"0px\";\n                    break;\n                }\n            }\n            return computedValue ? String(computedValue) : \"\";\n        }\n        CSS.computePropertyValue = computePropertyValue;\n        /**\n         * Get a property value. This will grab via the cache if it exists, then\n         * via any normalisations.\n         */        function getPropertyValue(element, propertyName, fn, skipCache) {\n            var data = Data(element);\n            var propertyValue;\n            if (VelocityStatic.NoCacheNormalizations.has(propertyName)) {\n                skipCache = true;\n            }\n            if (!skipCache && data && data.cache[propertyName] != null) {\n                propertyValue = data.cache[propertyName];\n            } else {\n                fn = fn || VelocityStatic.getNormalization(element, propertyName);\n                if (fn) {\n                    propertyValue = fn(element);\n                    if (data) {\n                        data.cache[propertyName] = propertyValue;\n                    }\n                }\n            }\n            if (VelocityStatic.debug >= 2) {\n                console.info(\"Get \" + propertyName + \": \" + propertyValue);\n            }\n            return propertyValue;\n        }\n        CSS.getPropertyValue = getPropertyValue;\n    })(CSS = VelocityStatic.CSS || (VelocityStatic.CSS = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    var CSS;\n    (function(CSS) {\n        /**\n         * All possible units in CSS. Used to recognise units when parsing tweens.\n         */\n        var Units = [ \"%\", \"em\", \"ex\", \"ch\", \"rem\", \"vw\", \"vh\", \"vmin\", \"vmax\", \"cm\", \"mm\", \"Q\", \"in\", \"pc\", \"pt\", \"px\", \"deg\", \"grad\", \"rad\", \"turn\", \"s\", \"ms\" ];\n        /**\n         * Get the current unit for this property. Only used when parsing tweens\n         * to check if the unit is changing between the start and end values.\n         */        function getUnit(property, start) {\n            start = start || 0;\n            if (property[start] && property[start] !== \" \") {\n                for (var i = 0, units = Units; i < units.length; i++) {\n                    var unit = units[i];\n                    var j = 0;\n                    do {\n                        if (j >= unit.length) {\n                            return unit;\n                        }\n                        if (unit[j] !== property[start + j]) {\n                            break;\n                        }\n                    } while (++j);\n                }\n            }\n            return \"\";\n        }\n        CSS.getUnit = getUnit;\n    })(CSS = VelocityStatic.CSS || (VelocityStatic.CSS = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    var CSS;\n    (function(CSS) {\n        /**\n         * The singular setPropertyValue, which routes the logic for all\n         * normalizations.\n         */\n        function setPropertyValue(element, propertyName, propertyValue, fn) {\n            var data = Data(element);\n            if (isString(propertyValue) && propertyValue[0] === \"c\" && propertyValue[1] === \"a\" && propertyValue[2] === \"l\" && propertyValue[3] === \"c\" && propertyValue[4] === \"(\" && propertyValue[5] === \"0\" && propertyValue[5] === \" \") {\n                // Make sure we un-calc unit changing values - try not to trigger\n                // this code any more often than we have to since it's expensive\n                propertyValue = propertyValue.replace(/^calc\\(0[^\\d]* \\+ ([^\\(\\)]+)\\)$/, \"$1\");\n            }\n            if (data && data.cache[propertyName] !== propertyValue) {\n                // By setting it to undefined we force a true \"get\" later\n                data.cache[propertyName] = propertyValue || undefined;\n                fn = fn || VelocityStatic.getNormalization(element, propertyName);\n                if (fn) {\n                    fn(element, propertyValue);\n                }\n                if (VelocityStatic.debug >= 2) {\n                    console.info(\"Set \" + propertyName + \": \" + propertyValue, element);\n                }\n            }\n        }\n        CSS.setPropertyValue = setPropertyValue;\n    })(CSS = VelocityStatic.CSS || (VelocityStatic.CSS = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    var Easing;\n    (function(Easing) {\n        Easing.Easings = createEmptyObject();\n        /**\n         * Used to register a easing. This should never be called by users\n         * directly, instead it should be called via an action:<br/>\n         * <code>Velocity(\"registerEasing\", \"name\", VelocityEasingFn);</code>\n         *\n         * @private\n         */        function registerEasing(args) {\n            var name = args[0], callback = args[1];\n            if (!isString(name)) {\n                console.warn(\"VelocityJS: Trying to set 'registerEasing' name to an invalid value:\", name);\n            } else if (!isFunction(callback)) {\n                console.warn(\"VelocityJS: Trying to set 'registerEasing' callback to an invalid value:\", name, callback);\n            } else if (Easing.Easings[name]) {\n                console.warn(\"VelocityJS: Trying to override 'registerEasing' callback\", name);\n            } else {\n                Easing.Easings[name] = callback;\n            }\n        }\n        Easing.registerEasing = registerEasing;\n        VelocityStatic.registerAction([ \"registerEasing\", registerEasing ], true);\n        /* Basic (same as jQuery) easings. */        registerEasing([ \"linear\", function(percentComplete, startValue, endValue) {\n            return startValue + percentComplete * (endValue - startValue);\n        } ]);\n        registerEasing([ \"swing\", function(percentComplete, startValue, endValue) {\n            return startValue + (.5 - Math.cos(percentComplete * Math.PI) / 2) * (endValue - startValue);\n        } ]);\n        /* Bonus \"spring\" easing, which is a less exaggerated version of easeInOutElastic. */        registerEasing([ \"spring\", function(percentComplete, startValue, endValue) {\n            return startValue + (1 - Math.cos(percentComplete * 4.5 * Math.PI) * Math.exp(-percentComplete * 6)) * (endValue - startValue);\n        } ]);\n    })(Easing = VelocityStatic.Easing || (VelocityStatic.Easing = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"easings.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Back easings, based on code from https://github.com/yuichiroharai/easeplus-velocity\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    var Easing;\n    (function(Easing) {\n        function registerBackIn(name, amount) {\n            Easing.registerEasing([ name, function(percentComplete, startValue, endValue) {\n                if (percentComplete === 0) {\n                    return startValue;\n                }\n                if (percentComplete === 1) {\n                    return endValue;\n                }\n                return Math.pow(percentComplete, 2) * ((amount + 1) * percentComplete - amount) * (endValue - startValue);\n            } ]);\n        }\n        Easing.registerBackIn = registerBackIn;\n        function registerBackOut(name, amount) {\n            Easing.registerEasing([ name, function(percentComplete, startValue, endValue) {\n                if (percentComplete === 0) {\n                    return startValue;\n                }\n                if (percentComplete === 1) {\n                    return endValue;\n                }\n                return (Math.pow(--percentComplete, 2) * ((amount + 1) * percentComplete + amount) + 1) * (endValue - startValue);\n            } ]);\n        }\n        Easing.registerBackOut = registerBackOut;\n        function registerBackInOut(name, amount) {\n            amount *= 1.525;\n            Easing.registerEasing([ name, function(percentComplete, startValue, endValue) {\n                if (percentComplete === 0) {\n                    return startValue;\n                }\n                if (percentComplete === 1) {\n                    return endValue;\n                }\n                return ((percentComplete *= 2) < 1 ? Math.pow(percentComplete, 2) * ((amount + 1) * percentComplete - amount) : Math.pow(percentComplete -= 2, 2) * ((amount + 1) * percentComplete + amount) + 2) * .5 * (endValue - startValue);\n            } ]);\n        }\n        Easing.registerBackInOut = registerBackInOut;\n        registerBackIn(\"easeInBack\", 1.7);\n        registerBackOut(\"easeOutBack\", 1.7);\n        registerBackInOut(\"easeInOutBack\", 1.7);\n        // TODO: Expose these as actions to register custom easings?\n        })(Easing = VelocityStatic.Easing || (VelocityStatic.Easing = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"easings.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    var Easing;\n    (function(Easing) {\n        /**\n         * Fix to a range of <code>0 <= num <= 1</code>.\n         */\n        function fixRange(num) {\n            return Math.min(Math.max(num, 0), 1);\n        }\n        function A(aA1, aA2) {\n            return 1 - 3 * aA2 + 3 * aA1;\n        }\n        function B(aA1, aA2) {\n            return 3 * aA2 - 6 * aA1;\n        }\n        function C(aA1) {\n            return 3 * aA1;\n        }\n        function calcBezier(aT, aA1, aA2) {\n            return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n        }\n        function getSlope(aT, aA1, aA2) {\n            return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);\n        }\n        function generateBezier(mX1, mY1, mX2, mY2) {\n            var NEWTON_ITERATIONS = 4, NEWTON_MIN_SLOPE = .001, SUBDIVISION_PRECISION = 1e-7, SUBDIVISION_MAX_ITERATIONS = 10, kSplineTableSize = 11, kSampleStepSize = 1 / (kSplineTableSize - 1), float32ArraySupported = \"Float32Array\" in window;\n            /* Must contain four arguments. */            if (arguments.length !== 4) {\n                return;\n            }\n            /* Arguments must be numbers. */            for (var i = 0; i < 4; ++i) {\n                if (typeof arguments[i] !== \"number\" || isNaN(arguments[i]) || !isFinite(arguments[i])) {\n                    return;\n                }\n            }\n            /* X values must be in the [0, 1] range. */            mX1 = fixRange(mX1);\n            mX2 = fixRange(mX2);\n            var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n            function newtonRaphsonIterate(aX, aGuessT) {\n                for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n                    var currentSlope = getSlope(aGuessT, mX1, mX2);\n                    if (currentSlope === 0) {\n                        return aGuessT;\n                    }\n                    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n                    aGuessT -= currentX / currentSlope;\n                }\n                return aGuessT;\n            }\n            function calcSampleValues() {\n                for (var i = 0; i < kSplineTableSize; ++i) {\n                    mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n                }\n            }\n            function binarySubdivide(aX, aA, aB) {\n                var currentX, currentT, i = 0;\n                do {\n                    currentT = aA + (aB - aA) / 2;\n                    currentX = calcBezier(currentT, mX1, mX2) - aX;\n                    if (currentX > 0) {\n                        aB = currentT;\n                    } else {\n                        aA = currentT;\n                    }\n                } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n                return currentT;\n            }\n            function getTForX(aX) {\n                var intervalStart = 0, currentSample = 1, lastSample = kSplineTableSize - 1;\n                for (;currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\n                    intervalStart += kSampleStepSize;\n                }\n                --currentSample;\n                var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]), guessForT = intervalStart + dist * kSampleStepSize, initialSlope = getSlope(guessForT, mX1, mX2);\n                if (initialSlope >= NEWTON_MIN_SLOPE) {\n                    return newtonRaphsonIterate(aX, guessForT);\n                } else if (initialSlope === 0) {\n                    return guessForT;\n                } else {\n                    return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\n                }\n            }\n            var _precomputed = false;\n            function precompute() {\n                _precomputed = true;\n                if (mX1 !== mY1 || mX2 !== mY2) {\n                    calcSampleValues();\n                }\n            }\n            var f = function(percentComplete, startValue, endValue, property) {\n                if (!_precomputed) {\n                    precompute();\n                }\n                if (percentComplete === 0) {\n                    return startValue;\n                }\n                if (percentComplete === 1) {\n                    return endValue;\n                }\n                if (mX1 === mY1 && mX2 === mY2) {\n                    return startValue + percentComplete * (endValue - startValue);\n                }\n                return startValue + calcBezier(getTForX(percentComplete), mY1, mY2) * (endValue - startValue);\n            };\n            f.getControlPoints = function() {\n                return [ {\n                    x: mX1,\n                    y: mY1\n                }, {\n                    x: mX2,\n                    y: mY2\n                } ];\n            };\n            var str = \"generateBezier(\" + [ mX1, mY1, mX2, mY2 ] + \")\";\n            f.toString = function() {\n                return str;\n            };\n            return f;\n        }\n        Easing.generateBezier = generateBezier;\n        /* Common easings */        var easeIn = generateBezier(.42, 0, 1, 1), easeOut = generateBezier(0, 0, .58, 1), easeInOut = generateBezier(.42, 0, .58, 1);\n        Easing.registerEasing([ \"ease\", generateBezier(.25, .1, .25, 1) ]);\n        Easing.registerEasing([ \"easeIn\", easeIn ]);\n        Easing.registerEasing([ \"ease-in\", easeIn ]);\n        Easing.registerEasing([ \"easeOut\", easeOut ]);\n        Easing.registerEasing([ \"ease-out\", easeOut ]);\n        Easing.registerEasing([ \"easeInOut\", easeInOut ]);\n        Easing.registerEasing([ \"ease-in-out\", easeInOut ]);\n        Easing.registerEasing([ \"easeInSine\", generateBezier(.47, 0, .745, .715) ]);\n        Easing.registerEasing([ \"easeOutSine\", generateBezier(.39, .575, .565, 1) ]);\n        Easing.registerEasing([ \"easeInOutSine\", generateBezier(.445, .05, .55, .95) ]);\n        Easing.registerEasing([ \"easeInQuad\", generateBezier(.55, .085, .68, .53) ]);\n        Easing.registerEasing([ \"easeOutQuad\", generateBezier(.25, .46, .45, .94) ]);\n        Easing.registerEasing([ \"easeInOutQuad\", generateBezier(.455, .03, .515, .955) ]);\n        Easing.registerEasing([ \"easeInCubic\", generateBezier(.55, .055, .675, .19) ]);\n        Easing.registerEasing([ \"easeOutCubic\", generateBezier(.215, .61, .355, 1) ]);\n        Easing.registerEasing([ \"easeInOutCubic\", generateBezier(.645, .045, .355, 1) ]);\n        Easing.registerEasing([ \"easeInQuart\", generateBezier(.895, .03, .685, .22) ]);\n        Easing.registerEasing([ \"easeOutQuart\", generateBezier(.165, .84, .44, 1) ]);\n        Easing.registerEasing([ \"easeInOutQuart\", generateBezier(.77, 0, .175, 1) ]);\n        Easing.registerEasing([ \"easeInQuint\", generateBezier(.755, .05, .855, .06) ]);\n        Easing.registerEasing([ \"easeOutQuint\", generateBezier(.23, 1, .32, 1) ]);\n        Easing.registerEasing([ \"easeInOutQuint\", generateBezier(.86, 0, .07, 1) ]);\n        Easing.registerEasing([ \"easeInExpo\", generateBezier(.95, .05, .795, .035) ]);\n        Easing.registerEasing([ \"easeOutExpo\", generateBezier(.19, 1, .22, 1) ]);\n        Easing.registerEasing([ \"easeInOutExpo\", generateBezier(1, 0, 0, 1) ]);\n        Easing.registerEasing([ \"easeInCirc\", generateBezier(.6, .04, .98, .335) ]);\n        Easing.registerEasing([ \"easeOutCirc\", generateBezier(.075, .82, .165, 1) ]);\n        Easing.registerEasing([ \"easeInOutCirc\", generateBezier(.785, .135, .15, .86) ]);\n    })(Easing = VelocityStatic.Easing || (VelocityStatic.Easing = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"easings.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Bounce easings, based on code from https://github.com/yuichiroharai/easeplus-velocity\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    var Easing;\n    (function(Easing) {\n        function easeOutBounce(percentComplete) {\n            if (percentComplete < 1 / 2.75) {\n                return 7.5625 * percentComplete * percentComplete;\n            }\n            if (percentComplete < 2 / 2.75) {\n                return 7.5625 * (percentComplete -= 1.5 / 2.75) * percentComplete + .75;\n            }\n            if (percentComplete < 2.5 / 2.75) {\n                return 7.5625 * (percentComplete -= 2.25 / 2.75) * percentComplete + .9375;\n            }\n            return 7.5625 * (percentComplete -= 2.625 / 2.75) * percentComplete + .984375;\n        }\n        function easeInBounce(percentComplete) {\n            return 1 - easeOutBounce(1 - percentComplete);\n        }\n        Easing.registerEasing([ \"easeInBounce\", function(percentComplete, startValue, endValue) {\n            if (percentComplete === 0) {\n                return startValue;\n            }\n            if (percentComplete === 1) {\n                return endValue;\n            }\n            return easeInBounce(percentComplete) * (endValue - startValue);\n        } ]);\n        Easing.registerEasing([ \"easeOutBounce\", function(percentComplete, startValue, endValue) {\n            if (percentComplete === 0) {\n                return startValue;\n            }\n            if (percentComplete === 1) {\n                return endValue;\n            }\n            return easeOutBounce(percentComplete) * (endValue - startValue);\n        } ]);\n        Easing.registerEasing([ \"easeInOutBounce\", function(percentComplete, startValue, endValue) {\n            if (percentComplete === 0) {\n                return startValue;\n            }\n            if (percentComplete === 1) {\n                return endValue;\n            }\n            return (percentComplete < .5 ? easeInBounce(percentComplete * 2) * .5 : easeOutBounce(percentComplete * 2 - 1) * .5 + .5) * (endValue - startValue);\n        } ]);\n    })(Easing = VelocityStatic.Easing || (VelocityStatic.Easing = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"easings.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Elastic easings, based on code from https://github.com/yuichiroharai/easeplus-velocity\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    var Easing;\n    (function(Easing) {\n        var pi2 = Math.PI * 2;\n        function registerElasticIn(name, amplitude, period) {\n            Easing.registerEasing([ name, function(percentComplete, startValue, endValue) {\n                if (percentComplete === 0) {\n                    return startValue;\n                }\n                if (percentComplete === 1) {\n                    return endValue;\n                }\n                return -(amplitude * Math.pow(2, 10 * (percentComplete -= 1)) * Math.sin((percentComplete - period / pi2 * Math.asin(1 / amplitude)) * pi2 / period)) * (endValue - startValue);\n            } ]);\n        }\n        Easing.registerElasticIn = registerElasticIn;\n        function registerElasticOut(name, amplitude, period) {\n            Easing.registerEasing([ name, function(percentComplete, startValue, endValue) {\n                if (percentComplete === 0) {\n                    return startValue;\n                }\n                if (percentComplete === 1) {\n                    return endValue;\n                }\n                return (amplitude * Math.pow(2, -10 * percentComplete) * Math.sin((percentComplete - period / pi2 * Math.asin(1 / amplitude)) * pi2 / period) + 1) * (endValue - startValue);\n            } ]);\n        }\n        Easing.registerElasticOut = registerElasticOut;\n        function registerElasticInOut(name, amplitude, period) {\n            Easing.registerEasing([ name, function(percentComplete, startValue, endValue) {\n                if (percentComplete === 0) {\n                    return startValue;\n                }\n                if (percentComplete === 1) {\n                    return endValue;\n                }\n                var s = period / pi2 * Math.asin(1 / amplitude);\n                percentComplete = percentComplete * 2 - 1;\n                return (percentComplete < 0 ? -.5 * (amplitude * Math.pow(2, 10 * percentComplete) * Math.sin((percentComplete - s) * pi2 / period)) : amplitude * Math.pow(2, -10 * percentComplete) * Math.sin((percentComplete - s) * pi2 / period) * .5 + 1) * (endValue - startValue);\n            } ]);\n        }\n        Easing.registerElasticInOut = registerElasticInOut;\n        registerElasticIn(\"easeInElastic\", 1, .3);\n        registerElasticOut(\"easeOutElastic\", 1, .3);\n        registerElasticInOut(\"easeInOutElastic\", 1, .3 * 1.5);\n        // TODO: Expose these as actions to register custom easings?\n        })(Easing = VelocityStatic.Easing || (VelocityStatic.Easing = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"easings.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    var Easing;\n    (function(Easing) {\n        /* Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */\n        /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass\n         then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */\n        function springAccelerationForState(state) {\n            return -state.tension * state.x - state.friction * state.v;\n        }\n        function springEvaluateStateWithDerivative(initialState, dt, derivative) {\n            var state = {\n                x: initialState.x + derivative.dx * dt,\n                v: initialState.v + derivative.dv * dt,\n                tension: initialState.tension,\n                friction: initialState.friction\n            };\n            return {\n                dx: state.v,\n                dv: springAccelerationForState(state)\n            };\n        }\n        function springIntegrateState(state, dt) {\n            var a = {\n                dx: state.v,\n                dv: springAccelerationForState(state)\n            }, b = springEvaluateStateWithDerivative(state, dt * .5, a), c = springEvaluateStateWithDerivative(state, dt * .5, b), d = springEvaluateStateWithDerivative(state, dt, c), dxdt = 1 / 6 * (a.dx + 2 * (b.dx + c.dx) + d.dx), dvdt = 1 / 6 * (a.dv + 2 * (b.dv + c.dv) + d.dv);\n            state.x = state.x + dxdt * dt;\n            state.v = state.v + dvdt * dt;\n            return state;\n        }\n        function generateSpringRK4(tension, friction, duration) {\n            var initState = {\n                x: -1,\n                v: 0,\n                tension: parseFloat(tension) || 500,\n                friction: parseFloat(friction) || 20\n            }, path = [ 0 ], time_lapsed = 0, tolerance = 1 / 1e4, DT = 16 / 1e3, have_duration = duration != null, // deliberate \"==\", as undefined == null != 0\n            dt, last_state;\n            /* Calculate the actual time it takes for this animation to complete with the provided conditions. */            if (have_duration) {\n                /* Run the simulation without a duration. */\n                time_lapsed = generateSpringRK4(initState.tension, initState.friction);\n                /* Compute the adjusted time delta. */                dt = time_lapsed / duration * DT;\n            } else {\n                dt = DT;\n            }\n            while (true) {\n                /* Next/step function .*/\n                last_state = springIntegrateState(last_state || initState, dt);\n                /* Store the position. */                path.push(1 + last_state.x);\n                time_lapsed += 16;\n                /* If the change threshold is reached, break. */                if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {\n                    break;\n                }\n            }\n            /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the\n             computed path and returns a snapshot of the position according to a given percentComplete. */            return !have_duration ? time_lapsed : function(percentComplete, startValue, endValue) {\n                if (percentComplete === 0) {\n                    return startValue;\n                }\n                if (percentComplete === 1) {\n                    return endValue;\n                }\n                return startValue + path[percentComplete * (path.length - 1) | 0] * (endValue - startValue);\n            };\n        }\n        Easing.generateSpringRK4 = generateSpringRK4;\n    })(Easing = VelocityStatic.Easing || (VelocityStatic.Easing = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"easings.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details\n *\n * Step easing generator.\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    var Easing;\n    (function(Easing) {\n        var cache = {};\n        function generateStep(steps) {\n            var fn = cache[steps];\n            if (fn) {\n                return fn;\n            }\n            return cache[steps] = function(percentComplete, startValue, endValue) {\n                if (percentComplete === 0) {\n                    return startValue;\n                }\n                if (percentComplete === 1) {\n                    return endValue;\n                }\n                return startValue + Math.round(percentComplete * steps) * (1 / steps) * (endValue - startValue);\n            };\n        }\n        Easing.generateStep = generateStep;\n    })(Easing = VelocityStatic.Easing || (VelocityStatic.Easing = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"easings.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Easings to act on strings, either set at the start or at the end depending on\n * need.\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    var Easing;\n    (function(Easing) {\n        /**\n         * Easing function that sets to the specified value immediately after the\n         * animation starts.\n         */\n        Easing.registerEasing([ \"at-start\", function(percentComplete, startValue, endValue) {\n            return percentComplete === 0 ? startValue : endValue;\n        } ]);\n        /**\n         * Easing function that sets to the specified value while the animation is\n         * running.\n         */        Easing.registerEasing([ \"during\", function(percentComplete, startValue, endValue) {\n            return percentComplete === 0 || percentComplete === 1 ? startValue : endValue;\n        } ]);\n        /**\n         * Easing function that sets to the specified value when the animation ends.\n         */        Easing.registerEasing([ \"at-end\", function(percentComplete, startValue, endValue) {\n            return percentComplete === 1 ? endValue : startValue;\n        } ]);\n    })(Easing = VelocityStatic.Easing || (VelocityStatic.Easing = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"../actions/_all.d.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Normalisations are used when getting or setting a (normally css compound\n * properties) value that can have a different order in different browsers.\n *\n * It can also be used to extend and create specific properties that otherwise\n * don't exist (such as for scrolling, or inner/outer dimensions).\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * The highest type index for finding the best normalization for a property.\n     */\n    VelocityStatic.MaxType = -1;\n    /**\n     * Unlike \"actions\", normalizations can always be replaced by users.\n     */    VelocityStatic.Normalizations = [];\n    /**\n     * Store a cross-reference to units to be added to specific normalization\n     * functions if the user supplies a unit-less number.\n     *\n     * This is pretty much confined to adding \"px\" to several css properties.\n     */    VelocityStatic.NormalizationUnits = createEmptyObject();\n    /**\n     * Any normalisations that should never be cached are listed here.\n     * Faster than an array - https://jsperf.com/array-includes-and-find-methods-vs-set-has\n     */    VelocityStatic.NoCacheNormalizations = new Set();\n    /**\n     * An array of classes used for the per-class normalizations. This\n     * translates into a bitwise enum for quick cross-reference, and so that\n     * the element doesn't need multiple <code>instanceof</code> calls every\n     * frame.\n     */    VelocityStatic.constructors = [];\n    /**\n     * Used to register a normalization. This should never be called by users\n     * directly, instead it should be called via an action:<br/>\n     * <code>Velocity(\"registerNormalization\", Element, \"name\", VelocityNormalizationsFn[, false]);</code>\n     *\n     * The fourth argument can be an explicit <code>false</code>, which prevents\n     * the property from being cached. Please note that this can be dangerous\n     * for performance!\n     *\n     * @private\n     */    function registerNormalization(args) {\n        var constructor = args[0], name = args[1], callback = args[2];\n        if (isString(constructor) || !(constructor instanceof Object)) {\n            console.warn(\"VelocityJS: Trying to set 'registerNormalization' constructor to an invalid value:\", constructor);\n        } else if (!isString(name)) {\n            console.warn(\"VelocityJS: Trying to set 'registerNormalization' name to an invalid value:\", name);\n        } else if (!isFunction(callback)) {\n            console.warn(\"VelocityJS: Trying to set 'registerNormalization' callback to an invalid value:\", name, callback);\n        } else {\n            var index = VelocityStatic.constructors.indexOf(constructor), nextArg = 3;\n            if (index < 0) {\n                VelocityStatic.MaxType = index = VelocityStatic.constructors.push(constructor) - 1;\n                VelocityStatic.Normalizations[index] = createEmptyObject();\n            }\n            VelocityStatic.Normalizations[index][name] = callback;\n            if (isString(args[nextArg])) {\n                var unit = args[nextArg++], units = VelocityStatic.NormalizationUnits[unit];\n                if (!units) {\n                    units = VelocityStatic.NormalizationUnits[unit] = [];\n                }\n                units.push(callback);\n            }\n            if (args[nextArg] === false) {\n                VelocityStatic.NoCacheNormalizations.add(name);\n            }\n        }\n    }\n    VelocityStatic.registerNormalization = registerNormalization;\n    /**\n     * Used to check if a normalisation exists on a specific class.\n     */    function hasNormalization(args) {\n        var constructor = args[0], name = args[1];\n        var index = VelocityStatic.constructors.indexOf(constructor);\n        return !!VelocityStatic.Normalizations[index][name];\n    }\n    VelocityStatic.hasNormalization = hasNormalization;\n    /**\n     * Get the unit to add to a unitless number based on the normalization used.\n     */    function getNormalizationUnit(fn) {\n        for (var unit in VelocityStatic.NormalizationUnits) {\n            if (_inArray(VelocityStatic.NormalizationUnits[unit], fn)) {\n                return unit;\n            }\n        }\n        return \"\";\n    }\n    VelocityStatic.getNormalizationUnit = getNormalizationUnit;\n    /**\n     * Get the normalization for an element and propertyName combination. This\n     * value should be cached at asking time, as it may change if the user adds\n     * more normalizations.\n     */    function getNormalization(element, propertyName) {\n        var data = Data(element);\n        var fn;\n        for (var index = VelocityStatic.MaxType, types = data.types; !fn && index >= 0; index--) {\n            if (types & 1 << index) {\n                fn = VelocityStatic.Normalizations[index][propertyName];\n            }\n        }\n        return fn;\n    }\n    VelocityStatic.getNormalization = getNormalization;\n    VelocityStatic.registerAction([ \"registerNormalization\", registerNormalization ]);\n    VelocityStatic.registerAction([ \"hasNormalization\", hasNormalization ]);\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"../normalizations.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    var CSS;\n    (function(CSS) {\n        /**\n         * Get/set an attribute.\n         */\n        function getAttribute(name) {\n            return function(element, propertyValue) {\n                if (propertyValue === undefined) {\n                    return element.getAttribute(name);\n                }\n                element.setAttribute(name, propertyValue);\n            };\n        }\n        var base = document.createElement(\"div\"), rxSubtype = /^SVG(.*)Element$/, rxElement = /Element$/;\n        Object.getOwnPropertyNames(window).forEach(function(globals) {\n            var subtype = rxSubtype.exec(globals);\n            if (subtype && subtype[1] !== \"SVG\") {\n                try {\n                    var element = subtype[1] ? document.createElementNS(\"http://www.w3.org/2000/svg\", (subtype[1] || \"svg\").toLowerCase()) : document.createElement(\"svg\"), constructor = element.constructor;\n                    for (var attribute in element) {\n                        var value = element[attribute];\n                        if (isString(attribute) && !(attribute[0] === \"o\" && attribute[1] === \"n\") && attribute !== attribute.toUpperCase() && !rxElement.test(attribute) && !(attribute in base) && !isFunction(value)) {\n                            // TODO: Should this all be set on the generic SVGElement, it would save space and time, but not as powerful\n                            VelocityStatic.registerNormalization([ constructor, attribute, getAttribute(attribute) ]);\n                        }\n                    }\n                } catch (e) {\n                    console.error(\"VelocityJS: Error when trying to identify SVG attributes on \" + globals + \".\", e);\n                }\n            }\n        });\n    })(CSS = VelocityStatic.CSS || (VelocityStatic.CSS = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"../normalizations.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    var CSS;\n    (function(CSS) {\n        /**\n         * Get/set the width or height.\n         */\n        function getDimension(name) {\n            return function(element, propertyValue) {\n                if (propertyValue === undefined) {\n                    // Firefox throws an error if .getBBox() is called on an SVG that isn't attached to the DOM.\n                    try {\n                        return element.getBBox()[name] + \"px\";\n                    } catch (e) {\n                        return \"0px\";\n                    }\n                }\n                element.setAttribute(name, propertyValue);\n            };\n        }\n        VelocityStatic.registerNormalization([ SVGElement, \"width\", getDimension(\"width\") ]);\n        VelocityStatic.registerNormalization([ SVGElement, \"height\", getDimension(\"height\") ]);\n    })(CSS = VelocityStatic.CSS || (VelocityStatic.CSS = {}));\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"normalizations.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * Figure out the dimensions for this width / height based on the\n     * potential borders and whether we care about them.\n     */\n    function augmentDimension(element, name, wantInner) {\n        var isBorderBox = VelocityStatic.CSS.getPropertyValue(element, \"boxSizing\").toString().toLowerCase() === \"border-box\";\n        if (isBorderBox === wantInner) {\n            // in box-sizing mode, the CSS width / height accessors already\n            // give the outerWidth / outerHeight.\n            var sides = name === \"width\" ? [ \"Left\", \"Right\" ] : [ \"Top\", \"Bottom\" ], fields = [ \"padding\" + sides[0], \"padding\" + sides[1], \"border\" + sides[0] + \"Width\", \"border\" + sides[1] + \"Width\" ];\n            var i = void 0, value = void 0, augment = 0;\n            for (i = 0; i < fields.length; i++) {\n                value = parseFloat(VelocityStatic.CSS.getPropertyValue(element, fields[i]));\n                if (!isNaN(value)) {\n                    augment += value;\n                }\n            }\n            return wantInner ? -augment : augment;\n        }\n        return 0;\n    }\n    VelocityStatic.augmentDimension = augmentDimension;\n    /**\n     * Get/set the inner/outer dimension.\n     */    function getDimension(name, wantInner) {\n        return function(element, propertyValue) {\n            if (propertyValue === undefined) {\n                return augmentDimension(element, name, wantInner) + \"px\";\n            }\n            VelocityStatic.CSS.setPropertyValue(element, name, parseFloat(propertyValue) - augmentDimension(element, name, wantInner) + \"px\");\n        };\n    }\n    VelocityStatic.registerNormalization([ Element, \"innerWidth\", getDimension(\"width\", true) ]);\n    VelocityStatic.registerNormalization([ Element, \"innerHeight\", getDimension(\"height\", true) ]);\n    VelocityStatic.registerNormalization([ Element, \"outerWidth\", getDimension(\"width\", false) ]);\n    VelocityStatic.registerNormalization([ Element, \"outerHeight\", getDimension(\"height\", false) ]);\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"normalizations.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    VelocityStatic.inlineRx = /^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|let|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i,\n    VelocityStatic.listItemRx = /^(li)$/i, VelocityStatic.tableRowRx = /^(tr)$/i, VelocityStatic.tableRx = /^(table)$/i,\n    VelocityStatic.tableRowGroupRx = /^(tbody)$/i;\n    function display(element, propertyValue) {\n        var style = element.style;\n        if (propertyValue === undefined) {\n            return VelocityStatic.CSS.computePropertyValue(element, \"display\");\n        }\n        if (propertyValue === \"auto\") {\n            var nodeName = element && element.nodeName, data = Data(element);\n            if (VelocityStatic.inlineRx.test(nodeName)) {\n                propertyValue = \"inline\";\n            } else if (VelocityStatic.listItemRx.test(nodeName)) {\n                propertyValue = \"list-item\";\n            } else if (VelocityStatic.tableRowRx.test(nodeName)) {\n                propertyValue = \"table-row\";\n            } else if (VelocityStatic.tableRx.test(nodeName)) {\n                propertyValue = \"table\";\n            } else if (VelocityStatic.tableRowGroupRx.test(nodeName)) {\n                propertyValue = \"table-row-group\";\n            } else {\n                // Default to \"block\" when no match is found.\n                propertyValue = \"block\";\n            }\n            // IMPORTANT: We need to do this as getPropertyValue bypasses the\n            // Normalisation when it exists in the cache.\n                        data.cache[\"display\"] = propertyValue;\n        }\n        style.display = propertyValue;\n    }\n    VelocityStatic.registerNormalization([ Element, \"display\", display ]);\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"normalizations.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    function clientWidth(element, propertyValue) {\n        if (propertyValue == null) {\n            return element.clientWidth + \"px\";\n        }\n    }\n    function scrollWidth(element, propertyValue) {\n        if (propertyValue == null) {\n            return element.scrollWidth + \"px\";\n        }\n    }\n    function clientHeight(element, propertyValue) {\n        if (propertyValue == null) {\n            return element.clientHeight + \"px\";\n        }\n    }\n    function scrollHeight(element, propertyValue) {\n        if (propertyValue == null) {\n            return element.scrollHeight + \"px\";\n        }\n    }\n    function scroll(direction, end) {\n        return function(element, propertyValue) {\n            if (propertyValue == null) {\n                // Make sure we have these values cached.\n                VelocityStatic.CSS.getPropertyValue(element, \"client\" + direction, null, true);\n                VelocityStatic.CSS.getPropertyValue(element, \"scroll\" + direction, null, true);\n                VelocityStatic.CSS.getPropertyValue(element, \"scroll\" + end, null, true);\n                return element[\"scroll\" + end] + \"px\";\n            }\n            //\t\tconsole.log(\"setScrollTop\", propertyValue)\n                        var value = parseFloat(propertyValue), unit = propertyValue.replace(String(value), \"\");\n            switch (unit) {\n              case \"\":\n              case \"px\":\n                element[\"scroll\" + end] = value;\n                break;\n\n              case \"%\":\n                var client = parseFloat(VelocityStatic.CSS.getPropertyValue(element, \"client\" + direction)), scroll_1 = parseFloat(VelocityStatic.CSS.getPropertyValue(element, \"scroll\" + direction));\n                //\t\t\t\tconsole.log(\"setScrollTop percent\", scrollHeight, clientHeight, value, Math.max(0, scrollHeight - clientHeight) * value / 100)\n                                element[\"scroll\" + end] = Math.max(0, scroll_1 - client) * value / 100;\n            }\n        };\n    }\n    VelocityStatic.registerNormalization([ HTMLElement, \"scroll\", scroll(\"Height\", \"Top\"), false ]);\n    VelocityStatic.registerNormalization([ HTMLElement, \"scrollTop\", scroll(\"Height\", \"Top\"), false ]);\n    VelocityStatic.registerNormalization([ HTMLElement, \"scrollLeft\", scroll(\"Width\", \"Left\"), false ]);\n    VelocityStatic.registerNormalization([ HTMLElement, \"scrollWidth\", scrollWidth ]);\n    VelocityStatic.registerNormalization([ HTMLElement, \"clientWidth\", clientWidth ]);\n    VelocityStatic.registerNormalization([ HTMLElement, \"scrollHeight\", scrollHeight ]);\n    VelocityStatic.registerNormalization([ HTMLElement, \"clientHeight\", clientHeight ]);\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"normalizations.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * This handles all CSS style properties. With browser prefixed properties it\n * will register a version that handles setting (and getting) both the prefixed\n * and non-prefixed version.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * An RegExp pattern for the following list of css words using\n     * http://kemio.com.ar/tools/lst-trie-re.php to generate:\n     *\n     * blockSize\n     * borderBottomLeftRadius\n     * borderBottomRightRadius\n     * borderBottomWidth\n     * borderImageOutset\n     * borderImageWidth\n     * borderLeftWidth\n     * borderRadius\n     * borderRightWidth\n     * borderSpacing\n     * borderTopLeftRadius\n     * borderTopRightRadius\n     * borderTopWidth\n     * borderWidth\n     * bottom\n     * columnGap\n     * columnRuleWidth\n     * columnWidth\n     * flexBasis\n     * fontSize\n     * gridColumnGap\n     * gridGap\n     * gridRowGap\n     * height\n     * inlineSize\n     * left\n     * letterSpacing\n     * margin\n     * marginBottom\n     * marginLeft\n     * marginRight\n     * marginTop\n     * maxBlockSize\n     * maxHeight\n     * maxInlineSize\n     * maxWidth\n     * minBlockSize\n     * minHeight\n     * minInlineSize\n     * minWidth\n     * objectPosition\n     * outlineOffset\n     * outlineWidth\n     * padding\n     * paddingBottom\n     * paddingLeft\n     * paddingRight\n     * paddingTop\n     * perspective\n     * right\n     * shapeMargin\n     * strokeDashoffset\n     * strokeWidth\n     * textIndent\n     * top\n     * transformOrigin\n     * width\n     * wordSpacing\n     */\n    var rxAddPx = /^(b(lockSize|o(rder(Bottom(LeftRadius|RightRadius|Width)|Image(Outset|Width)|LeftWidth|R(adius|ightWidth)|Spacing|Top(LeftRadius|RightRadius|Width)|Width)|ttom))|column(Gap|RuleWidth|Width)|f(lexBasis|ontSize)|grid(ColumnGap|Gap|RowGap)|height|inlineSize|le(ft|tterSpacing)|m(a(rgin(Bottom|Left|Right|Top)|x(BlockSize|Height|InlineSize|Width))|in(BlockSize|Height|InlineSize|Width))|o(bjectPosition|utline(Offset|Width))|p(adding(Bottom|Left|Right|Top)|erspective)|right|s(hapeMargin|troke(Dashoffset|Width))|t(extIndent|op|ransformOrigin)|w(idth|ordSpacing))$/;\n    /**\n     * Return a Normalisation that can be used to set / get a prefixed style\n     * property.\n     */    function getSetPrefixed(propertyName, unprefixed) {\n        return function(element, propertyValue) {\n            if (propertyValue === undefined) {\n                return VelocityStatic.CSS.computePropertyValue(element, propertyName) || VelocityStatic.CSS.computePropertyValue(element, unprefixed);\n            }\n            element.style[propertyName] = element.style[unprefixed] = propertyValue;\n        };\n    }\n    /**\n     * Return a Normalisation that can be used to set / get a style property.\n     */    function getSetStyle(propertyName) {\n        return function(element, propertyValue) {\n            if (propertyValue === undefined) {\n                return VelocityStatic.CSS.computePropertyValue(element, propertyName);\n            }\n            element.style[propertyName] = propertyValue;\n        };\n    }\n    /**\n     * Vendor prefixes. Chrome / Safari, Firefox, IE / Edge, Opera.\n     */    var rxVendors = /^(webkit|moz|ms|o)[A-Z]/, prefixElement = VelocityStatic.State.prefixElement;\n    for (var propertyName in prefixElement.style) {\n        if (rxVendors.test(propertyName)) {\n            var unprefixed = propertyName.replace(/^[a-z]+([A-Z])/, function($, letter) {\n                return letter.toLowerCase();\n            });\n            if (ALL_VENDOR_PREFIXES || isString(prefixElement.style[unprefixed])) {\n                var addUnit = rxAddPx.test(unprefixed) ? \"px\" : undefined;\n                VelocityStatic.registerNormalization([ Element, unprefixed, getSetPrefixed(propertyName, unprefixed), addUnit ]);\n            }\n        } else if (!VelocityStatic.hasNormalization([ Element, propertyName ])) {\n            var addUnit = rxAddPx.test(propertyName) ? \"px\" : undefined;\n            VelocityStatic.registerNormalization([ Element, propertyName, getSetStyle(propertyName), addUnit ]);\n        }\n    }\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"normalizations.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * A fake normalization used to allow the \"tween\" property easy access.\n     */\n    function getSetTween(element, propertyValue) {\n        if (propertyValue === undefined) {\n            return \"\";\n        }\n    }\n    VelocityStatic.registerNormalization([ Element, \"tween\", getSetTween ]);\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Call Completion\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * Call the complete method of an animation in a separate function so it can\n     * benefit from JIT compiling while still having a try/catch block.\n     */\n    function callComplete(activeCall) {\n        try {\n            var elements = activeCall.elements;\n            activeCall.options.complete.call(elements, elements, activeCall);\n        } catch (error) {\n            setTimeout(function() {\n                throw error;\n            }, 1);\n        }\n    }\n    /**\n     * Complete an animation. This might involve restarting (for loop or repeat\n     * options). Once it is finished we also check for any callbacks or Promises\n     * that need updating.\n     */    function completeCall(activeCall) {\n        //\t\tconsole.log(\"complete\", activeCall)\n        // TODO: Check if it's not been completed already\n        var options = activeCall.options, queue = getValue(activeCall.queue, options.queue), isLoop = getValue(activeCall.loop, options.loop, VelocityStatic.defaults.loop), isRepeat = getValue(activeCall.repeat, options.repeat, VelocityStatic.defaults.repeat), isStopped = activeCall._flags & 8 /* STOPPED */;\n        if (!isStopped && (isLoop || isRepeat)) {\n            ////////////////////\n            // Option: Loop   //\n            // Option: Repeat //\n            ////////////////////\n            if (isRepeat && isRepeat !== true) {\n                activeCall.repeat = isRepeat - 1;\n            } else if (isLoop && isLoop !== true) {\n                activeCall.loop = isLoop - 1;\n                activeCall.repeat = getValue(activeCall.repeatAgain, options.repeatAgain, VelocityStatic.defaults.repeatAgain);\n            }\n            if (isLoop) {\n                activeCall._flags ^= 64 /* REVERSE */;\n            }\n            if (queue !== false) {\n                // Can't be called when stopped so no need for an extra check.\n                Data(activeCall.element).lastFinishList[queue] = activeCall.timeStart + getValue(activeCall.duration, options.duration, VelocityStatic.defaults.duration);\n            }\n            activeCall.timeStart = activeCall.ellapsedTime = activeCall.percentComplete = 0;\n            activeCall._flags &= ~4 /* STARTED */;\n        } else {\n            var element = activeCall.element, data = Data(element);\n            if (!--data.count && !isStopped) {\n                ////////////////////////\n                // Feature: Classname //\n                ////////////////////////\n                removeClass(element, VelocityStatic.State.className);\n            }\n            //////////////////////\n            // Option: Complete //\n            //////////////////////\n            // If this is the last animation in this list then we can check for\n            // and complete calls or Promises.\n            // TODO: When deleting an element we need to adjust these values.\n                        if (options && ++options._completed === options._total) {\n                if (!isStopped && options.complete) {\n                    // We don't call the complete if the animation is stopped,\n                    // and we clear the key to prevent it being called again.\n                    callComplete(activeCall);\n                    options.complete = null;\n                }\n                var resolver = options._resolver;\n                if (resolver) {\n                    // Fulfil the Promise\n                    resolver(activeCall.elements);\n                    delete options._resolver;\n                }\n            }\n            ///////////////////\n            // Option: Queue //\n            ///////////////////\n                        if (queue !== false) {\n                // We only do clever things with queues...\n                if (!isStopped) {\n                    // If we're not stopping an animation, we need to remember\n                    // what time it finished so that the next animation in\n                    // sequence gets the correct start time.\n                    data.lastFinishList[queue] = activeCall.timeStart + getValue(activeCall.duration, options.duration, VelocityStatic.defaults.duration);\n                }\n                // Start the next animation in sequence, or delete the queue if\n                // this was the last one.\n                                VelocityStatic.dequeue(element, queue);\n            }\n            // Cleanup any pointers, and remember the last animation etc.\n                        VelocityStatic.freeAnimationCall(activeCall);\n        }\n    }\n    VelocityStatic.completeCall = completeCall;\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */\n/**\n * Get (and create) the internal data store for an element.\n */\nfunction Data(element) {\n    // Use a string member so Uglify doesn't mangle it.\n    var data = element[\"velocityData\"];\n    if (data) {\n        return data;\n    }\n    var types = 0;\n    for (var index = 0, constructors = VelocityStatic.constructors; index < constructors.length; index++) {\n        if (element instanceof constructors[index]) {\n            types |= 1 << index;\n        }\n    }\n    // Do it this way so it errors on incorrect data.\n        var newData = {\n        types: types,\n        count: 0,\n        computedStyle: null,\n        cache: createEmptyObject(),\n        queueList: createEmptyObject(),\n        lastAnimationList: createEmptyObject(),\n        lastFinishList: createEmptyObject()\n    };\n    Object.defineProperty(element, \"velocityData\", {\n        value: newData\n    });\n    return newData;\n}\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * Set to true, 1 or 2 (most verbose) to output debug info to console.\n     */\n    VelocityStatic.debug = false;\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Velocity option defaults, which can be overriden by the user.\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    // NOTE: Add the variable here, then add the default state in \"reset\" below.\n    var _cache, _begin, _complete, _delay, _duration, _easing, _fpsLimit, _loop, _minFrameTime, _promise, _promiseRejectEmpty, _queue, _repeat, _speed, _sync;\n    VelocityStatic.defaults = {\n        mobileHA: true\n    };\n    // IMPORTANT: Make sure any new defaults get added to the actions/set.ts list\n        Object.defineProperties(VelocityStatic.defaults, {\n        reset: {\n            enumerable: true,\n            value: function() {\n                _cache = DEFAULT_CACHE;\n                _begin = undefined;\n                _complete = undefined;\n                _delay = DEFAULT_DELAY;\n                _duration = DEFAULT_DURATION;\n                _easing = validateEasing(DEFAULT_EASING, DEFAULT_DURATION);\n                _fpsLimit = DEFAULT_FPSLIMIT;\n                _loop = DEFAULT_LOOP;\n                _minFrameTime = FUZZY_MS_PER_SECOND / DEFAULT_FPSLIMIT;\n                _promise = DEFAULT_PROMISE;\n                _promiseRejectEmpty = DEFAULT_PROMISE_REJECT_EMPTY;\n                _queue = DEFAULT_QUEUE;\n                _repeat = DEFAULT_REPEAT;\n                _speed = DEFAULT_SPEED;\n                _sync = DEFAULT_SYNC;\n            }\n        },\n        cache: {\n            enumerable: true,\n            get: function() {\n                return _cache;\n            },\n            set: function(value) {\n                value = validateCache(value);\n                if (value !== undefined) {\n                    _cache = value;\n                }\n            }\n        },\n        begin: {\n            enumerable: true,\n            get: function() {\n                return _begin;\n            },\n            set: function(value) {\n                value = validateBegin(value);\n                if (value !== undefined) {\n                    _begin = value;\n                }\n            }\n        },\n        complete: {\n            enumerable: true,\n            get: function() {\n                return _complete;\n            },\n            set: function(value) {\n                value = validateComplete(value);\n                if (value !== undefined) {\n                    _complete = value;\n                }\n            }\n        },\n        delay: {\n            enumerable: true,\n            get: function() {\n                return _delay;\n            },\n            set: function(value) {\n                value = validateDelay(value);\n                if (value !== undefined) {\n                    _delay = value;\n                }\n            }\n        },\n        duration: {\n            enumerable: true,\n            get: function() {\n                return _duration;\n            },\n            set: function(value) {\n                value = validateDuration(value);\n                if (value !== undefined) {\n                    _duration = value;\n                }\n            }\n        },\n        easing: {\n            enumerable: true,\n            get: function() {\n                return _easing;\n            },\n            set: function(value) {\n                value = validateEasing(value, _duration);\n                if (value !== undefined) {\n                    _easing = value;\n                }\n            }\n        },\n        fpsLimit: {\n            enumerable: true,\n            get: function() {\n                return _fpsLimit;\n            },\n            set: function(value) {\n                value = validateFpsLimit(value);\n                if (value !== undefined) {\n                    _fpsLimit = value;\n                    _minFrameTime = FUZZY_MS_PER_SECOND / value;\n                }\n            }\n        },\n        loop: {\n            enumerable: true,\n            get: function() {\n                return _loop;\n            },\n            set: function(value) {\n                value = validateLoop(value);\n                if (value !== undefined) {\n                    _loop = value;\n                }\n            }\n        },\n        minFrameTime: {\n            enumerable: true,\n            get: function() {\n                return _minFrameTime;\n            }\n        },\n        promise: {\n            enumerable: true,\n            get: function() {\n                return _promise;\n            },\n            set: function(value) {\n                value = validatePromise(value);\n                if (value !== undefined) {\n                    _promise = value;\n                }\n            }\n        },\n        promiseRejectEmpty: {\n            enumerable: true,\n            get: function() {\n                return _promiseRejectEmpty;\n            },\n            set: function(value) {\n                value = validatePromiseRejectEmpty(value);\n                if (value !== undefined) {\n                    _promiseRejectEmpty = value;\n                }\n            }\n        },\n        queue: {\n            enumerable: true,\n            get: function() {\n                return _queue;\n            },\n            set: function(value) {\n                value = validateQueue(value);\n                if (value !== undefined) {\n                    _queue = value;\n                }\n            }\n        },\n        repeat: {\n            enumerable: true,\n            get: function() {\n                return _repeat;\n            },\n            set: function(value) {\n                value = validateRepeat(value);\n                if (value !== undefined) {\n                    _repeat = value;\n                }\n            }\n        },\n        speed: {\n            enumerable: true,\n            get: function() {\n                return _speed;\n            },\n            set: function(value) {\n                value = validateSpeed(value);\n                if (value !== undefined) {\n                    _speed = value;\n                }\n            }\n        },\n        sync: {\n            enumerable: true,\n            get: function() {\n                return _sync;\n            },\n            set: function(value) {\n                value = validateSync(value);\n                if (value !== undefined) {\n                    _sync = value;\n                }\n            }\n        }\n    });\n    VelocityStatic.defaults.reset();\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Velocity-wide animation time remapping for testing purposes.\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * In mock mode, all animations are forced to complete immediately upon the\n     * next rAF tick. If there are further animations queued then they will each\n     * take one single frame in turn. Loops and repeats will be disabled while\n     * <code>mock = true</code>.\n     */\n    VelocityStatic.mock = false;\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * Used to patch any object to allow Velocity chaining. In order to chain an\n     * object must either be treatable as an array - with a <code>.length</code>\n     * property, and each member a Node, or a Node directly.\n     *\n     * By default Velocity will try to patch <code>window</code>,\n     * <code>jQuery</code>, <code>Zepto</code>, and several classes that return\n     * Nodes or lists of Nodes.\n     *\n     * @public\n     */\n    function patch(proto, global) {\n        try {\n            defineProperty(proto, (global ? \"V\" : \"v\") + \"elocity\", VelocityFn);\n        } catch (e) {\n            console.warn(\"VelocityJS: Error when trying to add prototype.\", e);\n        }\n    }\n    VelocityStatic.patch = patch;\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"data.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * AnimationCall queue\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * Simple queue management. Un-named queue is directly within the element data,\n     * named queue is within an object within it.\n     */\n    function animate(animation) {\n        var prev = VelocityStatic.State.last;\n        animation._prev = prev;\n        animation._next = undefined;\n        if (prev) {\n            prev._next = animation;\n        } else {\n            VelocityStatic.State.first = animation;\n        }\n        VelocityStatic.State.last = animation;\n        if (!VelocityStatic.State.firstNew) {\n            VelocityStatic.State.firstNew = animation;\n        }\n        var element = animation.element, data = Data(element);\n        if (!data.count++) {\n            ////////////////////////\n            // Feature: Classname //\n            ////////////////////////\n            addClass(element, VelocityStatic.State.className);\n        }\n    }\n    /**\n     * Add an item to an animation queue.\n     */    function queue(element, animation, queue) {\n        var data = Data(element);\n        if (queue !== false) {\n            // Store the last animation added so we can use it for the\n            // beginning of the next one.\n            data.lastAnimationList[queue] = animation;\n        }\n        if (queue === false) {\n            animate(animation);\n        } else {\n            if (!isString(queue)) {\n                queue = \"\";\n            }\n            var last = data.queueList[queue];\n            if (!last) {\n                if (last === null) {\n                    data.queueList[queue] = animation;\n                } else {\n                    data.queueList[queue] = null;\n                    animate(animation);\n                }\n            } else {\n                while (last._next) {\n                    last = last._next;\n                }\n                last._next = animation;\n                animation._prev = last;\n            }\n        }\n    }\n    VelocityStatic.queue = queue;\n    /**\n     * Start the next animation on this element's queue (named or default).\n     *\n     * @returns the next animation that is starting.\n     */    function dequeue(element, queue, skip) {\n        if (queue !== false) {\n            if (!isString(queue)) {\n                queue = \"\";\n            }\n            var data = Data(element), animation = data.queueList[queue];\n            if (animation) {\n                data.queueList[queue] = animation._next || null;\n                if (!skip) {\n                    animate(animation);\n                }\n            } else if (animation === null) {\n                delete data.queueList[queue];\n            }\n            return animation;\n        }\n    }\n    VelocityStatic.dequeue = dequeue;\n    /**\n     * Remove an animation from the active animation list. If it has a queue set\n     * then remember it as the last animation for that queue, and free the one\n     * that was previously there. If the animation list is completely empty then\n     * mark us as finished.\n     */    function freeAnimationCall(animation) {\n        var next = animation._next, prev = animation._prev, queue = animation.queue == null ? animation.options.queue : animation.queue;\n        if (VelocityStatic.State.firstNew === animation) {\n            VelocityStatic.State.firstNew = next;\n        }\n        if (VelocityStatic.State.first === animation) {\n            VelocityStatic.State.first = next;\n        } else if (prev) {\n            prev._next = next;\n        }\n        if (VelocityStatic.State.last === animation) {\n            VelocityStatic.State.last = prev;\n        } else if (next) {\n            next._prev = prev;\n        }\n        if (queue) {\n            var data = Data(animation.element);\n            if (data) {\n                animation._next = animation._prev = undefined;\n            }\n        }\n    }\n    VelocityStatic.freeAnimationCall = freeAnimationCall;\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    /* Container for the user's custom animation redirects that are referenced by name in place of the properties map argument. */\n    VelocityStatic.Redirects = {};\n    /***********************\n     Packaged Redirects\n     ***********************/\n    /* slideUp, slideDown */    [ \"Down\", \"Up\" ].forEach(function(direction) {\n        VelocityStatic.Redirects[\"slide\" + direction] = function(element, options, elementsIndex, elementsSize, elements, resolver) {\n            var opts = __assign({}, options), begin = opts.begin, complete = opts.complete, inlineValues = {}, computedValues = {\n                height: \"\",\n                marginTop: \"\",\n                marginBottom: \"\",\n                paddingTop: \"\",\n                paddingBottom: \"\"\n            };\n            if (opts.display === undefined) {\n                var isInline = VelocityStatic.inlineRx.test(element.nodeName.toLowerCase());\n                /* Show the element before slideDown begins and hide the element after slideUp completes. */\n                /* Note: Inline elements cannot have dimensions animated, so they're reverted to inline-block. */                opts.display = direction === \"Down\" ? isInline ? \"inline-block\" : \"block\" : \"none\";\n            }\n            opts.begin = function() {\n                /* If the user passed in a begin callback, fire it now. */\n                if (elementsIndex === 0 && begin) {\n                    begin.call(elements, elements);\n                }\n                /* Cache the elements' original vertical dimensional property values so that we can animate back to them. */                for (var property in computedValues) {\n                    if (!computedValues.hasOwnProperty(property)) {\n                        continue;\n                    }\n                    inlineValues[property] = element.style[property];\n                    /* For slideDown, use forcefeeding to animate all vertical properties from 0. For slideUp,\n                     use forcefeeding to start from computed values and animate down to 0. */                    var propertyValue = VelocityStatic.CSS.getPropertyValue(element, property);\n                    computedValues[property] = direction === \"Down\" ? [ propertyValue, 0 ] : [ 0, propertyValue ];\n                }\n                /* Force vertical overflow content to clip so that sliding works as expected. */                inlineValues.overflow = element.style.overflow;\n                element.style.overflow = \"hidden\";\n            };\n            opts.complete = function() {\n                /* Reset element to its pre-slide inline values once its slide animation is complete. */\n                for (var property in inlineValues) {\n                    if (inlineValues.hasOwnProperty(property)) {\n                        element.style[property] = inlineValues[property];\n                    }\n                }\n                /* If the user passed in a complete callback, fire it now. */                if (elementsIndex === elementsSize - 1) {\n                    if (complete) {\n                        complete.call(elements, elements);\n                    }\n                    if (resolver) {\n                        resolver(elements);\n                    }\n                }\n            };\n            VelocityFn(element, computedValues, opts);\n        };\n    });\n    /* fadeIn, fadeOut */    [ \"In\", \"Out\" ].forEach(function(direction) {\n        VelocityStatic.Redirects[\"fade\" + direction] = function(element, options, elementsIndex, elementsSize, elements, promiseData) {\n            var opts = __assign({}, options), complete = opts.complete, propertiesMap = {\n                opacity: direction === \"In\" ? 1 : 0\n            };\n            /* Since redirects are triggered individually for each element in the animated set, avoid repeatedly triggering\n             callbacks by firing them only when the final element has been reached. */            if (elementsIndex !== 0) {\n                opts.begin = null;\n            }\n            if (elementsIndex !== elementsSize - 1) {\n                opts.complete = null;\n            } else {\n                opts.complete = function() {\n                    if (complete) {\n                        complete.call(elements, elements);\n                    }\n                    if (promiseData) {\n                        promiseData.resolver(elements);\n                    }\n                };\n            }\n            /* If a display was passed in, use it. Otherwise, default to \"none\" for fadeOut or the element-specific default for fadeIn. */\n            /* Note: We allow users to pass in \"null\" to skip display setting altogether. */            if (opts.display === undefined) {\n                opts.display = direction === \"In\" ? \"auto\" : \"none\";\n            }\n            VelocityFn(this, propertiesMap, opts);\n        };\n    });\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Effect Registration\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    /* Animate the expansion/contraction of the elements' parent's height for In/Out effects. */\n    function animateParentHeight(elements, direction, totalDuration, stagger) {\n        var totalHeightDelta = 0, parentNode;\n        /* Sum the total height (including padding and margin) of all targeted elements. */\n        /* Sum the total height (including padding and margin) of all targeted elements. */\n        (elements.nodeType ? [ elements ] : elements).forEach(function(element, i) {\n            if (stagger) {\n                /* Increase the totalDuration by the successive delay amounts produced by the stagger option. */\n                totalDuration += i * stagger;\n            }\n            parentNode = element.parentNode;\n            var propertiesToSum = [ \"height\", \"paddingTop\", \"paddingBottom\", \"marginTop\", \"marginBottom\" ];\n            /* If box-sizing is border-box, the height already includes padding and margin */            if (VelocityStatic.CSS.getPropertyValue(element, \"boxSizing\").toString().toLowerCase() === \"border-box\") {\n                propertiesToSum = [ \"height\" ];\n            }\n            propertiesToSum.forEach(function(property) {\n                totalHeightDelta += parseFloat(VelocityStatic.CSS.getPropertyValue(element, property));\n            });\n        });\n        /* Animate the parent element's height adjustment (with a varying duration multiplier for aesthetic benefits). */\n        // TODO: Get this typesafe again\n                VelocityFn(parentNode, {\n            height: (direction === \"In\" ? \"+\" : \"-\") + \"=\" + totalHeightDelta\n        }, {\n            queue: false,\n            easing: \"ease-in-out\",\n            duration: totalDuration * (direction === \"In\" ? .6 : 1)\n        });\n    }\n    /* Note: RegisterUI is a legacy name. */    function RegisterEffect(effectName, properties) {\n        /* Register a custom redirect for each effect. */\n        VelocityStatic.Redirects[effectName] = function(element, redirectOptions, elementsIndex, elementsSize, elements, resolver, loop) {\n            var finalElement = elementsIndex === elementsSize - 1, totalDuration = 0;\n            loop = loop || properties.loop;\n            if (typeof properties.defaultDuration === \"function\") {\n                properties.defaultDuration = properties.defaultDuration.call(elements, elements);\n            } else {\n                properties.defaultDuration = parseFloat(properties.defaultDuration);\n            }\n            /* Get the total duration used, so we can share it out with everything that doesn't have a duration */            for (var callIndex = 0; callIndex < properties.calls.length; callIndex++) {\n                var durationPercentage = properties.calls[callIndex][1];\n                if (typeof durationPercentage === \"number\") {\n                    totalDuration += durationPercentage;\n                }\n            }\n            var shareDuration = totalDuration >= 1 ? 0 : properties.calls.length ? (1 - totalDuration) / properties.calls.length : 1;\n            var _loop_1 = function(callIndex) {\n                var call = properties.calls[callIndex], propertyMap = call[0], redirectDuration = 1e3, durationPercentage = call[1], callOptions = call[2] || {}, opts = {};\n                if (redirectOptions.duration !== undefined) {\n                    redirectDuration = redirectOptions.duration;\n                } else if (properties.defaultDuration !== undefined) {\n                    redirectDuration = properties.defaultDuration;\n                }\n                /* Assign the whitelisted per-call options. */                opts.duration = redirectDuration * (typeof durationPercentage === \"number\" ? durationPercentage : shareDuration);\n                opts.queue = redirectOptions.queue || \"\";\n                opts.easing = callOptions.easing || \"ease\";\n                opts.delay = parseFloat(callOptions.delay) || 0;\n                opts.loop = !properties.loop && callOptions.loop;\n                opts.cache = callOptions.cache || true;\n                /* Special processing for the first effect call. */                if (callIndex === 0) {\n                    /* If a delay was passed into the redirect, combine it with the first call's delay. */\n                    opts.delay += parseFloat(redirectOptions.delay) || 0;\n                    if (elementsIndex === 0) {\n                        opts.begin = function() {\n                            /* Only trigger a begin callback on the first effect call with the first element in the set. */\n                            if (redirectOptions.begin) {\n                                redirectOptions.begin.call(elements, elements);\n                            }\n                            var direction = effectName.match(/(In|Out)$/);\n                            /* Make \"in\" transitioning elements invisible immediately so that there's no FOUC between now\n                             and the first RAF tick. */                            if (direction && direction[0] === \"In\" && propertyMap.opacity !== undefined) {\n                                (elements.nodeType ? [ elements ] : elements).forEach(function(element) {\n                                    VelocityStatic.CSS.setPropertyValue(element, \"opacity\", 0);\n                                });\n                            }\n                            /* Only trigger animateParentHeight() if we're using an In/Out transition. */                            if (redirectOptions.animateParentHeight && direction) {\n                                animateParentHeight(elements, direction[0], redirectDuration + opts.delay, redirectOptions.stagger);\n                            }\n                        };\n                    }\n                    /* If the user isn't overriding the display option, default to \"auto\" for \"In\"-suffixed transitions. */\n                    //\t\t\t\t\tif (redirectOptions.display !== null) {\n                    //\t\t\t\t\t\tif (redirectOptions.display !== undefined && redirectOptions.display !== \"none\") {\n                    //\t\t\t\t\t\t\topts.display = redirectOptions.display;\n                    //\t\t\t\t\t\t} else if (/In$/.test(effectName)) {\n                    //\t\t\t\t\t\t\t/* Inline elements cannot be subjected to transforms, so we switch them to inline-block. */\n                    //\t\t\t\t\t\t\tlet defaultDisplay = CSS.Values.getDisplayType(element);\n                    //\t\t\t\t\t\t\topts.display = (defaultDisplay === \"inline\") ? \"inline-block\" : defaultDisplay;\n                    //\t\t\t\t\t\t}\n                    //\t\t\t\t\t}\n                                        if (redirectOptions.visibility && redirectOptions.visibility !== \"hidden\") {\n                        opts.visibility = redirectOptions.visibility;\n                    }\n                }\n                /* Special processing for the last effect call. */                if (callIndex === properties.calls.length - 1) {\n                    /* Append promise resolving onto the user's redirect callback. */\n                    var injectFinalCallbacks_1 = function() {\n                        if ((redirectOptions.display === undefined || redirectOptions.display === \"none\") && /Out$/.test(effectName)) {\n                            (elements.nodeType ? [ elements ] : elements).forEach(function(element) {\n                                VelocityStatic.CSS.setPropertyValue(element, \"display\", \"none\");\n                            });\n                        }\n                        if (redirectOptions.complete) {\n                            redirectOptions.complete.call(elements, elements);\n                        }\n                        if (resolver) {\n                            resolver(elements || element);\n                        }\n                    };\n                    opts.complete = function() {\n                        if (loop) {\n                            VelocityStatic.Redirects[effectName](element, redirectOptions, elementsIndex, elementsSize, elements, resolver, loop === true ? true : Math.max(0, loop - 1));\n                        }\n                        if (properties.reset) {\n                            for (var resetProperty in properties.reset) {\n                                if (!properties.reset.hasOwnProperty(resetProperty)) {\n                                    continue;\n                                }\n                                var resetValue = properties.reset[resetProperty];\n                                /* Format each non-array value in the reset property map to [ value, value ] so that changes apply\n                                 immediately and DOM querying is avoided (via forcefeeding). */\n                                /* Note: Don't forcefeed hooks, otherwise their hook roots will be defaulted to their null values. */\n                                // TODO: Fix this\n                                //\t\t\t\t\t\t\t\tif (CSS.Hooks.registered[resetProperty] === undefined && (typeof resetValue === \"string\" || typeof resetValue === \"number\")) {\n                                //\t\t\t\t\t\t\t\t\tproperties.reset[resetProperty] = [properties.reset[resetProperty], properties.reset[resetProperty]];\n                                //\t\t\t\t\t\t\t\t}\n                                                        }\n                            /* So that the reset values are applied instantly upon the next rAF tick, use a zero duration and parallel queueing. */                            var resetOptions = {\n                                duration: 0,\n                                queue: false\n                            };\n                            /* Since the reset option uses up the complete callback, we trigger the user's complete callback at the end of ours. */                            if (finalElement) {\n                                resetOptions.complete = injectFinalCallbacks_1;\n                            }\n                            VelocityFn(element, properties.reset, resetOptions);\n                            /* Only trigger the user's complete callback on the last effect call with the last element in the set. */                        } else if (finalElement) {\n                            injectFinalCallbacks_1();\n                        }\n                    };\n                    if (redirectOptions.visibility === \"hidden\") {\n                        opts.visibility = redirectOptions.visibility;\n                    }\n                }\n                VelocityFn(element, propertyMap, opts);\n            };\n            /* Iterate through each effect's call array. */            for (var callIndex = 0; callIndex < properties.calls.length; callIndex++) {\n                _loop_1(callIndex);\n            }\n        };\n        /* Return the Velocity object so that RegisterUI calls can be chained. */        return VelocityFn;\n    }\n    VelocityStatic.RegisterEffect = RegisterEffect;\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Sequence Running\n */\n/**\n * Perform a deep copy of an object - also copies children so they're not\n * going to be affected by changing original.\n */\nfunction _deepCopyObject(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    if (target == null) {\n        throw new TypeError(\"Cannot convert undefined or null to object\");\n    }\n    var to = Object(target), hasOwnProperty = Object.prototype.hasOwnProperty;\n    var source;\n    while (source = sources.shift()) {\n        if (source != null) {\n            for (var key in source) {\n                if (hasOwnProperty.call(source, key)) {\n                    var value = source[key];\n                    if (Array.isArray(value)) {\n                        _deepCopyObject(to[key] = [], value);\n                    } else if (isPlainObject(value)) {\n                        _deepCopyObject(to[key] = {}, value);\n                    } else {\n                        to[key] = value;\n                    }\n                }\n            }\n        }\n    }\n    return to;\n}\n\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    /* Note: Sequence calls must use Velocity's single-object arguments syntax. */\n    function RunSequence(originalSequence) {\n        var sequence = _deepCopyObject([], originalSequence);\n        if (sequence.length > 1) {\n            sequence.reverse().forEach(function(currentCall, i) {\n                var nextCall = sequence[i + 1];\n                if (nextCall) {\n                    /* Parallel sequence calls (indicated via sequenceQueue:false) are triggered\n                     in the previous call's begin callback. Otherwise, chained calls are normally triggered\n                     in the previous call's complete callback. */\n                    var currentCallOptions = currentCall.o || currentCall.options, nextCallOptions = nextCall.o || nextCall.options;\n                    var timing = currentCallOptions && currentCallOptions.sequenceQueue === false ? \"begin\" : \"complete\", callbackOriginal_1 = nextCallOptions && nextCallOptions[timing], options = {};\n                    options[timing] = function() {\n                        var nextCallElements = nextCall.e || nextCall.elements;\n                        var elements = nextCallElements.nodeType ? [ nextCallElements ] : nextCallElements;\n                        if (callbackOriginal_1) {\n                            callbackOriginal_1.call(elements, elements);\n                        }\n                        VelocityFn(currentCall);\n                    };\n                    if (nextCall.o) {\n                        nextCall.o = __assign({}, nextCallOptions, options);\n                    } else {\n                        nextCall.options = __assign({}, nextCallOptions, options);\n                    }\n                }\n            });\n            sequence.reverse();\n        }\n        VelocityFn(sequence[0]);\n    }\n    VelocityStatic.RunSequence = RunSequence;\n})(VelocityStatic || (VelocityStatic = {}));\n\n///<reference path=\"state.ts\" />\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Tick\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    /**\n     * Call the begin method of an animation in a separate function so it can\n     * benefit from JIT compiling while still having a try/catch block.\n     */\n    function callBegin(activeCall) {\n        try {\n            var elements = activeCall.elements;\n            activeCall.options.begin.call(elements, elements, activeCall);\n        } catch (error) {\n            setTimeout(function() {\n                throw error;\n            }, 1);\n        }\n    }\n    VelocityStatic.callBegin = callBegin;\n    /**\n     * Call the progress method of an animation in a separate function so it can\n     * benefit from JIT compiling while still having a try/catch block.\n     */    function callProgress(activeCall, timeCurrent) {\n        try {\n            var elements = activeCall.elements, percentComplete = activeCall.percentComplete, options = activeCall.options, tweenValue = activeCall.tween;\n            activeCall.options.progress.call(elements, elements, percentComplete, Math.max(0, activeCall.timeStart + (activeCall.duration != null ? activeCall.duration : options.duration != null ? options.duration : VelocityStatic.defaults.duration) - timeCurrent), tweenValue !== undefined ? tweenValue : String(percentComplete * 100), activeCall);\n        } catch (error) {\n            setTimeout(function() {\n                throw error;\n            }, 1);\n        }\n    }\n    var firstProgress, firstComplete;\n    function asyncCallbacks() {\n        var activeCall, nextCall;\n        // Callbacks and complete that might read the DOM again.\n        // Progress callback\n                for (activeCall = firstProgress; activeCall; activeCall = nextCall) {\n            nextCall = activeCall._nextProgress;\n            // Pass to an external fn with a try/catch block for optimisation\n                        callProgress(activeCall, VelocityStatic.lastTick);\n        }\n        // Complete animations, including complete callback or looping\n                for (activeCall = firstComplete; activeCall; activeCall = nextCall) {\n            nextCall = activeCall._nextComplete;\n            /* If this call has finished tweening, pass it to complete() to handle call cleanup. */            VelocityStatic.completeCall(activeCall);\n        }\n    }\n    /**************\n     Timing\n     **************/    var FRAME_TIME = 1e3 / 60,\n    /**\n    * Shim for window.performance in case it doesn't exist\n    */\n    performance = function() {\n        var perf = window.performance || {};\n        if (typeof perf.now !== \"function\") {\n            var nowOffset_1 = perf.timing && perf.timing.navigationStart ? perf.timing.navigationStart : _now();\n            perf.now = function() {\n                return _now() - nowOffset_1;\n            };\n        }\n        return perf;\n    }(),\n    /**\n     * Proxy function for when rAF is not available - try to be as accurate\n     * as possible with the setTimeout calls, however they are far less\n     * accurate than rAF can be - so try not to use normally (unless the tab\n     * is in the background).\n     */\n    rAFProxy = function(callback) {\n        console.log(\"rAFProxy\", Math.max(0, FRAME_TIME - (performance.now() - VelocityStatic.lastTick)), performance.now(), VelocityStatic.lastTick, FRAME_TIME);\n        return setTimeout(function() {\n            callback(performance.now());\n        }, Math.max(0, FRAME_TIME - (performance.now() - VelocityStatic.lastTick)));\n    },\n    /* rAF shim. Gist: https://gist.github.com/julianshapiro/9497513 */\n    rAFShim = window.requestAnimationFrame || rAFProxy;\n    /**\n     * The ticker function being used, either rAF, or a function that\n     * emulates it.\n     */    var ticker = document.hidden ? rAFProxy : rAFShim;\n    /**\n     * The time that the last animation frame ran at. Set from tick(), and used\n     * for missing rAF (ie, when not in focus etc).\n     */    VelocityStatic.lastTick = 0;\n    /* Inactive browser tabs pause rAF, which results in all active animations immediately sprinting to their completion states when the tab refocuses.\n     To get around this, we dynamically switch rAF to setTimeout (which the browser *doesn't* pause) when the tab loses focus. We skip this for mobile\n     devices to avoid wasting battery power on inactive tabs. */\n    /* Note: Tab focus detection doesn't work on older versions of IE, but that's okay since they don't support rAF to begin with. */    if (!VelocityStatic.State.isMobile && document.hidden !== undefined) {\n        document.addEventListener(\"visibilitychange\", function updateTicker(event) {\n            var hidden = document.hidden;\n            ticker = hidden ? rAFProxy : rAFShim;\n            if (event) {\n                setTimeout(tick, 2e3);\n            }\n            tick();\n        });\n    }\n    var ticking;\n    /**\n     * Called on every tick, preferably through rAF. This is reponsible for\n     * initialising any new animations, then starting any that need starting.\n     * Finally it will expand any tweens and set the properties relating to\n     * them. If there are any callbacks relating to the animations then they\n     * will attempt to call at the end (with the exception of \"begin\").\n     */    function tick(timestamp) {\n        if (ticking) {\n            // Should never happen - but if we've swapped back from hidden to\n            // visibile then we want to make sure\n            return;\n        }\n        ticking = true;\n        /* An empty timestamp argument indicates that this is the first tick occurence since ticking was turned on.\n         We leverage this metadata to fully ignore the first tick pass since RAF's initial pass is fired whenever\n         the browser's next tick sync time occurs, which results in the first elements subjected to Velocity\n         calls being animated out of sync with any elements animated immediately thereafter. In short, we ignore\n         the first RAF tick pass so that elements being immediately consecutively animated -- instead of simultaneously animated\n         by the same Velocity call -- are properly batched into the same initial RAF tick and consequently remain in sync thereafter. */        if (timestamp) {\n            /* We normally use RAF's high resolution timestamp but as it can be significantly offset when the browser is\n             under high stress we give the option for choppiness over allowing the browser to drop huge chunks of frames.\n             We use performance.now() and shim it if it doesn't exist for when the tab is hidden. */\n            var timeCurrent = timestamp && timestamp !== true ? timestamp : performance.now(), deltaTime = VelocityStatic.lastTick ? timeCurrent - VelocityStatic.lastTick : FRAME_TIME, defaultSpeed = VelocityStatic.defaults.speed, defaultEasing = VelocityStatic.defaults.easing, defaultDuration = VelocityStatic.defaults.duration;\n            var activeCall = void 0, nextCall = void 0, lastProgress = void 0, lastComplete = void 0;\n            firstProgress = null;\n            firstComplete = null;\n            if (deltaTime >= VelocityStatic.defaults.minFrameTime || !VelocityStatic.lastTick) {\n                VelocityStatic.lastTick = timeCurrent;\n                /********************\n                 Call Iteration\n                 ********************/\n                // Expand any tweens that might need it.\n                                while (activeCall = VelocityStatic.State.firstNew) {\n                    VelocityStatic.validateTweens(activeCall);\n                }\n                // Iterate through each active call.\n                                for (activeCall = VelocityStatic.State.first; activeCall && activeCall !== VelocityStatic.State.firstNew; activeCall = activeCall._next) {\n                    var element = activeCall.element;\n                    var data = void 0;\n                    // Check to see if this element has been deleted midway\n                    // through the animation. If it's gone then end this\n                    // animation.\n                                        if (!element.parentNode || !(data = Data(element))) {\n                        // TODO: Remove safely - decrease count, delete data, remove from arrays\n                        VelocityStatic.freeAnimationCall(activeCall);\n                        continue;\n                    }\n                    // Don't bother getting until we can use these.\n                                        var options = activeCall.options, flags = activeCall._flags;\n                    var timeStart = activeCall.timeStart;\n                    // If this is the first time that this call has been\n                    // processed by tick() then we assign timeStart now so that\n                    // it's value is as close to the real animation start time\n                    // as possible.\n                                        if (!timeStart) {\n                        var queue_1 = activeCall.queue != null ? activeCall.queue : options.queue;\n                        timeStart = timeCurrent - deltaTime;\n                        if (queue_1 !== false) {\n                            timeStart = Math.max(timeStart, data.lastFinishList[queue_1] || 0);\n                        }\n                        activeCall.timeStart = timeStart;\n                    }\n                    // If this animation is paused then skip processing unless\n                    // it has been set to resume.\n                                        if (flags & 16 /* PAUSED */) {\n                        // Update the time start to accomodate the paused\n                        // completion amount.\n                        activeCall.timeStart += deltaTime;\n                        continue;\n                    }\n                    // Check if this animation is ready - if it's synced then it\n                    // needs to wait for all other animations in the sync\n                                        if (!(flags & 2 /* READY */)) {\n                        activeCall._flags |= 2 /* READY */;\n                        options._ready++;\n                    }\n                }\n                // Need to split the loop, as ready sync animations must all get\n                // the same start time.\n                                for (activeCall = VelocityStatic.State.first; activeCall && activeCall !== VelocityStatic.State.firstNew; activeCall = nextCall) {\n                    var flags = activeCall._flags;\n                    nextCall = activeCall._next;\n                    if (!(flags & 2 /* READY */) || flags & 16 /* PAUSED */) {\n                        continue;\n                    }\n                    var options = activeCall.options;\n                    if (flags & 32 /* SYNC */ && options._ready < options._total) {\n                        activeCall.timeStart += deltaTime;\n                        continue;\n                    }\n                    var speed = activeCall.speed != null ? activeCall.speed : options.speed != null ? options.speed : defaultSpeed;\n                    var timeStart = activeCall.timeStart;\n                    // Don't bother getting until we can use these.\n                                        if (!(flags & 4 /* STARTED */)) {\n                        var delay = activeCall.delay != null ? activeCall.delay : options.delay;\n                        // Make sure anything we've delayed doesn't start\n                        // animating yet, there might still be an active delay\n                        // after something has been un-paused\n                                                if (delay) {\n                            if (timeStart + delay / speed > timeCurrent) {\n                                continue;\n                            }\n                            activeCall.timeStart = timeStart += delay / (delay > 0 ? speed : 1);\n                        }\n                        activeCall._flags |= 4 /* STARTED */;\n                        // The begin callback is fired once per call, not once\n                        // per element, and is passed the full raw DOM element\n                        // set as both its context and its first argument.\n                                                if (options._started++ === 0) {\n                            options._first = activeCall;\n                            if (options.begin) {\n                                // Pass to an external fn with a try/catch block for optimisation\n                                callBegin(activeCall);\n                                // Only called once, even if reversed or repeated\n                                                                options.begin = undefined;\n                            }\n                        }\n                    }\n                    if (speed !== 1) {\n                        // On the first frame we may have a shorter delta\n                        var delta = Math.min(deltaTime, timeCurrent - timeStart);\n                        activeCall.timeStart = timeStart += delta * (1 - speed);\n                    }\n                    if (options._first === activeCall && options.progress) {\n                        activeCall._nextProgress = undefined;\n                        if (lastProgress) {\n                            lastProgress._nextProgress = lastProgress = activeCall;\n                        } else {\n                            firstProgress = lastProgress = activeCall;\n                        }\n                    }\n                    var activeEasing = activeCall.easing != null ? activeCall.easing : options.easing != null ? options.easing : defaultEasing, millisecondsEllapsed = activeCall.ellapsedTime = timeCurrent - timeStart, duration = activeCall.duration != null ? activeCall.duration : options.duration != null ? options.duration : defaultDuration, percentComplete = activeCall.percentComplete = VelocityStatic.mock ? 1 : Math.min(millisecondsEllapsed / duration, 1), tweens = activeCall.tweens, reverse = flags & 64 /* REVERSE */;\n                    if (percentComplete === 1) {\n                        activeCall._nextComplete = undefined;\n                        if (lastComplete) {\n                            lastComplete._nextComplete = lastComplete = activeCall;\n                        } else {\n                            firstComplete = lastComplete = activeCall;\n                        }\n                    }\n                    for (var property in tweens) {\n                        // For every element, iterate through each property.\n                        var tween_3 = tweens[property], easing = tween_3.easing || activeEasing, pattern = tween_3.pattern;\n                        var currentValue = \"\", i = 0;\n                        if (pattern) {\n                            for (;i < pattern.length; i++) {\n                                var startValue = tween_3.start[i];\n                                if (startValue == null) {\n                                    currentValue += pattern[i];\n                                } else {\n                                    // All easings must deal with numbers except for\n                                    // our internal ones\n                                    var result = easing(reverse ? 1 - percentComplete : percentComplete, startValue, tween_3.end[i], property);\n                                    currentValue += pattern[i] === true ? Math.round(result) : result;\n                                }\n                            }\n                            if (property !== \"tween\") {\n                                // TODO: To solve an IE<=8 positioning bug, the unit type must be dropped when setting a property value of 0 - add normalisations to legacy\n                                VelocityStatic.CSS.setPropertyValue(activeCall.element, property, currentValue, tween_3.fn);\n                            } else {\n                                // Skip the fake 'tween' property as that is only\n                                // passed into the progress callback.\n                                activeCall.tween = currentValue;\n                            }\n                        } else {\n                            console.warn(\"VelocityJS: Missing pattern:\", property, JSON.stringify(tween_3[property]));\n                            delete tweens[property];\n                        }\n                    }\n                }\n                if (firstProgress || firstComplete) {\n                    setTimeout(asyncCallbacks, 1);\n                }\n            }\n        }\n        if (VelocityStatic.State.first) {\n            VelocityStatic.State.isTicking = true;\n            ticker(tick);\n        } else {\n            VelocityStatic.State.isTicking = false;\n            VelocityStatic.lastTick = 0;\n        }\n        ticking = false;\n    }\n    VelocityStatic.tick = tick;\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Use rAF high resolution timestamp when available.\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    VelocityStatic.timestamp = true;\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Tweens\n */\nvar VelocityStatic;\n\n(function(VelocityStatic) {\n    var rxHex = /^#([A-f\\d]{3}){1,2}$/i;\n    var commands = new Map();\n    commands.set(\"function\", function(value, element, elements, elementArrayIndex, propertyName, tween) {\n        return value.call(element, elementArrayIndex, elements.length);\n    });\n    commands.set(\"number\", function(value, element, elements, elementArrayIndex, propertyName, tween) {\n        return value + VelocityStatic.getNormalizationUnit(tween.fn);\n    });\n    commands.set(\"string\", function(value, element, elements, elementArrayIndex, propertyName, tween) {\n        return VelocityStatic.CSS.fixColors(value);\n    });\n    commands.set(\"undefined\", function(value, element, elements, elementArrayIndex, propertyName, tween) {\n        return VelocityStatic.CSS.fixColors(VelocityStatic.CSS.getPropertyValue(element, propertyName, tween.fn) || \"\");\n    });\n    /**\n     * Expand a VelocityProperty argument into a valid sparse Tween array. This\n     * pre-allocates the array as it is then the correct size and slightly\n     * faster to access.\n     */    function expandProperties(animation, properties) {\n        var tweens = animation.tweens = createEmptyObject(), elements = animation.elements, element = animation.element, elementArrayIndex = elements.indexOf(element), data = Data(element), queue = getValue(animation.queue, animation.options.queue), duration = getValue(animation.options.duration, VelocityStatic.defaults.duration);\n        for (var property in properties) {\n            var propertyName = VelocityStatic.CSS.camelCase(property);\n            var valueData = properties[property], fn = VelocityStatic.getNormalization(element, propertyName);\n            if (!fn && propertyName !== \"tween\") {\n                if (VelocityStatic.debug) {\n                    console.log(\"Skipping [\" + property + \"] due to a lack of browser support.\");\n                }\n                continue;\n            }\n            if (valueData == null) {\n                if (VelocityStatic.debug) {\n                    console.log(\"Skipping [\" + property + \"] due to no value supplied.\");\n                }\n                continue;\n            }\n            var tween_4 = tweens[propertyName] = createEmptyObject();\n            var endValue = void 0, startValue = void 0;\n            tween_4.fn = fn;\n            if (isFunction(valueData)) {\n                // If we have a function as the main argument then resolve\n                // it first, in case it returns an array that needs to be\n                // split.\n                valueData = valueData.call(element, elementArrayIndex, elements.length, elements);\n            }\n            if (Array.isArray(valueData)) {\n                // valueData is an array in the form of\n                // [ endValue, [, easing] [, startValue] ]\n                var arr1 = valueData[1], arr2 = valueData[2];\n                endValue = valueData[0];\n                if (isString(arr1) && (/^[\\d-]/.test(arr1) || rxHex.test(arr1)) || isFunction(arr1) || isNumber(arr1)) {\n                    startValue = arr1;\n                } else if (isString(arr1) && VelocityStatic.Easing.Easings[arr1] || Array.isArray(arr1)) {\n                    tween_4.easing = arr1;\n                    startValue = arr2;\n                } else {\n                    startValue = arr1 || arr2;\n                }\n            } else {\n                endValue = valueData;\n            }\n            tween_4.end = commands.get(typeof endValue)(endValue, element, elements, elementArrayIndex, propertyName, tween_4);\n            if (startValue != null || (queue === false || data.queueList[queue] === undefined)) {\n                tween_4.start = commands.get(typeof startValue)(startValue, element, elements, elementArrayIndex, propertyName, tween_4);\n            }\n            explodeTween(propertyName, tween_4, duration, !!startValue);\n        }\n    }\n    VelocityStatic.expandProperties = expandProperties;\n    /**\n     * Convert a string-based tween with start and end strings, into a pattern\n     * based tween with arrays.\n     */    function explodeTween(propertyName, tween, duration, isForcefeed) {\n        var endValue = tween.end;\n        var startValue = tween.start;\n        if (!isString(endValue) || !isString(startValue)) {\n            return;\n        }\n        var runAgain = false;\n // Can only be set once if the Start value doesn't match the End value and it's not forcefed\n                do {\n            runAgain = false;\n            var arrayStart = tween.start = [ null ], arrayEnd = tween.end = [ null ], pattern = tween.pattern = [ \"\" ];\n            var easing = tween.easing, indexStart = 0, // index in startValue\n            indexEnd = 0, // index in endValue\n            inCalc = 0, // Keep track of being inside a \"calc()\" so we don't duplicate it\n            inRGB = 0, // Keep track of being inside an RGB as we can't use fractional values\n            inRGBA = 0, // Keep track of being inside an RGBA as we must pass fractional for the alpha channel\n            isStringValue = void 0;\n            var _loop_2 = function() {\n                var charStart = startValue[indexStart], charEnd = endValue[indexEnd];\n                // If they're both numbers, then parse them as a whole\n                                if (TWEEN_NUMBER_REGEX.test(charStart) && TWEEN_NUMBER_REGEX.test(charEnd)) {\n                    var tempStart = charStart, // temporary character buffer\n                    tempEnd = charEnd, // temporary character buffer\n                    dotStart = \".\", // Make sure we can only ever match a single dot in a decimal\n                    dotEnd = \".\";\n // Make sure we can only ever match a single dot in a decimal\n                                        while (++indexStart < startValue.length) {\n                        charStart = startValue[indexStart];\n                        if (charStart === dotStart) {\n                            dotStart = \"..\";\n // Can never match two characters\n                                                } else if (!isNumberWhenParsed(charStart)) {\n                            break;\n                        }\n                        tempStart += charStart;\n                    }\n                    while (++indexEnd < endValue.length) {\n                        charEnd = endValue[indexEnd];\n                        if (charEnd === dotEnd) {\n                            dotEnd = \"..\";\n // Can never match two characters\n                                                } else if (!isNumberWhenParsed(charEnd)) {\n                            break;\n                        }\n                        tempEnd += charEnd;\n                    }\n                    var unitStart = VelocityStatic.CSS.getUnit(startValue, indexStart), // temporary unit type\n                    unitEnd = VelocityStatic.CSS.getUnit(endValue, indexEnd);\n // temporary unit type\n                                        indexStart += unitStart.length;\n                    indexEnd += unitEnd.length;\n                    if (unitEnd.length === 0) {\n                        // This order as it's most common for the user supplied\n                        // value to be a number.\n                        unitEnd = unitStart;\n                    } else if (unitStart.length === 0) {\n                        unitStart = unitEnd;\n                    }\n                    if (unitStart === unitEnd) {\n                        // Same units\n                        if (tempStart === tempEnd) {\n                            // Same numbers, so just copy over\n                            pattern[pattern.length - 1] += tempStart + unitStart;\n                        } else {\n                            pattern.push(inRGB ? true : false, unitStart);\n                            arrayStart.push(parseFloat(tempStart), null);\n                            arrayEnd.push(parseFloat(tempEnd), null);\n                        }\n                    } else {\n                        // Different units, so put into a \"calc(from + to)\" and\n                        // animate each side to/from zero. setPropertyValue will\n                        // look out for the final \"calc(0 + \" prefix and remove\n                        // it from the value when it finds it.\n                        pattern[pattern.length - 1] += inCalc ? \"+ (\" : \"calc(\";\n                        pattern.push(false, unitStart + \" + \", false, unitEnd + \")\");\n                        arrayStart.push(parseFloat(tempStart) || 0, null, 0, null);\n                        arrayEnd.push(0, null, parseFloat(tempEnd) || 0, null);\n                    }\n                } else if (charStart === charEnd) {\n                    pattern[pattern.length - 1] += charStart;\n                    indexStart++;\n                    indexEnd++;\n                    // Keep track of being inside a calc()\n                                        if (inCalc === 0 && charStart === \"c\" || inCalc === 1 && charStart === \"a\" || inCalc === 2 && charStart === \"l\" || inCalc === 3 && charStart === \"c\" || inCalc >= 4 && charStart === \"(\") {\n                        inCalc++;\n                    } else if (inCalc && inCalc < 5 || inCalc >= 4 && charStart === \")\" && --inCalc < 5) {\n                        inCalc = 0;\n                    }\n                    // Keep track of being inside an rgb() / rgba()\n                    // The opacity must not be rounded.\n                                        if (inRGB === 0 && charStart === \"r\" || inRGB === 1 && charStart === \"g\" || inRGB === 2 && charStart === \"b\" || inRGB === 3 && charStart === \"a\" || inRGB >= 3 && charStart === \"(\") {\n                        if (inRGB === 3 && charStart === \"a\") {\n                            inRGBA = 1;\n                        }\n                        inRGB++;\n                    } else if (inRGBA && charStart === \",\") {\n                        if (++inRGBA > 3) {\n                            inRGB = inRGBA = 0;\n                        }\n                    } else if (inRGBA && inRGB < (inRGBA ? 5 : 4) || inRGB >= (inRGBA ? 4 : 3) && charStart === \")\" && --inRGB < (inRGBA ? 5 : 4)) {\n                        inRGB = inRGBA = 0;\n                    }\n                } else if (charStart || charEnd) {\n                    // Different letters, so we're going to push them into start\n                    // and end until the next word\n                    isStringValue = true;\n                    if (!isString(arrayStart[arrayStart.length - 1])) {\n                        if (pattern.length === 1 && !pattern[0]) {\n                            arrayStart[0] = arrayEnd[0] = \"\";\n                        } else {\n                            pattern.push(\"\");\n                            arrayStart.push(\"\");\n                            arrayEnd.push(\"\");\n                        }\n                    }\n                    while (indexStart < startValue.length) {\n                        charStart = startValue[indexStart++];\n                        if (charStart === \" \" || TWEEN_NUMBER_REGEX.test(charStart)) {\n                            break;\n                        } else {\n                            arrayStart[arrayStart.length - 1] += charStart;\n                        }\n                    }\n                    while (indexEnd < endValue.length) {\n                        charEnd = endValue[indexEnd++];\n                        if (charEnd === \" \" || TWEEN_NUMBER_REGEX.test(charEnd)) {\n                            break;\n                        } else {\n                            arrayEnd[arrayEnd.length - 1] += charEnd;\n                        }\n                    }\n                }\n                if (!isForcefeed && indexStart === startValue.length !== (indexEnd === endValue.length)) {\n                    // This little piece will take a startValue, split out the\n                    // various numbers in it, then copy the endValue into the\n                    // startValue while replacing the numbers in it to match the\n                    // original start numbers as a repeating sequence.\n                    // Finally this function will run again with the new\n                    // startValue and a now matching pattern.\n                    var startNumbers_1 = startValue.match(/\\d\\.?\\d*/g) || [ \"0\" ], count_1 = startNumbers_1.length, index_1 = 0;\n                    startValue = endValue.replace(/\\d+\\.?\\d*/g, function() {\n                        return startNumbers_1[index_1++ % count_1];\n                    });\n                    runAgain = isForcefeed = true;\n                    return \"break\";\n                }\n            };\n            // TODO: Relative Values\n            /* Operator logic must be performed last since it requires unit-normalized start and end values. */\n            /* Note: Relative *percent values* do not behave how most people think; while one would expect \"+=50%\"\n             to increase the property 1.5x its current value, it in fact increases the percent units in absolute terms:\n             50 points is added on top of the current % value. */\n            //\t\t\t\t\tswitch (operator as any as string) {\n            //\t\t\t\t\t\tcase \"+\":\n            //\t\t\t\t\t\t\tendValue = startValue + endValue;\n            //\t\t\t\t\t\t\tbreak;\n            //\n            //\t\t\t\t\t\tcase \"-\":\n            //\t\t\t\t\t\t\tendValue = startValue - endValue;\n            //\t\t\t\t\t\t\tbreak;\n            //\n            //\t\t\t\t\t\tcase \"*\":\n            //\t\t\t\t\t\t\tendValue = startValue * endValue;\n            //\t\t\t\t\t\t\tbreak;\n            //\n            //\t\t\t\t\t\tcase \"/\":\n            //\t\t\t\t\t\t\tendValue = startValue / endValue;\n            //\t\t\t\t\t\t\tbreak;\n            //\t\t\t\t\t}\n            // TODO: Leading from a calc value\n                        while (indexStart < startValue.length && indexEnd < endValue.length) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\") break;\n            }\n            if (!runAgain) {\n                // TODO: These two would be slightly better to not add the array indices in the first place\n                if (pattern[0] === \"\" && arrayEnd[0] == null) {\n                    pattern.shift();\n                    arrayStart.shift();\n                    arrayEnd.shift();\n                }\n                if (pattern[pattern.length] === \"\" && arrayEnd[arrayEnd.length] == null) {\n                    pattern.pop();\n                    arrayStart.pop();\n                    arrayEnd.pop();\n                }\n                if (indexStart < startValue.length || indexEnd < endValue.length) {\n                    // NOTE: We should never be able to reach this code unless a\n                    // bad forcefed value is supplied.\n                    console.error(\"Velocity: Trying to pattern match mis-matched strings \" + propertyName + ':[\"' + endValue + '\", \"' + startValue + '\"]');\n                }\n                if (VelocityStatic.debug) {\n                    console.log(\"Velocity: Pattern found:\", pattern, \" -> \", arrayStart, arrayEnd, \"[\" + startValue + \",\" + endValue + \"]\");\n                }\n                if (propertyName === \"display\") {\n                    if (!/^(at-start|at-end|during)$/.test(easing)) {\n                        easing = endValue === \"none\" ? \"at-end\" : \"at-start\";\n                    }\n                } else if (propertyName === \"visibility\") {\n                    if (!/^(at-start|at-end|during)$/.test(easing)) {\n                        easing = endValue === \"hidden\" ? \"at-end\" : \"at-start\";\n                    }\n                } else if (isStringValue && easing !== \"at-start\" && easing !== \"during\" && easing !== \"at-end\" && easing !== VelocityStatic.Easing.Easings[\"at-Start\"] && easing !== VelocityStatic.Easing.Easings[\"during\"] && easing !== VelocityStatic.Easing.Easings[\"at-end\"]) {\n                    console.warn(\"Velocity: String easings must use one of 'at-start', 'during' or 'at-end': {\" + propertyName + ': [\"' + endValue + '\", ' + easing + ', \"' + startValue + '\"]}');\n                    easing = \"at-start\";\n                }\n                tween.easing = validateEasing(easing, duration);\n            }\n            // This can only run a second time once - if going from automatic startValue to \"fixed\" pattern from endValue with startValue numbers\n                } while (runAgain);\n    }\n    /**\n     * Expand all queued animations that haven't gone yet\n     *\n     * This will automatically expand the properties map for any recently added\n     * animations so that the start and end values are correct.\n     */    function validateTweens(activeCall) {\n        // This might be called on an already-ready animation\n        if (VelocityStatic.State.firstNew === activeCall) {\n            VelocityStatic.State.firstNew = activeCall._next;\n        }\n        // Check if we're actually already ready\n                if (activeCall._flags & 1 /* EXPANDED */) {\n            return;\n        }\n        var element = activeCall.element, tweens = activeCall.tweens, duration = getValue(activeCall.options.duration, VelocityStatic.defaults.duration);\n        for (var propertyName in tweens) {\n            var tween_5 = tweens[propertyName];\n            if (tween_5.start == null) {\n                // Get the start value as it's not been passed in\n                var startValue = VelocityStatic.CSS.getPropertyValue(activeCall.element, propertyName);\n                if (isString(startValue)) {\n                    tween_5.start = VelocityStatic.CSS.fixColors(startValue);\n                    explodeTween(propertyName, tween_5, duration);\n                } else if (!Array.isArray(startValue)) {\n                    console.warn(\"bad type\", tween_5, propertyName, startValue);\n                }\n            }\n            if (VelocityStatic.debug) {\n                console.log(\"tweensContainer (\" + propertyName + \"): \" + JSON.stringify(tween_5), element);\n            }\n        }\n        activeCall._flags |= 1 /* EXPANDED */;\n    }\n    VelocityStatic.validateTweens = validateTweens;\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Validation functions used for various types of data that can be supplied.\n * All errors are reported in the non-minified version for development. If a\n * validation fails then it should return <code>undefined</code>.\n */\n/**\n * Parse a duration value and return an ms number. Optionally return a\n * default value if the number is not valid.\n */ function parseDuration(duration, def) {\n    if (isNumber(duration)) {\n        return duration;\n    }\n    if (isString(duration)) {\n        return Duration[duration.toLowerCase()] || parseFloat(duration.replace(\"ms\", \"\").replace(\"s\", \"000\"));\n    }\n    return def == null ? undefined : parseDuration(def);\n}\n\n/**\n * Validate a <code>cache</code> option.\n * @private\n */ function validateCache(value) {\n    if (isBoolean(value)) {\n        return value;\n    }\n    if (value != null) {\n        console.warn(\"VelocityJS: Trying to set 'cache' to an invalid value:\", value);\n    }\n}\n\n/**\n * Validate a <code>begin</code> option.\n * @private\n */ function validateBegin(value) {\n    if (isFunction(value)) {\n        return value;\n    }\n    if (value != null) {\n        console.warn(\"VelocityJS: Trying to set 'begin' to an invalid value:\", value);\n    }\n}\n\n/**\n * Validate a <code>complete</code> option.\n * @private\n */ function validateComplete(value, noError) {\n    if (isFunction(value)) {\n        return value;\n    }\n    if (value != null && !noError) {\n        console.warn(\"VelocityJS: Trying to set 'complete' to an invalid value:\", value);\n    }\n}\n\n/**\n * Validate a <code>delay</code> option.\n * @private\n */ function validateDelay(value) {\n    var parsed = parseDuration(value);\n    if (!isNaN(parsed)) {\n        return parsed;\n    }\n    if (value != null) {\n        console.error(\"VelocityJS: Trying to set 'delay' to an invalid value:\", value);\n    }\n}\n\n/**\n * Validate a <code>duration</code> option.\n * @private\n */ function validateDuration(value, noError) {\n    var parsed = parseDuration(value);\n    if (!isNaN(parsed) && parsed >= 0) {\n        return parsed;\n    }\n    if (value != null && !noError) {\n        console.error(\"VelocityJS: Trying to set 'duration' to an invalid value:\", value);\n    }\n}\n\n/**\n * Validate a <code>easing</code> option.\n * @private\n */ function validateEasing(value, duration, noError) {\n    var Easing = VelocityStatic.Easing;\n    if (isString(value)) {\n        // Named easing\n        return Easing.Easings[value];\n    }\n    if (isFunction(value)) {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        if (value.length === 1) {\n            // Steps\n            return Easing.generateStep(value[0]);\n        }\n        if (value.length === 2) {\n            // springRK4 must be passed the animation's duration.\n            // Note: If the springRK4 array contains non-numbers,\n            // generateSpringRK4() returns an easing function generated with\n            // default tension and friction values.\n            return Easing.generateSpringRK4(value[0], value[1], duration);\n        }\n        if (value.length === 4) {\n            // Note: If the bezier array contains non-numbers, generateBezier()\n            // returns undefined.\n            return Easing.generateBezier.apply(null, value) || false;\n        }\n    }\n    if (value != null && !noError) {\n        console.error(\"VelocityJS: Trying to set 'easing' to an invalid value:\", value);\n    }\n}\n\n/**\n * Validate a <code>fpsLimit</code> option.\n * @private\n */ function validateFpsLimit(value) {\n    if (value === false) {\n        return 0;\n    } else {\n        var parsed = parseInt(value, 10);\n        if (!isNaN(parsed) && parsed >= 0) {\n            return Math.min(parsed, 60);\n        }\n    }\n    if (value != null) {\n        console.warn(\"VelocityJS: Trying to set 'fpsLimit' to an invalid value:\", value);\n    }\n}\n\n/**\n * Validate a <code>loop</code> option.\n * @private\n */ function validateLoop(value) {\n    if (value === false) {\n        return 0;\n    } else if (value === true) {\n        return true;\n    } else {\n        var parsed = parseInt(value, 10);\n        if (!isNaN(parsed) && parsed >= 0) {\n            return parsed;\n        }\n    }\n    if (value != null) {\n        console.warn(\"VelocityJS: Trying to set 'loop' to an invalid value:\", value);\n    }\n}\n\n/**\n * Validate a <code>progress</code> option.\n * @private\n */ function validateProgress(value) {\n    if (isFunction(value)) {\n        return value;\n    }\n    if (value != null) {\n        console.warn(\"VelocityJS: Trying to set 'progress' to an invalid value:\", value);\n    }\n}\n\n/**\n * Validate a <code>promise</code> option.\n * @private\n */ function validatePromise(value) {\n    if (isBoolean(value)) {\n        return value;\n    }\n    if (value != null) {\n        console.warn(\"VelocityJS: Trying to set 'promise' to an invalid value:\", value);\n    }\n}\n\n/**\n * Validate a <code>promiseRejectEmpty</code> option.\n * @private\n */ function validatePromiseRejectEmpty(value) {\n    if (isBoolean(value)) {\n        return value;\n    }\n    if (value != null) {\n        console.warn(\"VelocityJS: Trying to set 'promiseRejectEmpty' to an invalid value:\", value);\n    }\n}\n\n/**\n * Validate a <code>queue</code> option.\n * @private\n */ function validateQueue(value, noError) {\n    if (value === false || isString(value)) {\n        return value;\n    }\n    if (value != null && !noError) {\n        console.warn(\"VelocityJS: Trying to set 'queue' to an invalid value:\", value);\n    }\n}\n\n/**\n * Validate a <code>repeat</code> option.\n * @private\n */ function validateRepeat(value) {\n    if (value === false) {\n        return 0;\n    } else if (value === true) {\n        return true;\n    } else {\n        var parsed = parseInt(value, 10);\n        if (!isNaN(parsed) && parsed >= 0) {\n            return parsed;\n        }\n    }\n    if (value != null) {\n        console.warn(\"VelocityJS: Trying to set 'repeat' to an invalid value:\", value);\n    }\n}\n\n/**\n * Validate a <code>speed</code> option.\n * @private\n */ function validateSpeed(value) {\n    if (isNumber(value)) {\n        return value;\n    }\n    if (value != null) {\n        console.error(\"VelocityJS: Trying to set 'speed' to an invalid value:\", value);\n    }\n}\n\n/**\n * Validate a <code>sync</code> option.\n * @private\n */ function validateSync(value) {\n    if (isBoolean(value)) {\n        return value;\n    }\n    if (value != null) {\n        console.error(\"VelocityJS: Trying to set 'sync' to an invalid value:\", value);\n    }\n}\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Velocity version (should grab from package.json during build).\n */ var VelocityStatic;\n\n(function(VelocityStatic) {\n    VelocityStatic.version = \"2.0.2\";\n})(VelocityStatic || (VelocityStatic = {}));\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Core \"Velocity\" function.\n */\nfunction VelocityFn() {\n    var __args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        __args[_i] = arguments[_i];\n    }\n    var\n    /**\n     * A shortcut to the default options.\n     */\n    defaults = VelocityStatic.defaults,\n    /**\n     * Shortcut to arguments for file size.\n     */\n    _arguments = arguments,\n    /**\n     * Cache of the first argument - this is used often enough to be saved.\n     */\n    args0 = _arguments[0],\n    /**\n     * To allow for expressive CoffeeScript code, Velocity supports an\n     * alternative syntax in which \"elements\" (or \"e\"), \"properties\" (or\n     * \"p\"), and \"options\" (or \"o\") objects are defined on a container\n     * object that's passed in as Velocity's sole argument.\n     *\n     * Note: Some browsers automatically populate arguments with a\n     * \"properties\" object. We detect it by checking for its default\n     * \"names\" property.\n     */\n    // TODO: Confirm which browsers - if <=IE8 the we can drop completely\n    syntacticSugar = isPlainObject(args0) && (args0.p || (isPlainObject(args0.properties) && !args0.properties.names || isString(args0.properties)));\n    var\n    /**\n     *  When Velocity is called via the utility function (Velocity()),\n     * elements are explicitly passed in as the first parameter. Thus,\n     * argument positioning varies.\n     */\n    argumentIndex = 0,\n    /**\n     * The list of elements, extended with Promise and Velocity.\n     */\n    elements,\n    /**\n     * The properties being animated. This can be a string, in which case it\n     * is either a function for these elements, or it is a \"named\" animation\n     * sequence to use instead. Named sequences start with either \"callout.\"\n     * or \"transition.\". When used as a callout the values will be reset\n     * after finishing. When used as a transtition then there is no special\n     * handling after finishing.\n     */\n    propertiesMap,\n    /**\n     * Options supplied, this will be mapped and validated into\n     * <code>options</code>.\n     */\n    optionsMap,\n    /**\n     * If called via a chain then this contains the <b>last</b> calls\n     * animations. If this does not have a value then any access to the\n     * element's animations needs to be to the currently-running ones.\n     */\n    animations,\n    /**\n     * The promise that is returned.\n     */\n    promise,\n    // Used when the animation is finished\n    resolver,\n    // Used when there was an issue with one or more of the Velocity arguments\n    rejecter;\n    //console.log(\"Velocity\", _arguments)\n    // First get the elements, and the animations connected to the last call if\n    // this is chained.\n    // TODO: Clean this up a bit\n    // TODO: Throw error if the chain is called with elements as the first argument. isVelocityResult(this) && ( (isNode(arg0) || isWrapped(arg0)) && arg0 == this)\n        if (isNode(this)) {\n        // This is from a chain such as document.getElementById(\"\").velocity(...)\n        elements = [ this ];\n    } else if (isWrapped(this)) {\n        // This might be a chain from something else, but if chained from a\n        // previous Velocity() call then grab the animations it's related to.\n        elements = Object.assign([], this);\n        if (isVelocityResult(this)) {\n            animations = this.velocity.animations;\n        }\n    } else if (syntacticSugar) {\n        elements = Object.assign([], args0.elements || args0.e);\n        argumentIndex++;\n    } else if (isNode(args0)) {\n        elements = Object.assign([], [ args0 ]);\n        argumentIndex++;\n    } else if (isWrapped(args0)) {\n        elements = Object.assign([], args0);\n        argumentIndex++;\n    }\n    // Allow elements to be chained.\n        if (elements) {\n        defineProperty(elements, \"velocity\", VelocityFn.bind(elements));\n        if (animations) {\n            defineProperty(elements.velocity, \"animations\", animations);\n        }\n    }\n    // Next get the propertiesMap and options.\n        if (syntacticSugar) {\n        propertiesMap = getValue(args0.properties, args0.p);\n    } else {\n        // TODO: Should be possible to call Velocity(\"pauseAll\") - currently not possible\n        propertiesMap = _arguments[argumentIndex++];\n    }\n    // Get any options map passed in as arguments first, expand any direct\n    // options if possible.\n        var isReverse = propertiesMap === \"reverse\", isAction = !isReverse && isString(propertiesMap), opts = syntacticSugar ? getValue(args0.options, args0.o) : _arguments[argumentIndex];\n    if (isPlainObject(opts)) {\n        optionsMap = opts;\n    }\n    // Create the promise if supported and wanted.\n        if (Promise && getValue(optionsMap && optionsMap.promise, defaults.promise)) {\n        promise = new Promise(function(_resolve, _reject) {\n            rejecter = _reject;\n            // IMPORTANT:\n            // If a resolver tries to run on a Promise then it will wait until\n            // that Promise resolves - but in this case we're running on our own\n            // Promise, so need to make sure it's not seen as one. Setting these\n            // values to <code>undefined</code> for the duration of the resolve.\n            // Due to being an async call, they should be back to \"normal\"\n            // before the <code>.then()</code> function gets called.\n                        resolver = function(args) {\n                if (isVelocityResult(args)) {\n                    var _then = args && args.then;\n                    if (_then) {\n                        args.then = undefined;\n // Preserving enumeration etc\n                                        }\n                    _resolve(args, _then);\n                } else {\n                    _resolve(args);\n                }\n            };\n        });\n\t\tpromise = promise.then(function(args, _then) {\n\t\t\tif (_then) {\n\t\t\t\targs.then = _then\n\t\t\t}\n\t\t\treturn args\n\t\t})\n        if (elements) {\n            defineProperty(elements, \"then\", promise.then.bind(promise));\n            defineProperty(elements, \"catch\", promise.catch.bind(promise));\n            if (promise.finally) {\n                // Semi-standard\n                defineProperty(elements, \"finally\", promise.finally.bind(promise));\n            }\n        }\n    }\n    var promiseRejectEmpty = getValue(optionsMap && optionsMap.promiseRejectEmpty, defaults.promiseRejectEmpty);\n    if (promise) {\n        if (!elements && !isAction) {\n            if (promiseRejectEmpty) {\n                rejecter(\"Velocity: No elements supplied, if that is deliberate then pass `promiseRejectEmpty:false` as an option. Aborting.\");\n            } else {\n                resolver();\n            }\n        } else if (!propertiesMap) {\n            if (promiseRejectEmpty) {\n                rejecter(\"Velocity: No properties supplied, if that is deliberate then pass `promiseRejectEmpty:false` as an option. Aborting.\");\n            } else {\n                resolver();\n            }\n        }\n    }\n    if (!elements && !isAction || !propertiesMap) {\n        return promise;\n    }\n    // NOTE: Can't use isAction here due to type inference - there are callbacks\n    // between so the type isn't considered safe.\n        if (isAction) {\n        var args = [], promiseHandler = promise && {\n            _promise: promise,\n            _resolver: resolver,\n            _rejecter: rejecter\n        };\n        while (argumentIndex < _arguments.length) {\n            args.push(_arguments[argumentIndex++]);\n        }\n        // Velocity's behavior is categorized into \"actions\". If a string is\n        // passed in instead of a propertiesMap then that will call a function\n        // to do something special to the animation linked.\n        // There is one special case - \"reverse\" - which is handled differently,\n        // by being stored on the animation and then expanded when the animation\n        // starts.\n                var action = propertiesMap.replace(/\\..*$/, \"\"), callback = VelocityStatic.Actions[action] || VelocityStatic.Actions[\"default\"];\n        if (callback) {\n            var result = callback(args, elements, promiseHandler, propertiesMap);\n            if (result !== undefined) {\n                return result;\n            }\n        } else {\n            console.warn(\"VelocityJS: Unknown action:\", propertiesMap);\n        }\n    } else if (isPlainObject(propertiesMap) || isReverse) {\n        /**\n         * The options for this set of animations.\n         */\n        var options = {};\n        var isSync = defaults.sync;\n        // Private options first - set as non-enumerable, and starting with an\n        // underscore so we can filter them out.\n                if (promise) {\n            defineProperty(options, \"_promise\", promise);\n            defineProperty(options, \"_rejecter\", rejecter);\n            defineProperty(options, \"_resolver\", resolver);\n        }\n        defineProperty(options, \"_ready\", 0);\n        defineProperty(options, \"_started\", 0);\n        defineProperty(options, \"_completed\", 0);\n        defineProperty(options, \"_total\", 0);\n        // Now check the optionsMap\n                if (isPlainObject(optionsMap)) {\n            options.duration = getValue(validateDuration(optionsMap.duration), defaults.duration);\n            options.delay = getValue(validateDelay(optionsMap.delay), defaults.delay);\n            // Need the extra fallback here in case it supplies an invalid\n            // easing that we need to overrride with the default.\n                        options.easing = validateEasing(getValue(optionsMap.easing, defaults.easing), options.duration) || validateEasing(defaults.easing, options.duration);\n            options.loop = getValue(validateLoop(optionsMap.loop), defaults.loop);\n            options.repeat = options.repeatAgain = getValue(validateRepeat(optionsMap.repeat), defaults.repeat);\n            if (optionsMap.speed != null) {\n                options.speed = getValue(validateSpeed(optionsMap.speed), 1);\n            }\n            if (isBoolean(optionsMap.promise)) {\n                options.promise = optionsMap.promise;\n            }\n            options.queue = getValue(validateQueue(optionsMap.queue), defaults.queue);\n            if (optionsMap.mobileHA && !VelocityStatic.State.isGingerbread) {\n                /* When set to true, and if this is a mobile device, mobileHA automatically enables hardware acceleration (via a null transform hack)\n                 on animating elements. HA is removed from the element at the completion of its animation. */\n                /* Note: Android Gingerbread doesn't support HA. If a null transform hack (mobileHA) is in fact set, it will prevent other tranform subproperties from taking effect. */\n                /* Note: You can read more about the use of mobileHA in Velocity's documentation: VelocityJS.org/#mobileHA. */\n                options.mobileHA = true;\n            }\n            if (!isReverse) {\n                if (optionsMap.display != null) {\n                    propertiesMap.display = optionsMap.display;\n                    console.error(\"Deprecated 'options.display' used, this is now a property:\", optionsMap.display);\n                }\n                if (optionsMap.visibility != null) {\n                    propertiesMap.visibility = optionsMap.visibility;\n                    console.error(\"Deprecated 'options.visibility' used, this is now a property:\", optionsMap.visibility);\n                }\n            }\n            // TODO: Allow functional options for different options per element\n                        var optionsBegin = validateBegin(optionsMap.begin), optionsComplete = validateComplete(optionsMap.complete), optionsProgress = validateProgress(optionsMap.progress), optionsSync = validateSync(optionsMap.sync);\n            if (optionsBegin != null) {\n                options.begin = optionsBegin;\n            }\n            if (optionsComplete != null) {\n                options.complete = optionsComplete;\n            }\n            if (optionsProgress != null) {\n                options.progress = optionsProgress;\n            }\n            if (optionsSync != null) {\n                isSync = optionsSync;\n            }\n        } else if (!syntacticSugar) {\n            // Expand any direct options if possible.\n            var duration = validateDuration(_arguments[argumentIndex], true);\n            var offset = 0;\n            if (duration !== undefined) {\n                offset++;\n                options.duration = duration;\n            }\n            if (!isFunction(_arguments[argumentIndex + offset])) {\n                // Despite coming before Complete, we can't pass a fn easing\n                var easing = validateEasing(_arguments[argumentIndex + offset], getValue(options && validateDuration(options.duration), defaults.duration), true);\n                if (easing !== undefined) {\n                    offset++;\n                    options.easing = easing;\n                }\n            }\n            var complete = validateComplete(_arguments[argumentIndex + offset], true);\n            if (complete !== undefined) {\n                options.complete = complete;\n            }\n            options.loop = defaults.loop;\n            options.repeat = options.repeatAgain = defaults.repeat;\n        }\n        if (isReverse && options.queue === false) {\n            throw new Error(\"VelocityJS: Cannot reverse a queue:false animation.\");\n        }\n        /* When a set of elements is targeted by a Velocity call, the set is broken up and each element has the current Velocity call individually queued onto it.\n         In this way, each element's existing queue is respected; some elements may already be animating and accordingly should not have this current Velocity call triggered immediately. */\n        /* In each queue, tween data is processed for each animating property then pushed onto the call-wide calls array. When the last element in the set has had its tweens processed,\n         the call array is pushed to VelocityStatic.State.calls for live processing by the requestAnimationFrame tick. */        var rootAnimation = {\n            _prev: undefined,\n            _next: undefined,\n            _flags: isSync ? 32 /* SYNC */ : 0,\n            options: options,\n            percentComplete: 0,\n            //element: element,\n            elements: elements,\n            ellapsedTime: 0,\n            timeStart: 0\n        };\n        animations = [];\n        for (var index = 0; index < elements.length; index++) {\n            var element = elements[index];\n            var flags = 0;\n            if (isNode(element)) {\n                if (isReverse) {\n                    var lastAnimation = Data(element).lastAnimationList[options.queue];\n                    propertiesMap = lastAnimation && lastAnimation.tweens;\n                    if (!propertiesMap) {\n                        console.error(\"VelocityJS: Attempting to reverse an animation on an element with no previous animation:\", element);\n                        continue;\n                    }\n                    flags |= 64 /* REVERSE */ & ~(lastAnimation._flags & 64 /* REVERSE */);\n                }\n                var tweens = createEmptyObject(), animation = Object.assign({\n                    element: element,\n                    tweens: tweens\n                }, rootAnimation);\n                options._total++;\n                animation._flags |= flags;\n                animations.push(animation);\n                if (isReverse) {\n                    // In this case we're using the previous animation, so\n                    // it will be expanded correctly when that one runs.\n                    animation.tweens = propertiesMap;\n                } else {\n                    VelocityStatic.expandProperties(animation, propertiesMap);\n                }\n                VelocityStatic.queue(element, animation, options.queue);\n            }\n        }\n        if (VelocityStatic.State.isTicking === false) {\n            // If the animation tick isn't running, start it. (Velocity shuts it\n            // off when there are no active calls to process.)\n            VelocityStatic.tick();\n        }\n        if (animations) {\n            defineProperty(elements.velocity, \"animations\", animations);\n        }\n    }\n    /***************\n     Chaining\n     ***************/\n    /* Return the elements back to the call chain, with wrapped elements taking precedence in case Velocity was called via the $.fn. extension. */    return elements || promise;\n}\n\n/***************\n Summary\n ***************/\n/*\n - CSS: CSS stack that works independently from the rest of Velocity.\n - animate(): Core animation method that iterates over the targeted elements and queues the incoming call onto each element individually.\n - Pre-Queueing: Prepare the element for animation by instantiating its data cache and processing the call's options.\n - Queueing: The logic that runs once the call has reached its point of execution in the element's queue stack.\n Most logic is placed here to avoid risking it becoming stale (if the element's properties have changed).\n - Pushing: Consolidation of the tween data followed by its push onto the global in-progress calls container.\n - tick(): The single requestAnimationFrame loop responsible for tweening all in-progress calls.\n - completeCall(): Handles the cleanup process for each Velocity call.\n */\n/*********************\n Helper Functions\n *********************/\n/* IE detection. Gist: https://gist.github.com/julianshapiro/9098609 */\nvar IE = function() {\n    if (document.documentMode) {\n        return document.documentMode;\n    } else {\n        for (var i = 7; i > 4; i--) {\n            var div = document.createElement(\"div\");\n            div.innerHTML = \"\\x3c!--[if IE \" + i + \"]><span></span><![endif]--\\x3e\";\n            if (div.getElementsByTagName(\"span\").length) {\n                div = null;\n                return i;\n            }\n        }\n    }\n    return undefined;\n}();\n\n/******************\n Unsupported\n ******************/ if (IE <= 8) {\n    throw new Error(\"VelocityJS cannot run on Internet Explorer 8 or earlier\");\n}\n\nif (window === this) {\n    /*\n     * Both jQuery and Zepto allow their $.fn object to be extended to allow\n     * wrapped elements to be subjected to plugin calls. If either framework is\n     * loaded, register a \"velocity\" extension pointing to Velocity's core\n     * animate() method. Velocity also registers itself onto a global container\n     * (window.jQuery || window.Zepto || window) so that certain features are\n     * accessible beyond just a per-element scope. Accordingly, Velocity can\n     * both act on wrapped DOM elements and stand alone for targeting raw DOM\n     * elements.\n     */\n    var patch = VelocityStatic.patch, jQuery = window.jQuery, Zepto = window.Zepto;\n    patch(window, true);\n    patch(Element && Element.prototype);\n    patch(NodeList && NodeList.prototype);\n    patch(HTMLCollection && HTMLCollection.prototype);\n    patch(jQuery, true);\n    patch(jQuery && jQuery.fn);\n    patch(Zepto, true);\n    patch(Zepto && Zepto.fn);\n}\n\n/******************\n Known Issues\n ******************/\n/* The CSS spec mandates that the translateX/Y/Z transforms are %-relative to the element itself -- not its parent.\n Velocity, however, doesn't make this distinction. Thus, converting to or from the % unit with these subproperties\n will produce an inaccurate conversion value. The same issue exists with the cx/cy attributes of SVG circles and ellipses. */ var _loop_3 = function(key) {\n    var value = VelocityStatic[key];\n    if (isString(value) || isNumber(value) || isBoolean(value)) {\n        Object.defineProperty(VelocityFn, key, {\n            enumerable: PUBLIC_MEMBERS.indexOf(key) >= 0,\n            get: function() {\n                return VelocityStatic[key];\n            },\n            set: function(value) {\n                VelocityStatic[key] = value;\n            }\n        });\n    } else {\n        Object.defineProperty(VelocityFn, key, {\n            enumerable: PUBLIC_MEMBERS.indexOf(key) >= 0,\n            get: function() {\n                return VelocityStatic[key];\n            }\n        });\n    }\n};\n\n/*\n * VelocityJS.org (C) 2014-2017 Julian Shapiro.\n *\n * Licensed under the MIT license. See LICENSE file in the project root for details.\n *\n * Merge the VelocityStatic namespace onto the Velocity function for external\n * use. This is done as a read-only way. Any attempt to change these values will\n * be allowed.\n */ for (var key in VelocityStatic) {\n    _loop_3(key);\n}\n\treturn VelocityFn;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmVsb2NpdHktYW5pbWF0ZS92ZWxvY2l0eS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92ZWxvY2l0eS1hbmltYXRlL3ZlbG9jaXR5LmpzPzU4OWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIFZlbG9jaXR5SlMub3JnICgyLjAuMikgKEMpIDIwMTQgSnVsaWFuIFNoYXBpcm8uIE1JVCBAbGljZW5zZTogZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlICovXG4oZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0ZGVmaW5lKCd2ZWxvY2l0eS1hbmltYXRlJywgW10sIGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH0gZWxzZSB7XG5cdFx0cm9vdFsnVmVsb2NpdHknXSA9IGZhY3RvcnkoKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbigpIHtcblxudmFyIF9fYXNzaWduID0gdGhpcyAmJiB0aGlzLl9fYXNzaWduIHx8IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICpcbiAqIENvbnN0YW50cyBhbmQgZGVmYXVsdHMuIFRoZXNlIHZhbHVlcyBzaG91bGQgbmV2ZXIgY2hhbmdlIHdpdGhvdXQgYSBNSU5PUlxuICogdmVyc2lvbiBidW1wLlxuICovXG4vL1tcImNvbXBsZXRlQ2FsbFwiLCBcIkNTU1wiLCBcIlN0YXRlXCIsIFwiZ2V0RWFzaW5nXCIsIFwiRWFzaW5nc1wiLCBcImRhdGFcIiwgXCJkZWJ1Z1wiLCBcImRlZmF1bHRzXCIsIFwiaG9va1wiLCBcImluaXRcIiwgXCJtb2NrXCIsIFwicGF1c2VBbGxcIiwgXCJxdWV1ZVwiLCBcImRlcXVldWVcIiwgXCJmcmVlQW5pbWF0aW9uQ2FsbFwiLCBcIlJlZGlyZWN0c1wiLCBcIlJlZ2lzdGVyRWZmZWN0XCIsIFwicmVzdW1lQWxsXCIsIFwiUnVuU2VxdWVuY2VcIiwgXCJsYXN0VGlja1wiLCBcInRpY2tcIiwgXCJ0aW1lc3RhbXBcIiwgXCJleHBhbmRUd2VlblwiLCBcInZlcnNpb25cIl1cbnZhciBQVUJMSUNfTUVNQkVSUyA9IFsgXCJ2ZXJzaW9uXCIsIFwiUmVnaXN0ZXJFZmZlY3RcIiwgXCJzdHlsZVwiLCBcInBhdGNoXCIsIFwidGltZXN0YW1wXCIgXTtcblxuLyoqXG4gKiBXaXRob3V0IHRoaXMgaXQgd2lsbCBvbmx5IHVuLXByZWZpeCBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBhIHZhbGlkIFwibm9ybWFsXCJcbiAqIHZlcnNpb24uXG4gKi8gdmFyIEFMTF9WRU5ET1JfUFJFRklYRVMgPSB0cnVlO1xuXG52YXIgRFVSQVRJT05fRkFTVCA9IDIwMDtcblxudmFyIERVUkFUSU9OX05PUk1BTCA9IDQwMDtcblxudmFyIERVUkFUSU9OX1NMT1cgPSA2MDA7XG5cbnZhciBGVVpaWV9NU19QRVJfU0VDT05EID0gOTgwO1xuXG52YXIgREVGQVVMVF9DQUNIRSA9IHRydWU7XG5cbnZhciBERUZBVUxUX0RFTEFZID0gMDtcblxudmFyIERFRkFVTFRfRFVSQVRJT04gPSBEVVJBVElPTl9OT1JNQUw7XG5cbnZhciBERUZBVUxUX0VBU0lORyA9IFwic3dpbmdcIjtcblxudmFyIERFRkFVTFRfRlBTTElNSVQgPSA2MDtcblxudmFyIERFRkFVTFRfTE9PUCA9IDA7XG5cbnZhciBERUZBVUxUX1BST01JU0UgPSB0cnVlO1xuXG52YXIgREVGQVVMVF9QUk9NSVNFX1JFSkVDVF9FTVBUWSA9IHRydWU7XG5cbnZhciBERUZBVUxUX1FVRVVFID0gXCJcIjtcblxudmFyIERFRkFVTFRfUkVQRUFUID0gMDtcblxudmFyIERFRkFVTFRfU1BFRUQgPSAxO1xuXG52YXIgREVGQVVMVF9TWU5DID0gdHJ1ZTtcblxudmFyIFRXRUVOX05VTUJFUl9SRUdFWCA9IC9bXFxkXFwuLV0vO1xuXG52YXIgQ0xBU1NOQU1FID0gXCJ2ZWxvY2l0eS1hbmltYXRpbmdcIjtcblxudmFyIER1cmF0aW9uID0ge1xuICAgIGZhc3Q6IERVUkFUSU9OX0ZBU1QsXG4gICAgbm9ybWFsOiBEVVJBVElPTl9OT1JNQUwsXG4gICAgc2xvdzogRFVSQVRJT05fU0xPV1xufTtcblxuLypcbiAqIFZlbG9jaXR5SlMub3JnIChDKSAyMDE0LTIwMTcgSnVsaWFuIFNoYXBpcm8uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGRldGFpbHMuXG4gKlxuICogUnVudGltZSB0eXBlIGNoZWNraW5nIG1ldGhvZHMuXG4gKi8gZnVuY3Rpb24gaXNCb29sZWFuKHZhcmlhYmxlKSB7XG4gICAgcmV0dXJuIHZhcmlhYmxlID09PSB0cnVlIHx8IHZhcmlhYmxlID09PSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIodmFyaWFibGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhcmlhYmxlID09PSBcIm51bWJlclwiO1xufVxuXG4vKipcbiAqIEZhc3RlciB3YXkgdG8gcGFyc2UgYSBzdHJpbmcvbnVtYmVyIGFzIGEgbnVtYmVyIGh0dHBzOi8vanNwZXJmLmNvbS9udW1iZXItdnMtcGFyc2VpbnQtdnMtcGx1cy8zXG4gKiBAcGFyYW0gdmFyaWFibGUgVGhlIGdpdmVuIHN0cmluZyBvciBudW1iZXJcbiAqIEByZXR1cm5zIHt2YXJpYWJsZSBpcyBudW1iZXJ9IFJldHVybnMgYm9vbGVhbiB0cnVlIGlmIGl0IGlzIGEgbnVtYmVyLCBmYWxzZSBvdGhlcndpc2VcbiAqLyBmdW5jdGlvbiBpc051bWJlcldoZW5QYXJzZWQodmFyaWFibGUpIHtcbiAgICByZXR1cm4gIWlzTmFOKE51bWJlcih2YXJpYWJsZSkpO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZyh2YXJpYWJsZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFyaWFibGUgPT09IFwic3RyaW5nXCI7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFyaWFibGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhcmlhYmxlKSA9PT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiO1xufVxuXG5mdW5jdGlvbiBpc05vZGUodmFyaWFibGUpIHtcbiAgICByZXR1cm4gISEodmFyaWFibGUgJiYgdmFyaWFibGUubm9kZVR5cGUpO1xufVxuXG5mdW5jdGlvbiBpc1ZlbG9jaXR5UmVzdWx0KHZhcmlhYmxlKSB7XG4gICAgcmV0dXJuIHZhcmlhYmxlICYmIGlzTnVtYmVyKHZhcmlhYmxlLmxlbmd0aCkgJiYgaXNGdW5jdGlvbih2YXJpYWJsZS52ZWxvY2l0eSk7XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xufVxuXG4vKiBEZXRlcm1pbmUgaWYgdmFyaWFibGUgaXMgYW4gYXJyYXktbGlrZSB3cmFwcGVkIGpRdWVyeSwgWmVwdG8gb3Igc2ltaWxhciBlbGVtZW50LCBvciBldmVuIGEgTm9kZUxpc3QgZXRjLiAqL1xuLyogTk9URTogSFRNTEZvcm1FbGVtZW50cyBhbHNvIGhhdmUgYSBsZW5ndGguICovIGZ1bmN0aW9uIGlzV3JhcHBlZCh2YXJpYWJsZSkge1xuICAgIHJldHVybiB2YXJpYWJsZSAmJiB2YXJpYWJsZSAhPT0gd2luZG93ICYmIGlzTnVtYmVyKHZhcmlhYmxlLmxlbmd0aCkgJiYgIWlzU3RyaW5nKHZhcmlhYmxlKSAmJiAhaXNGdW5jdGlvbih2YXJpYWJsZSkgJiYgIWlzTm9kZSh2YXJpYWJsZSkgJiYgKHZhcmlhYmxlLmxlbmd0aCA9PT0gMCB8fCBpc05vZGUodmFyaWFibGVbMF0pKTtcbn1cblxuZnVuY3Rpb24gaXNTVkcodmFyaWFibGUpIHtcbiAgICByZXR1cm4gU1ZHRWxlbWVudCAmJiB2YXJpYWJsZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFyaWFibGUpIHtcbiAgICBpZiAoIXZhcmlhYmxlIHx8IHR5cGVvZiB2YXJpYWJsZSAhPT0gXCJvYmplY3RcIiB8fCB2YXJpYWJsZS5ub2RlVHlwZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFyaWFibGUpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhcmlhYmxlKTtcbiAgICByZXR1cm4gIXByb3RvIHx8IHByb3RvLmhhc093blByb3BlcnR5KFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eU9iamVjdCh2YXJpYWJsZSkge1xuICAgIGZvciAodmFyIG5hbWVfMSBpbiB2YXJpYWJsZSkge1xuICAgICAgICBpZiAodmFyaWFibGUuaGFzT3duUHJvcGVydHkobmFtZV8xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGFuIGVtcHR5IG9iamVjdCB3aXRob3V0IGFueSBwcm90b3R5cGUgY2hhaW4uXG4gKi8gZnVuY3Rpb24gY3JlYXRlRW1wdHlPYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbi8qKlxuICogVGhlIDxzdHJvbmc+PGNvZGU+ZGVmaW5lUHJvcGVydHkoKTwvY29kZT48L3N0cm9uZz4gZnVuY3Rpb24gcHJvdmlkZXMgYVxuICogc2hvcnRjdXQgdG8gZGVmaW5pbmcgYSBwcm9wZXJ0eSB0aGF0IGNhbm5vdCBiZSBhY2NpZGVudGFsbHkgaXRlcmF0ZWQgYWNyb3NzLlxuICovIGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChwcm90bykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTaGltIHRvIGdldCB0aGUgY3VycmVudCBtaWxsaXNlY29uZHMgLSBvbiBhbnl0aGluZyBleGNlcHQgb2xkIElFIGl0J2xsIHVzZVxuICogRGF0ZS5ub3coKSBhbmQgc2F2ZSBjcmVhdGluZyBhbiBvYmplY3QuIElmIHRoYXQgZG9lc24ndCBleGlzdCB0aGVuIGl0J2xsXG4gKiBjcmVhdGUgb25lIHRoYXQgZ2V0cyBHQy5cbiAqLyB2YXIgX25vdyA9IERhdGUubm93ID8gRGF0ZS5ub3cgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSB2YWx1ZSBiZWxvbmdzIHRvIGFuIGFycmF5XG4gKiBodHRwczovL2pzcGVyZi5jb20vaW5jbHVkZXMtdnMtaW5kZXhvZi12cy13aGlsZS1sb29wLzZcbiAqIEBwYXJhbSBhcnJheSBUaGUgZ2l2ZW4gYXJyYXlcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgZ2l2ZW4gZWxlbWVudCB0byBjaGVjayBpZiBpdCBpcyBwYXJ0IG9mIHRoZSBhcnJheVxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgaXQgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcbiAqLyBmdW5jdGlvbiBfaW5BcnJheShhcnJheSwgdmFsdWUpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGFycmF5W2krK10gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBlbGVtZW50IG9yIGFycmF5LWxpa2UgZWxlbWVudCBsaXN0IGludG8gYW4gYXJyYXkgaWYgbmVlZGVkLlxuICovIGZ1bmN0aW9uIHNhbml0aXplRWxlbWVudHMoZWxlbWVudHMpIHtcbiAgICBpZiAoaXNOb2RlKGVsZW1lbnRzKSkge1xuICAgICAgICByZXR1cm4gWyBlbGVtZW50cyBdO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudHM7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlKGFyZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgX2FyZ3MgPSBhcmd1bWVudHM7IGkgPCBfYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX2FyZyA9IF9hcmdzW2ldO1xuICAgICAgICBpZiAoX2FyZyAhPT0gdW5kZWZpbmVkICYmIF9hcmcgPT09IF9hcmcpIHtcbiAgICAgICAgICAgIHJldHVybiBfYXJnO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEFkZCBhIHNpbmdsZSBjbGFzc05hbWUgdG8gYW4gRWxlbWVudC5cbiAqLyBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSAoZWxlbWVudC5jbGFzc05hbWUubGVuZ3RoID8gXCIgXCIgOiBcIlwiKSArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBzaW5nbGUgY2xhc3NOYW1lIGZyb20gYW4gRWxlbWVudC5cbiAqLyBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRPRE86IE5lZWQgc29tZSBqc3BlcmYgdGVzdHMgb24gcGVyZm9ybWFuY2UgLSBjYW4gd2UgZ2V0IHJpZCBvZiB0aGUgcmVnZXggYW5kIG1heWJlIHVzZSBzcGxpdCAvIGFycmF5IG1hbmlwdWxhdGlvbj9cbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUudG9TdHJpbmcoKS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIiArIGNsYXNzTmFtZSArIFwiKFxcXFxzfCQpXCIsIFwiZ2lcIiksIFwiIFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLypcbiAqIFZlbG9jaXR5SlMub3JnIChDKSAyMDE0LTIwMTcgSnVsaWFuIFNoYXBpcm8uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGRldGFpbHMuXG4gKlxuICogQWN0aW9ucyB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgYnkgcGFzc2luZyBhIHN0cmluZyBpbnN0ZWFkIG9mIGEgcHJvcGVydGllc01hcC5cbiAqLyB2YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIC8qKlxuICAgICAqIEFjdGlvbnMgY2Fubm90IGJlIHJlcGxhY2VkIGlmIHRoZXkgYXJlIGludGVybmFsIChoYXNPd25Qcm9wZXJ0eSBpcyBmYWxzZVxuICAgICAqIGJ1dCB0aGV5IHN0aWxsIGV4aXN0KS4gT3RoZXJ3aXNlIHRoZXkgY2FuIGJlIHJlcGxhY2VkIGJ5IHVzZXJzLlxuICAgICAqXG4gICAgICogQWxsIGV4dGVybmFsIG1ldGhvZCBjYWxscyBzaG91bGQgYmUgdXNpbmcgYWN0aW9ucyByYXRoZXIgdGhhbiBzdWItY2FsbHNcbiAgICAgKiBvZiBWZWxvY2l0eSBpdHNlbGYuXG4gICAgICovXG4gICAgVmVsb2NpdHlTdGF0aWMuQWN0aW9ucyA9IGNyZWF0ZUVtcHR5T2JqZWN0KCk7XG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZWdpc3RlciBhbiBhY3Rpb24uIFRoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZCBieSB1c2Vyc1xuICAgICAqIGRpcmVjdGx5LCBpbnN0ZWFkIGl0IHNob3VsZCBiZSBjYWxsZWQgdmlhICBhbiBhY3Rpb246PGJyLz5cbiAgICAgKiA8Y29kZT5WZWxvY2l0eShcInJlZ2lzdGVyQWN0aW9uXCIsIFwibmFtZVwiLCBWZWxvY2l0eUFjdGlvbkZuKTs8L2NvZGU+XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqLyAgICBmdW5jdGlvbiByZWdpc3RlckFjdGlvbihhcmdzLCBpbnRlcm5hbCkge1xuICAgICAgICB2YXIgbmFtZSA9IGFyZ3NbMF0sIGNhbGxiYWNrID0gYXJnc1sxXTtcbiAgICAgICAgaWYgKCFpc1N0cmluZyhuYW1lKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVmVsb2NpdHlKUzogVHJ5aW5nIHRvIHNldCAncmVnaXN0ZXJBY3Rpb24nIG5hbWUgdG8gYW4gaW52YWxpZCB2YWx1ZTpcIiwgbmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJWZWxvY2l0eUpTOiBUcnlpbmcgdG8gc2V0ICdyZWdpc3RlckFjdGlvbicgY2FsbGJhY2sgdG8gYW4gaW52YWxpZCB2YWx1ZTpcIiwgbmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2UgaWYgKFZlbG9jaXR5U3RhdGljLkFjdGlvbnNbbmFtZV0gJiYgIXByb3BlcnR5SXNFbnVtZXJhYmxlKFZlbG9jaXR5U3RhdGljLkFjdGlvbnMsIG5hbWUpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJWZWxvY2l0eUpTOiBUcnlpbmcgdG8gb3ZlcnJpZGUgaW50ZXJuYWwgJ3JlZ2lzdGVyQWN0aW9uJyBjYWxsYmFja1wiLCBuYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnRlcm5hbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkoVmVsb2NpdHlTdGF0aWMuQWN0aW9ucywgbmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVmVsb2NpdHlTdGF0aWMuQWN0aW9uc1tuYW1lXSA9IGNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIFZlbG9jaXR5U3RhdGljLnJlZ2lzdGVyQWN0aW9uID0gcmVnaXN0ZXJBY3Rpb247XG4gICAgcmVnaXN0ZXJBY3Rpb24oWyBcInJlZ2lzdGVyQWN0aW9uXCIsIHJlZ2lzdGVyQWN0aW9uIF0sIHRydWUpO1xufSkoVmVsb2NpdHlTdGF0aWMgfHwgKFZlbG9jaXR5U3RhdGljID0ge30pKTtcblxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiYWN0aW9ucy50c1wiIC8+XG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqXG4gKiBEZWZhdWx0IGFjdGlvbi5cbiAqLyB2YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHN0b3AgYWN0aW9uIGlzIHRyaWdnZXJlZCwgdGhlIGVsZW1lbnRzJyBjdXJyZW50bHkgYWN0aXZlIGNhbGwgaXMgaW1tZWRpYXRlbHkgc3RvcHBlZC4gVGhlIGFjdGl2ZSBjYWxsIG1pZ2h0IGhhdmVcbiAgICAgKiBiZWVuIGFwcGxpZWQgdG8gbXVsdGlwbGUgZWxlbWVudHMsIGluIHdoaWNoIGNhc2UgYWxsIG9mIHRoZSBjYWxsJ3MgZWxlbWVudHMgd2lsbCBiZSBzdG9wcGVkLiBXaGVuIGFuIGVsZW1lbnRcbiAgICAgKiBpcyBzdG9wcGVkLCB0aGUgbmV4dCBpdGVtIGluIGl0cyBhbmltYXRpb24gcXVldWUgaXMgaW1tZWRpYXRlbHkgdHJpZ2dlcmVkLlxuICAgICAqIEFuIGFkZGl0aW9uYWwgYXJndW1lbnQgbWF5IGJlIHBhc3NlZCBpbiB0byBjbGVhciBhbiBlbGVtZW50J3MgcmVtYWluaW5nIHF1ZXVlZCBjYWxscy4gRWl0aGVyIHRydWUgKHdoaWNoIGRlZmF1bHRzIHRvIHRoZSBcImZ4XCIgcXVldWUpXG4gICAgICogb3IgYSBjdXN0b20gcXVldWUgc3RyaW5nIGNhbiBiZSBwYXNzZWQgaW4uXG4gICAgICogTm90ZTogVGhlIHN0b3AgY29tbWFuZCBydW5zIHByaW9yIHRvIFZlbG9jaXR5J3MgUXVldWVpbmcgcGhhc2Ugc2luY2UgaXRzIGJlaGF2aW9yIGlzIGludGVuZGVkIHRvIHRha2UgZWZmZWN0ICppbW1lZGlhdGVseSosXG4gICAgICogcmVnYXJkbGVzcyBvZiB0aGUgZWxlbWVudCdzIGN1cnJlbnQgcXVldWUgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxvclNWR0VsZW1lbnRbXX0gZWxlbWVudHMgVGhlIGNvbGxlY3Rpb24gb2YgSFRNTCBvciBTVkcgZWxlbWVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmljdFZlbG9jaXR5T3B0aW9uc30gVGhlIHN0cmljdCBWZWxvY2l0eSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtQcm9taXNlPEhUTUxvclNWR0VsZW1lbnRbXT59IEFuIG9wdGlvbmFsIHByb21pc2UgaWYgdGhlIHVzZXIgdXNlcyBwcm9taXNlc1xuICAgICAqIEBwYXJhbSB7KHZhbHVlPzogKEhUTUxvclNWR0VsZW1lbnRbXSB8IFZlbG9jaXR5UmVzdWx0KSkgPT4gdm9pZH0gcmVzb2x2ZXIgVGhlIHJlc29sdmUgbWV0aG9kIG9mIHRoZSBwcm9taXNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmYXVsdEFjdGlvbihhcmdzLCBlbGVtZW50cywgcHJvbWlzZUhhbmRsZXIsIGFjdGlvbikge1xuICAgICAgICAvLyBUT0RPOiBkZWZhdWx0IGlzIHdyb25nLCBzaG91bGQgYmUgcnVuU2VxdWVuY2UgYmFzZWQsIGFuZCBuZWVkcyBhbGwgYXJndW1lbnRzXG4gICAgICAgIGlmIChpc1N0cmluZyhhY3Rpb24pICYmIFZlbG9jaXR5U3RhdGljLlJlZGlyZWN0c1thY3Rpb25dKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGlzUGxhaW5PYmplY3QoYXJnc1swXSkgPyBhcmdzWzBdIDoge30sIG9wdHNfMSA9IF9fYXNzaWduKHt9LCBvcHRpb25zKSwgZHVyYXRpb25PcmlnaW5hbF8xID0gcGFyc2VGbG9hdChvcHRpb25zLmR1cmF0aW9uKSwgZGVsYXlPcmlnaW5hbF8xID0gcGFyc2VGbG9hdChvcHRpb25zLmRlbGF5KSB8fCAwO1xuICAgICAgICAgICAgLyogSWYgdGhlIGJhY2t3YXJkcyBvcHRpb24gd2FzIHBhc3NlZCBpbiwgcmV2ZXJzZSB0aGUgZWxlbWVudCBzZXQgc28gdGhhdCBlbGVtZW50cyBhbmltYXRlIGZyb20gdGhlIGxhc3QgdG8gdGhlIGZpcnN0LiAqLyAgICAgICAgICAgIGlmIChvcHRzXzEuYmFja3dhcmRzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50cy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBJbmRpdmlkdWFsbHkgdHJpZ2dlciB0aGUgcmVkaXJlY3QgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0IHRvIHByZXZlbnQgdXNlcnMgZnJvbSBoYXZpbmcgdG8gaGFuZGxlIGl0ZXJhdGlvbiBsb2dpYyBpbiB0aGVpciByZWRpcmVjdC4gKi8gICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGVsZW1lbnRJbmRleCkge1xuICAgICAgICAgICAgICAgIC8qIElmIHRoZSBzdGFnZ2VyIG9wdGlvbiB3YXMgcGFzc2VkIGluLCBzdWNjZXNzaXZlbHkgZGVsYXkgZWFjaCBlbGVtZW50IGJ5IHRoZSBzdGFnZ2VyIHZhbHVlIChpbiBtcykuIFJldGFpbiB0aGUgb3JpZ2luYWwgZGVsYXkgdmFsdWUuICovXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQob3B0c18xLnN0YWdnZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHNfMS5kZWxheSA9IGRlbGF5T3JpZ2luYWxfMSArIHBhcnNlRmxvYXQob3B0c18xLnN0YWdnZXIpICogZWxlbWVudEluZGV4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihvcHRzXzEuc3RhZ2dlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0c18xLmRlbGF5ID0gZGVsYXlPcmlnaW5hbF8xICsgb3B0c18xLnN0YWdnZXIuY2FsbChlbGVtZW50LCBlbGVtZW50SW5kZXgsIGVsZW1lbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIElmIHRoZSBkcmFnIG9wdGlvbiB3YXMgcGFzc2VkIGluLCBzdWNjZXNzaXZlbHkgaW5jcmVhc2UvZGVjcmVhc2UgKGRlcGVuZGluZyBvbiB0aGUgcHJlc2Vuc2Ugb2Ygb3B0cy5iYWNrd2FyZHMpXG4gICAgICAgICAgICAgICAgIHRoZSBkdXJhdGlvbiBvZiBlYWNoIGVsZW1lbnQncyBhbmltYXRpb24sIHVzaW5nIGZsb29ycyB0byBwcmV2ZW50IHByb2R1Y2luZyB2ZXJ5IHNob3J0IGR1cmF0aW9ucy4gKi8gICAgICAgICAgICAgICAgaWYgKG9wdHNfMS5kcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIERlZmF1bHQgdGhlIGR1cmF0aW9uIG9mIFVJIHBhY2sgZWZmZWN0cyAoY2FsbG91dHMgYW5kIHRyYW5zaXRpb25zKSB0byAxMDAwbXMgaW5zdGVhZCBvZiB0aGUgdXN1YWwgZGVmYXVsdCBkdXJhdGlvbiBvZiA0MDBtcy4gKi9cbiAgICAgICAgICAgICAgICAgICAgb3B0c18xLmR1cmF0aW9uID0gZHVyYXRpb25PcmlnaW5hbF8xIHx8ICgvXihjYWxsb3V0fHRyYW5zaXRpb24pLy50ZXN0KGFjdGlvbikgPyAxZTMgOiBERUZBVUxUX0RVUkFUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgLyogRm9yIGVhY2ggZWxlbWVudCwgdGFrZSB0aGUgZ3JlYXRlciBkdXJhdGlvbiBvZjogQSkgYW5pbWF0aW9uIGNvbXBsZXRpb24gcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgb3JpZ2luYWwgZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICBCKSA3NSUgb2YgdGhlIG9yaWdpbmFsIGR1cmF0aW9uLCBvciBDKSBhIDIwMG1zIGZhbGxiYWNrIChpbiBjYXNlIGR1cmF0aW9uIGlzIGFscmVhZHkgc2V0IHRvIGEgbG93IHZhbHVlKS5cbiAgICAgICAgICAgICAgICAgICAgIFRoZSBlbmQgcmVzdWx0IGlzIGEgYmFzZWxpbmUgb2YgNzUlIG9mIHRoZSByZWRpcmVjdCdzIGR1cmF0aW9uIHRoYXQgaW5jcmVhc2VzL2RlY3JlYXNlcyBhcyB0aGUgZW5kIG9mIHRoZSBlbGVtZW50IHNldCBpcyBhcHByb2FjaGVkLiAqLyAgICAgICAgICAgICAgICAgICAgb3B0c18xLmR1cmF0aW9uID0gTWF0aC5tYXgob3B0c18xLmR1cmF0aW9uICogKG9wdHNfMS5iYWNrd2FyZHMgPyAxIC0gZWxlbWVudEluZGV4IC8gZWxlbWVudHMubGVuZ3RoIDogKGVsZW1lbnRJbmRleCArIDEpIC8gZWxlbWVudHMubGVuZ3RoKSwgb3B0c18xLmR1cmF0aW9uICogLjc1LCAyMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBQYXNzIGluIHRoZSBjYWxsJ3Mgb3B0cyBvYmplY3Qgc28gdGhhdCB0aGUgcmVkaXJlY3QgY2FuIG9wdGlvbmFsbHkgZXh0ZW5kIGl0LiBJdCBkZWZhdWx0cyB0byBhbiBlbXB0eSBvYmplY3QgaW5zdGVhZCBvZiBudWxsIHRvXG4gICAgICAgICAgICAgICAgIHJlZHVjZSB0aGUgb3B0cyBjaGVja2luZyBsb2dpYyByZXF1aXJlZCBpbnNpZGUgdGhlIHJlZGlyZWN0LiAqLyAgICAgICAgICAgICAgICBWZWxvY2l0eVN0YXRpYy5SZWRpcmVjdHNbYWN0aW9uXS5jYWxsKGVsZW1lbnQsIGVsZW1lbnQsIG9wdHNfMSwgZWxlbWVudEluZGV4LCBlbGVtZW50cy5sZW5ndGgsIGVsZW1lbnRzLCBwcm9taXNlSGFuZGxlciAmJiBwcm9taXNlSGFuZGxlci5fcmVzb2x2ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKiBTaW5jZSB0aGUgYW5pbWF0aW9uIGxvZ2ljIHJlc2lkZXMgd2l0aGluIHRoZSByZWRpcmVjdCdzIG93biBjb2RlLCBhYm9ydCB0aGUgcmVtYWluZGVyIG9mIHRoaXMgY2FsbC5cbiAgICAgICAgICAgICAoVGhlIHBlcmZvcm1hbmNlIG92ZXJoZWFkIHVwIHRvIHRoaXMgcG9pbnQgaXMgdmlydHVhbGx5IG5vbi1leGlzdGFudC4pICovXG4gICAgICAgICAgICAvKiBOb3RlOiBUaGUgalF1ZXJ5IGNhbGwgY2hhaW4gaXMga2VwdCBpbnRhY3QgYnkgcmV0dXJuaW5nIHRoZSBjb21wbGV0ZSBlbGVtZW50IHNldC4gKi8gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYWJvcnRFcnJvciA9IFwiVmVsb2NpdHk6IEZpcnN0IGFyZ3VtZW50IChcIiArIGFjdGlvbiArIFwiKSB3YXMgbm90IGEgcHJvcGVydHkgbWFwLCBhIGtub3duIGFjdGlvbiwgb3IgYSByZWdpc3RlcmVkIHJlZGlyZWN0LiBBYm9ydGluZy5cIjtcbiAgICAgICAgICAgIGlmIChwcm9taXNlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHByb21pc2VIYW5kbGVyLl9yZWplY3RlcihuZXcgRXJyb3IoYWJvcnRFcnJvcikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGFib3J0RXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFZlbG9jaXR5U3RhdGljLnJlZ2lzdGVyQWN0aW9uKFsgXCJkZWZhdWx0XCIsIGRlZmF1bHRBY3Rpb24gXSwgdHJ1ZSk7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJhY3Rpb25zLnRzXCIgLz5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICpcbiAqIEZpbmlzaCBhbGwgYW5pbWF0aW9uLlxuICovIHZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gYW5pbWF0aW9uIHNob3VsZCBiZSBmaW5pc2hlZCwgYW5kIGlmIHNvIHdlIHNldCB0aGUgdHdlZW5zIHRvXG4gICAgICogdGhlIGZpbmFsIHZhbHVlIGZvciBpdCwgdGhlbiBjYWxsIGNvbXBsZXRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrQW5pbWF0aW9uU2hvdWxkQmVGaW5pc2hlZChhbmltYXRpb24sIHF1ZXVlTmFtZSwgZGVmYXVsdFF1ZXVlKSB7XG4gICAgICAgIFZlbG9jaXR5U3RhdGljLnZhbGlkYXRlVHdlZW5zKGFuaW1hdGlvbik7XG4gICAgICAgIGlmIChxdWV1ZU5hbWUgPT09IHVuZGVmaW5lZCB8fCBxdWV1ZU5hbWUgPT09IGdldFZhbHVlKGFuaW1hdGlvbi5xdWV1ZSwgYW5pbWF0aW9uLm9wdGlvbnMucXVldWUsIGRlZmF1bHRRdWV1ZSkpIHtcbiAgICAgICAgICAgIGlmICghKGFuaW1hdGlvbi5fZmxhZ3MgJiA0IC8qIFNUQVJURUQgKi8pKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29waWVkIGZyb20gdGljay50cyAtIGVuc3VyZSB0aGF0IHRoZSBhbmltYXRpb24gaXMgY29tcGxldGVseVxuICAgICAgICAgICAgICAgIC8vIHZhbGlkIGFuZCBydW4gYmVnaW4oKSBiZWZvcmUgY29tcGxldGUoKS5cbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFuaW1hdGlvbi5vcHRpb25zO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBiZWdpbiBjYWxsYmFjayBpcyBmaXJlZCBvbmNlIHBlciBjYWxsLCBub3Qgb25jZSBwZXJcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50LCBhbmQgaXMgcGFzc2VkIHRoZSBmdWxsIHJhdyBET00gZWxlbWVudCBzZXQgYXMgYm90aFxuICAgICAgICAgICAgICAgIC8vIGl0cyBjb250ZXh0IGFuZCBpdHMgZmlyc3QgYXJndW1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLl9zdGFydGVkKysgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5fZmlyc3QgPSBhbmltYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJlZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIHRvIGFuIGV4dGVybmFsIGZuIHdpdGggYSB0cnkvY2F0Y2ggYmxvY2sgZm9yIG9wdGltaXNhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgVmVsb2NpdHlTdGF0aWMuY2FsbEJlZ2luKGFuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGNhbGxlZCBvbmNlLCBldmVuIGlmIHJldmVyc2VkIG9yIHJlcGVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmJlZ2luID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5fZmxhZ3MgfD0gNCAvKiBTVEFSVEVEICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gYW5pbWF0aW9uLnR3ZWVucykge1xuICAgICAgICAgICAgICAgIHZhciB0d2Vlbl8xID0gYW5pbWF0aW9uLnR3ZWVuc1twcm9wZXJ0eV0sIHBhdHRlcm4gPSB0d2Vlbl8xLnBhdHRlcm47XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IFwiXCIsIGkgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoO2kgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kVmFsdWUgPSB0d2Vlbl8xLmVuZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSArPSBlbmRWYWx1ZSA9PSBudWxsID8gcGF0dGVybltpXSA6IGVuZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLkNTUy5zZXRQcm9wZXJ0eVZhbHVlKGFuaW1hdGlvbi5lbGVtZW50LCBwcm9wZXJ0eSwgY3VycmVudFZhbHVlLCB0d2Vlbl8xLmZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLmNvbXBsZXRlQ2FsbChhbmltYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIGZpbmlzaCBhY3Rpb24gaXMgdHJpZ2dlcmVkLCB0aGUgZWxlbWVudHMnIGN1cnJlbnRseSBhY3RpdmUgY2FsbCBpc1xuICAgICAqIGltbWVkaWF0ZWx5IGZpbmlzaGVkLiBXaGVuIGFuIGVsZW1lbnQgaXMgZmluaXNoZWQsIHRoZSBuZXh0IGl0ZW0gaW4gaXRzXG4gICAgICogYW5pbWF0aW9uIHF1ZXVlIGlzIGltbWVkaWF0ZWx5IHRyaWdnZXJlZC4gSWYgcGFzc2VkIHZpYSBhIGNoYWluZWQgY2FsbFxuICAgICAqIHRoZW4gdGhpcyB3aWxsIG9ubHkgdGFyZ2V0IHRoZSBhbmltYXRpb25zIGluIHRoYXQgY2FsbCwgYW5kIG5vdCB0aGVcbiAgICAgKiBlbGVtZW50cyBsaW5rZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBBIHF1ZXVlIG5hbWUgbWF5IGJlIHBhc3NlZCBpbiB0byBzcGVjaWZ5IHRoYXQgb25seSBhbmltYXRpb25zIG9uIHRoZVxuICAgICAqIG5hbWVkIHF1ZXVlIGFyZSBmaW5pc2hlZC4gVGhlIGRlZmF1bHQgcXVldWUgaXMgbmFtZWQgXCJcIi4gSW4gYWRkaXRpb24gdGhlXG4gICAgICogdmFsdWUgb2YgYGZhbHNlYCBpcyBhbGxvd2VkIGZvciB0aGUgcXVldWUgbmFtZS5cbiAgICAgKlxuICAgICAqIEFuIGZpbmFsIGFyZ3VtZW50IG1heSBiZSBwYXNzZWQgaW4gdG8gY2xlYXIgYW4gZWxlbWVudCdzIHJlbWFpbmluZyBxdWV1ZWRcbiAgICAgKiBjYWxscy4gVGhpcyBtYXkgb25seSBiZSB0aGUgdmFsdWUgYHRydWVgLlxuICAgICAqLyAgICBmdW5jdGlvbiBmaW5pc2goYXJncywgZWxlbWVudHMsIHByb21pc2VIYW5kbGVyKSB7XG4gICAgICAgIHZhciBxdWV1ZU5hbWUgPSB2YWxpZGF0ZVF1ZXVlKGFyZ3NbMF0sIHRydWUpLCBkZWZhdWx0UXVldWUgPSBWZWxvY2l0eVN0YXRpYy5kZWZhdWx0cy5xdWV1ZSwgZmluaXNoQWxsID0gYXJnc1txdWV1ZU5hbWUgPT09IHVuZGVmaW5lZCA/IDAgOiAxXSA9PT0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzVmVsb2NpdHlSZXN1bHQoZWxlbWVudHMpICYmIGVsZW1lbnRzLnZlbG9jaXR5LmFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBhbmltYXRpb25zID0gZWxlbWVudHMudmVsb2NpdHkuYW5pbWF0aW9uczsgaSA8IGFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGVja0FuaW1hdGlvblNob3VsZEJlRmluaXNoZWQoYW5pbWF0aW9uc1tpXSwgcXVldWVOYW1lLCBkZWZhdWx0UXVldWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFjdGl2ZUNhbGwgPSBWZWxvY2l0eVN0YXRpYy5TdGF0ZS5maXJzdCwgbmV4dENhbGwgPSB2b2lkIDA7XG4gICAgICAgICAgICB3aGlsZSAoYWN0aXZlQ2FsbCA9IFZlbG9jaXR5U3RhdGljLlN0YXRlLmZpcnN0TmV3KSB7XG4gICAgICAgICAgICAgICAgVmVsb2NpdHlTdGF0aWMudmFsaWRhdGVUd2VlbnMoYWN0aXZlQ2FsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGFjdGl2ZUNhbGwgPSBWZWxvY2l0eVN0YXRpYy5TdGF0ZS5maXJzdDsgYWN0aXZlQ2FsbCAmJiAoZmluaXNoQWxsIHx8IGFjdGl2ZUNhbGwgIT09IFZlbG9jaXR5U3RhdGljLlN0YXRlLmZpcnN0TmV3KTsgYWN0aXZlQ2FsbCA9IG5leHRDYWxsIHx8IFZlbG9jaXR5U3RhdGljLlN0YXRlLmZpcnN0TmV3KSB7XG4gICAgICAgICAgICAgICAgbmV4dENhbGwgPSBhY3RpdmVDYWxsLl9uZXh0O1xuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudHMgfHwgX2luQXJyYXkoZWxlbWVudHMsIGFjdGl2ZUNhbGwuZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tBbmltYXRpb25TaG91bGRCZUZpbmlzaGVkKGFjdGl2ZUNhbGwsIHF1ZXVlTmFtZSwgZGVmYXVsdFF1ZXVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21pc2VIYW5kbGVyKSB7XG4gICAgICAgICAgICBpZiAoaXNWZWxvY2l0eVJlc3VsdChlbGVtZW50cykgJiYgZWxlbWVudHMudmVsb2NpdHkuYW5pbWF0aW9ucyAmJiBlbGVtZW50cy50aGVuKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMudGhlbihwcm9taXNlSGFuZGxlci5fcmVzb2x2ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlSGFuZGxlci5fcmVzb2x2ZXIoZWxlbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFZlbG9jaXR5U3RhdGljLnJlZ2lzdGVyQWN0aW9uKFsgXCJmaW5pc2hcIiwgZmluaXNoIF0sIHRydWUpO1xufSkoVmVsb2NpdHlTdGF0aWMgfHwgKFZlbG9jaXR5U3RhdGljID0ge30pKTtcblxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiYWN0aW9ucy50c1wiIC8+XG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqXG4gKiBHZXQgb3Igc2V0IGEgdmFsdWUgZnJvbSBvbmUgb3IgbW9yZSBydW5uaW5nIGFuaW1hdGlvbnMuXG4gKi8gdmFyIFZlbG9jaXR5U3RhdGljO1xuXG4oZnVuY3Rpb24oVmVsb2NpdHlTdGF0aWMpIHtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIG1hcCBnZXR0ZXJzIGZvciB0aGUgdmFyaW91cyBBbmltYXRpb25GbGFncy5cbiAgICAgKi9cbiAgICB2YXIgYW5pbWF0aW9uRmxhZ3MgPSB7XG4gICAgICAgIGlzRXhwYW5kZWQ6IDEgLyogRVhQQU5ERUQgKi8gLFxuICAgICAgICBpc1JlYWR5OiAyIC8qIFJFQURZICovICxcbiAgICAgICAgaXNTdGFydGVkOiA0IC8qIFNUQVJURUQgKi8gLFxuICAgICAgICBpc1N0b3BwZWQ6IDggLyogU1RPUFBFRCAqLyAsXG4gICAgICAgIGlzUGF1c2VkOiAxNiAvKiBQQVVTRUQgKi8gLFxuICAgICAgICBpc1N5bmM6IDMyIC8qIFNZTkMgKi8gLFxuICAgICAgICBpc1JldmVyc2U6IDY0XG4gLyogUkVWRVJTRSAqLyAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBvciBzZXQgYW4gb3B0aW9uIG9yIHJ1bm5pbmcgQW5pbWF0aW9uQ2FsbCBkYXRhIHZhbHVlLiBJZiB0aGVyZSBpcyBub1xuICAgICAqIHZhbHVlIHBhc3NlZCB0aGVuIGl0IHdpbGwgZ2V0LCBvdGhlcndpc2Ugd2Ugd2lsbCBzZXQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBXaGVuIHVzaW5nIFwiZ2V0XCIgdGhpcyB3aWxsIG5vdCB0b3VjaCB0aGUgUHJvbWlzZSBhcyBpdCBpcyBuZXZlclxuICAgICAqIHJldHVybmVkIHRvIHRoZSB1c2VyLlxuICAgICAqLyAgICBmdW5jdGlvbiBvcHRpb24oYXJncywgZWxlbWVudHMsIHByb21pc2VIYW5kbGVyLCBhY3Rpb24pIHtcbiAgICAgICAgdmFyIGtleSA9IGFyZ3NbMF0sIHF1ZXVlID0gYWN0aW9uLmluZGV4T2YoXCIuXCIpID49IDAgPyBhY3Rpb24ucmVwbGFjZSgvXi4qXFwuLywgXCJcIikgOiB1bmRlZmluZWQsIHF1ZXVlTmFtZSA9IHF1ZXVlID09PSBcImZhbHNlXCIgPyBmYWxzZSA6IHZhbGlkYXRlUXVldWUocXVldWUsIHRydWUpO1xuICAgICAgICB2YXIgYW5pbWF0aW9ucywgdmFsdWUgPSBhcmdzWzFdO1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVmVsb2NpdHlKUzogQ2Fubm90IGFjY2VzcyBhIG5vbi1leGlzdGFudCBrZXkhXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UncmUgY2hhaW5pbmcgdGhlIHJldHVybiB2YWx1ZSBmcm9tIFZlbG9jaXR5IHRoZW4gd2UgYXJlIG9ubHlcbiAgICAgICAgLy8gaW50ZXJlc3RlZCBpbiB0aGUgdmFsdWVzIHJlbGF0ZWQgdG8gdGhhdCBjYWxsXG4gICAgICAgICAgICAgICAgaWYgKGlzVmVsb2NpdHlSZXN1bHQoZWxlbWVudHMpICYmIGVsZW1lbnRzLnZlbG9jaXR5LmFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbnMgPSBlbGVtZW50cy52ZWxvY2l0eS5hbmltYXRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5pbWF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgYWN0aXZlQ2FsbCA9IFZlbG9jaXR5U3RhdGljLlN0YXRlLmZpcnN0OyBhY3RpdmVDYWxsOyBhY3RpdmVDYWxsID0gYWN0aXZlQ2FsbC5fbmV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cy5pbmRleE9mKGFjdGl2ZUNhbGwuZWxlbWVudCkgPj0gMCAmJiBnZXRWYWx1ZShhY3RpdmVDYWxsLnF1ZXVlLCBhY3RpdmVDYWxsLm9wdGlvbnMucXVldWUpID09PSBxdWV1ZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKGFjdGl2ZUNhbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGRlYWxpbmcgd2l0aCBtdWx0aXBsZSBlbGVtZW50cyB0aGF0IGFyZSBwb2ludGluZyBhdCBhXG4gICAgICAgICAgICAvLyBzaW5nbGUgcnVubmluZyBhbmltYXRpb24sIHRoZW4gaW5zdGVhZCB0cmVhdCB0aGVtIGFzIGEgc2luZ2xlXG4gICAgICAgICAgICAvLyBhbmltYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMSAmJiBhbmltYXRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDEsIG9wdGlvbnMgPSBhbmltYXRpb25zWzBdLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBhbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uc1tpKytdLm9wdGlvbnMgIT09IG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBuZWVkcyB0byBjaGVjayB0aGF0IHRoZXkncmUgYWN0dWFsbHkgYSBzeW5jOnRydWUgYW5pbWF0aW9uIHRvIG1lcmdlIHRoZSByZXN1bHRzLCBvdGhlcndpc2UgdGhlIGluZGl2aWR1YWwgdmFsdWVzIG1heSBiZSBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9ucyA9IFsgYW5pbWF0aW9uc1swXSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBHRVRcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBmbGFnID0gYW5pbWF0aW9uRmxhZ3Nba2V5XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBub3JtYWwga2V5IHRvIGdldC5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2V0VmFsdWUoYW5pbWF0aW9uc1tpXVtrZXldLCBhbmltYXRpb25zW2ldLm9wdGlvbnNba2V5XSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgZmxhZyB0aGF0IHdlJ3JlIGNoZWNraW5nIGFnYWluc3QuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKChhbmltYXRpb25zW2ldLl9mbGFncyAmIGZsYWcpID09PSAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAxICYmIGFuaW1hdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgb25seSBhIHNpbmdsZSBhbmltYXRpb24gaXMgZm91bmQgYW5kIHdlJ3JlIG9ubHkgdGFyZ2V0dGluZyBhXG4gICAgICAgICAgICAgICAgLy8gc2luZ2xlIGVsZW1lbnQsIHRoZW4gcmV0dXJuIHRoZSB2YWx1ZSBkaXJlY3RseVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFNFVFxuICAgICAgICAgICAgICAgIHZhciBpc1BlcmNlbnRDb21wbGV0ZTtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlIFwiY2FjaGVcIjpcbiAgICAgICAgICAgIHZhbHVlID0gdmFsaWRhdGVDYWNoZSh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJiZWdpblwiOlxuICAgICAgICAgICAgdmFsdWUgPSB2YWxpZGF0ZUJlZ2luKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImNvbXBsZXRlXCI6XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbGlkYXRlQ29tcGxldGUodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiZGVsYXlcIjpcbiAgICAgICAgICAgIHZhbHVlID0gdmFsaWRhdGVEZWxheSh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJkdXJhdGlvblwiOlxuICAgICAgICAgICAgdmFsdWUgPSB2YWxpZGF0ZUR1cmF0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImZwc0xpbWl0XCI6XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbGlkYXRlRnBzTGltaXQodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwibG9vcFwiOlxuICAgICAgICAgICAgdmFsdWUgPSB2YWxpZGF0ZUxvb3AodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwicGVyY2VudENvbXBsZXRlXCI6XG4gICAgICAgICAgICBpc1BlcmNlbnRDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwicmVwZWF0XCI6XG4gICAgICAgICAgY2FzZSBcInJlcGVhdEFnYWluXCI6XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbGlkYXRlUmVwZWF0KHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChrZXlbMF0gIT09IFwiX1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkZWxpYmVyYXRlIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInF1ZXVlXCI6XG4gICAgICAgICAgY2FzZSBcInByb21pc2VcIjpcbiAgICAgICAgICBjYXNlIFwicHJvbWlzZVJlamVjdEVtcHR5XCI6XG4gICAgICAgICAgY2FzZSBcImVhc2luZ1wiOlxuICAgICAgICAgIGNhc2UgXCJzdGFydGVkXCI6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJWZWxvY2l0eUpTOiBUcnlpbmcgdG8gc2V0IGEgcmVhZC1vbmx5IGtleTpcIiwga2V5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlZlbG9jaXR5SlM6IFRyeWluZyB0byBzZXQgYW4gaW52YWxpZCB2YWx1ZTpcIiwga2V5LCBcIj1cIiwgdmFsdWUsIFwiKFwiICsgYXJnc1sxXSArIFwiKVwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAoaXNQZXJjZW50Q29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24udGltZVN0YXJ0ID0gVmVsb2NpdHlTdGF0aWMubGFzdFRpY2sgLSBnZXRWYWx1ZShhbmltYXRpb24uZHVyYXRpb24sIGFuaW1hdGlvbi5vcHRpb25zLmR1cmF0aW9uLCBWZWxvY2l0eVN0YXRpYy5kZWZhdWx0cy5kdXJhdGlvbikgKiB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbWlzZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChpc1ZlbG9jaXR5UmVzdWx0KGVsZW1lbnRzKSAmJiBlbGVtZW50cy52ZWxvY2l0eS5hbmltYXRpb25zICYmIGVsZW1lbnRzLnRoZW4pIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy50aGVuKHByb21pc2VIYW5kbGVyLl9yZXNvbHZlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2VIYW5kbGVyLl9yZXNvbHZlcihlbGVtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgVmVsb2NpdHlTdGF0aWMucmVnaXN0ZXJBY3Rpb24oWyBcIm9wdGlvblwiLCBvcHRpb24gXSwgdHJ1ZSk7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJhY3Rpb25zLnRzXCIgLz5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICpcbiAqIFBhdXNlIGFuZCByZXN1bWUgYW5pbWF0aW9uLlxuICovIHZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gYW5pbWF0aW9uIHNob3VsZCBiZSBwYXVzZWQgLyByZXN1bWVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrQW5pbWF0aW9uKGFuaW1hdGlvbiwgcXVldWVOYW1lLCBkZWZhdWx0UXVldWUsIGlzUGF1c2VkKSB7XG4gICAgICAgIGlmIChxdWV1ZU5hbWUgPT09IHVuZGVmaW5lZCB8fCBxdWV1ZU5hbWUgPT09IGdldFZhbHVlKGFuaW1hdGlvbi5xdWV1ZSwgYW5pbWF0aW9uLm9wdGlvbnMucXVldWUsIGRlZmF1bHRRdWV1ZSkpIHtcbiAgICAgICAgICAgIGlmIChpc1BhdXNlZCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5fZmxhZ3MgfD0gMTYgLyogUEFVU0VEICovO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24uX2ZsYWdzICY9IH4xNiAvKiBQQVVTRUQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2UgYW5kIFJlc3VtZSBhcmUgY2FsbC13aWRlIChub3Qgb24gYSBwZXIgZWxlbWVudCBiYXNpcykuIFRodXMsIGNhbGxpbmcgcGF1c2Ugb3IgcmVzdW1lIG9uIGFcbiAgICAgKiBzaW5nbGUgZWxlbWVudCB3aWxsIGNhdXNlIGFueSBjYWxscyB0aGF0IGNvbnRhaW4gdHdlZW5zIGZvciB0aGF0IGVsZW1lbnQgdG8gYmUgcGF1c2VkL3Jlc3VtZWRcbiAgICAgKiBhcyB3ZWxsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhdXNlUmVzdW1lKGFyZ3MsIGVsZW1lbnRzLCBwcm9taXNlSGFuZGxlciwgYWN0aW9uKSB7XG4gICAgICAgIHZhciBpc1BhdXNlZCA9IGFjdGlvbi5pbmRleE9mKFwicGF1c2VcIikgPT09IDAsIHF1ZXVlID0gYWN0aW9uLmluZGV4T2YoXCIuXCIpID49IDAgPyBhY3Rpb24ucmVwbGFjZSgvXi4qXFwuLywgXCJcIikgOiB1bmRlZmluZWQsIHF1ZXVlTmFtZSA9IHF1ZXVlID09PSBcImZhbHNlXCIgPyBmYWxzZSA6IHZhbGlkYXRlUXVldWUoYXJnc1swXSksIGRlZmF1bHRRdWV1ZSA9IFZlbG9jaXR5U3RhdGljLmRlZmF1bHRzLnF1ZXVlO1xuICAgICAgICBpZiAoaXNWZWxvY2l0eVJlc3VsdChlbGVtZW50cykgJiYgZWxlbWVudHMudmVsb2NpdHkuYW5pbWF0aW9ucykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGFuaW1hdGlvbnMgPSBlbGVtZW50cy52ZWxvY2l0eS5hbmltYXRpb25zOyBpIDwgYW5pbWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoZWNrQW5pbWF0aW9uKGFuaW1hdGlvbnNbaV0sIHF1ZXVlTmFtZSwgZGVmYXVsdFF1ZXVlLCBpc1BhdXNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYWN0aXZlQ2FsbCA9IFZlbG9jaXR5U3RhdGljLlN0YXRlLmZpcnN0O1xuICAgICAgICAgICAgd2hpbGUgKGFjdGl2ZUNhbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnRzIHx8IF9pbkFycmF5KGVsZW1lbnRzLCBhY3RpdmVDYWxsLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQW5pbWF0aW9uKGFjdGl2ZUNhbGwsIHF1ZXVlTmFtZSwgZGVmYXVsdFF1ZXVlLCBpc1BhdXNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjdGl2ZUNhbGwgPSBhY3RpdmVDYWxsLl9uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9taXNlSGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKGlzVmVsb2NpdHlSZXN1bHQoZWxlbWVudHMpICYmIGVsZW1lbnRzLnZlbG9jaXR5LmFuaW1hdGlvbnMgJiYgZWxlbWVudHMudGhlbikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnRoZW4ocHJvbWlzZUhhbmRsZXIuX3Jlc29sdmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZUhhbmRsZXIuX3Jlc29sdmVyKGVsZW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBWZWxvY2l0eVN0YXRpYy5yZWdpc3RlckFjdGlvbihbIFwicGF1c2VcIiwgcGF1c2VSZXN1bWUgXSwgdHJ1ZSk7XG4gICAgVmVsb2NpdHlTdGF0aWMucmVnaXN0ZXJBY3Rpb24oWyBcInJlc3VtZVwiLCBwYXVzZVJlc3VtZSBdLCB0cnVlKTtcbn0pKFZlbG9jaXR5U3RhdGljIHx8IChWZWxvY2l0eVN0YXRpYyA9IHt9KSk7XG5cbi8vLzxyZWZlcmVuY2UgcGF0aD1cImFjdGlvbnMudHNcIiAvPlxuLypcbiAqIFZlbG9jaXR5SlMub3JnIChDKSAyMDE0LTIwMTcgSnVsaWFuIFNoYXBpcm8uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGRldGFpbHMuXG4gKlxuICogQWN0aW9ucyB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgYnkgcGFzc2luZyBhIHN0cmluZyBpbnN0ZWFkIG9mIGEgcHJvcGVydGllc01hcC5cbiAqLyB2YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIFZlbG9jaXR5U3RhdGljLnJlZ2lzdGVyQWN0aW9uKFsgXCJyZXZlcnNlXCIsIGZ1bmN0aW9uKGFyZ3MsIGVsZW1lbnRzLCBwcm9taXNlSGFuZGxlciwgYWN0aW9uKSB7XG4gICAgICAgIC8vIFRPRE86IENvZGUgbmVlZHMgdG8gc3BsaXQgb3V0IGJlZm9yZSBoZXJlIC0gYnV0IHRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnQgaXQgYmVpbmcgb3ZlcnJpZGRlblxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJWZWxvY2l0eUpTOiBUaGUgJ3JldmVyc2UnIGFjdGlvbiBpcyBwcml2YXRlLlwiKTtcbiAgICB9IF0sIHRydWUpO1xufSkoVmVsb2NpdHlTdGF0aWMgfHwgKFZlbG9jaXR5U3RhdGljID0ge30pKTtcblxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiYWN0aW9ucy50c1wiIC8+XG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqXG4gKiBTdG9wIGFuaW1hdGlvbi5cbiAqLyB2YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFuIGFuaW1hdGlvbiBzaG91bGQgYmUgc3RvcHBlZCwgYW5kIGlmIHNvIHRoZW4gc2V0IHRoZSBTVE9QUEVEXG4gICAgICogZmxhZyBvbiBpdCwgdGhlbiBjYWxsIGNvbXBsZXRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrQW5pbWF0aW9uU2hvdWxkQmVTdG9wcGVkKGFuaW1hdGlvbiwgcXVldWVOYW1lLCBkZWZhdWx0UXVldWUpIHtcbiAgICAgICAgVmVsb2NpdHlTdGF0aWMudmFsaWRhdGVUd2VlbnMoYW5pbWF0aW9uKTtcbiAgICAgICAgaWYgKHF1ZXVlTmFtZSA9PT0gdW5kZWZpbmVkIHx8IHF1ZXVlTmFtZSA9PT0gZ2V0VmFsdWUoYW5pbWF0aW9uLnF1ZXVlLCBhbmltYXRpb24ub3B0aW9ucy5xdWV1ZSwgZGVmYXVsdFF1ZXVlKSkge1xuICAgICAgICAgICAgYW5pbWF0aW9uLl9mbGFncyB8PSA4IC8qIFNUT1BQRUQgKi87XG4gICAgICAgICAgICBWZWxvY2l0eVN0YXRpYy5jb21wbGV0ZUNhbGwoYW5pbWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBzdG9wIGFjdGlvbiBpcyB0cmlnZ2VyZWQsIHRoZSBlbGVtZW50cycgY3VycmVudGx5IGFjdGl2ZSBjYWxsIGlzXG4gICAgICogaW1tZWRpYXRlbHkgc3RvcHBlZC4gV2hlbiBhbiBlbGVtZW50IGlzIHN0b3BwZWQsIHRoZSBuZXh0IGl0ZW0gaW4gaXRzXG4gICAgICogYW5pbWF0aW9uIHF1ZXVlIGlzIGltbWVkaWF0ZWx5IHRyaWdnZXJlZC4gSWYgcGFzc2VkIHZpYSBhIGNoYWluZWQgY2FsbFxuICAgICAqIHRoZW4gdGhpcyB3aWxsIG9ubHkgdGFyZ2V0IHRoZSBhbmltYXRpb25zIGluIHRoYXQgY2FsbCwgYW5kIG5vdCB0aGVcbiAgICAgKiBlbGVtZW50cyBsaW5rZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBBIHF1ZXVlIG5hbWUgbWF5IGJlIHBhc3NlZCBpbiB0byBzcGVjaWZ5IHRoYXQgb25seSBhbmltYXRpb25zIG9uIHRoZVxuICAgICAqIG5hbWVkIHF1ZXVlIGFyZSBzdG9wcGVkLiBUaGUgZGVmYXVsdCBxdWV1ZSBpcyBuYW1lZCBcIlwiLiBJbiBhZGRpdGlvbiB0aGVcbiAgICAgKiB2YWx1ZSBvZiBgZmFsc2VgIGlzIGFsbG93ZWQgZm9yIHRoZSBxdWV1ZSBuYW1lLlxuICAgICAqXG4gICAgICogQW4gZmluYWwgYXJndW1lbnQgbWF5IGJlIHBhc3NlZCBpbiB0byBjbGVhciBhbiBlbGVtZW50J3MgcmVtYWluaW5nIHF1ZXVlZFxuICAgICAqIGNhbGxzLiBUaGlzIG1heSBvbmx5IGJlIHRoZSB2YWx1ZSBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGUgc3RvcCBjb21tYW5kIHJ1bnMgcHJpb3IgdG8gVmVsb2NpdHkncyBRdWV1ZWluZyBwaGFzZSBzaW5jZSBpdHNcbiAgICAgKiBiZWhhdmlvciBpcyBpbnRlbmRlZCB0byB0YWtlIGVmZmVjdCAqaW1tZWRpYXRlbHkqLCByZWdhcmRsZXNzIG9mIHRoZVxuICAgICAqIGVsZW1lbnQncyBjdXJyZW50IHF1ZXVlIHN0YXRlLlxuICAgICAqLyAgICBmdW5jdGlvbiBzdG9wKGFyZ3MsIGVsZW1lbnRzLCBwcm9taXNlSGFuZGxlciwgYWN0aW9uKSB7XG4gICAgICAgIHZhciBxdWV1ZU5hbWUgPSB2YWxpZGF0ZVF1ZXVlKGFyZ3NbMF0sIHRydWUpLCBkZWZhdWx0UXVldWUgPSBWZWxvY2l0eVN0YXRpYy5kZWZhdWx0cy5xdWV1ZSwgZmluaXNoQWxsID0gYXJnc1txdWV1ZU5hbWUgPT09IHVuZGVmaW5lZCA/IDAgOiAxXSA9PT0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzVmVsb2NpdHlSZXN1bHQoZWxlbWVudHMpICYmIGVsZW1lbnRzLnZlbG9jaXR5LmFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBhbmltYXRpb25zID0gZWxlbWVudHMudmVsb2NpdHkuYW5pbWF0aW9uczsgaSA8IGFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGVja0FuaW1hdGlvblNob3VsZEJlU3RvcHBlZChhbmltYXRpb25zW2ldLCBxdWV1ZU5hbWUsIGRlZmF1bHRRdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYWN0aXZlQ2FsbCA9IFZlbG9jaXR5U3RhdGljLlN0YXRlLmZpcnN0LCBuZXh0Q2FsbCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHdoaWxlIChhY3RpdmVDYWxsID0gVmVsb2NpdHlTdGF0aWMuU3RhdGUuZmlyc3ROZXcpIHtcbiAgICAgICAgICAgICAgICBWZWxvY2l0eVN0YXRpYy52YWxpZGF0ZVR3ZWVucyhhY3RpdmVDYWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoYWN0aXZlQ2FsbCA9IFZlbG9jaXR5U3RhdGljLlN0YXRlLmZpcnN0OyBhY3RpdmVDYWxsICYmIChmaW5pc2hBbGwgfHwgYWN0aXZlQ2FsbCAhPT0gVmVsb2NpdHlTdGF0aWMuU3RhdGUuZmlyc3ROZXcpOyBhY3RpdmVDYWxsID0gbmV4dENhbGwgfHwgVmVsb2NpdHlTdGF0aWMuU3RhdGUuZmlyc3ROZXcpIHtcbiAgICAgICAgICAgICAgICBuZXh0Q2FsbCA9IGFjdGl2ZUNhbGwuX25leHQ7XG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50cyB8fCBfaW5BcnJheShlbGVtZW50cywgYWN0aXZlQ2FsbC5lbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0FuaW1hdGlvblNob3VsZEJlU3RvcHBlZChhY3RpdmVDYWxsLCBxdWV1ZU5hbWUsIGRlZmF1bHRRdWV1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9taXNlSGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKGlzVmVsb2NpdHlSZXN1bHQoZWxlbWVudHMpICYmIGVsZW1lbnRzLnZlbG9jaXR5LmFuaW1hdGlvbnMgJiYgZWxlbWVudHMudGhlbikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnRoZW4ocHJvbWlzZUhhbmRsZXIuX3Jlc29sdmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZUhhbmRsZXIuX3Jlc29sdmVyKGVsZW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBWZWxvY2l0eVN0YXRpYy5yZWdpc3RlckFjdGlvbihbIFwic3RvcFwiLCBzdG9wIF0sIHRydWUpO1xufSkoVmVsb2NpdHlTdGF0aWMgfHwgKFZlbG9jaXR5U3RhdGljID0ge30pKTtcblxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiYWN0aW9ucy50c1wiIC8+XG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqXG4gKiBHZXQgb3Igc2V0IGEgcHJvcGVydHkgZnJvbSBvbmUgb3IgbW9yZSBlbGVtZW50cy5cbiAqLyB2YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIGZ1bmN0aW9uIHN0eWxlKGVsZW1lbnRzLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlQWN0aW9uKFsgcHJvcGVydHksIHZhbHVlIF0sIGVsZW1lbnRzKTtcbiAgICB9XG4gICAgVmVsb2NpdHlTdGF0aWMuc3R5bGUgPSBzdHlsZTtcbiAgICAvKipcbiAgICAgKiBHZXQgb3Igc2V0IGEgc3R5bGUgb2YgTm9tcmFsaXNlZCBwcm9wZXJ0eSB2YWx1ZSBvbiBvbmUgb3IgbW9yZSBlbGVtZW50cy5cbiAgICAgKiBJZiB0aGVyZSBpcyBubyB2YWx1ZSBwYXNzZWQgdGhlbiBpdCB3aWxsIGdldCwgb3RoZXJ3aXNlIHdlIHdpbGwgc2V0LlxuICAgICAqXG4gICAgICogTk9URTogV2hlbiB1c2luZyBcImdldFwiIHRoaXMgd2lsbCBub3QgdG91Y2ggdGhlIFByb21pc2UgYXMgaXQgaXMgbmV2ZXJcbiAgICAgKiByZXR1cm5lZCB0byB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIFRoaXMgY2FuIGZhaWwgdG8gc2V0LCBhbmQgd2lsbCByZWplY3QgdGhlIFByb21pc2UgaWYgaXQgZG9lcyBzby5cbiAgICAgKlxuICAgICAqIFZlbG9jaXR5KGVsZW1lbnRzLCBcInN0eWxlXCIsIFwicHJvcGVydHlcIiwgXCJ2YWx1ZVwiKSA9PiBlbGVtZW50cztcbiAgICAgKiBWZWxvY2l0eShlbGVtZW50cywgXCJzdHlsZVwiLCB7XCJwcm9wZXJ0eVwiOiBcInZhbHVlXCIsIC4uLn0pID0+IGVsZW1lbnRzO1xuICAgICAqIFZlbG9jaXR5KGVsZW1lbnQsIFwic3R5bGVcIiwgXCJwcm9wZXJ0eVwiKSA9PiBcInZhbHVlXCI7XG4gICAgICogVmVsb2NpdHkoZWxlbWVudHMsIFwic3R5bGVcIiwgXCJwcm9wZXJ0eVwiKSA9PiBbXCJ2YWx1ZVwiLCAuLi5dO1xuICAgICAqLyAgICBmdW5jdGlvbiBzdHlsZUFjdGlvbihhcmdzLCBlbGVtZW50cywgcHJvbWlzZUhhbmRsZXIsIGFjdGlvbikge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBhcmdzWzBdLCB2YWx1ZSA9IGFyZ3NbMV07XG4gICAgICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlZlbG9jaXR5SlM6IENhbm5vdCBhY2Nlc3MgYSBub24tZXhpc3RhbnQgcHJvcGVydHkhXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR0VUXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIWlzUGxhaW5PYmplY3QocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAvLyBJZiBvbmx5IGEgc2luZ2xlIGFuaW1hdGlvbiBpcyBmb3VuZCBhbmQgd2UncmUgb25seSB0YXJnZXR0aW5nIGFcbiAgICAgICAgICAgIC8vIHNpbmdsZSBlbGVtZW50LCB0aGVuIHJldHVybiB0aGUgdmFsdWUgZGlyZWN0bHlcbiAgICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVsb2NpdHlTdGF0aWMuQ1NTLmZpeENvbG9ycyhWZWxvY2l0eVN0YXRpYy5DU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50c1swXSwgcHJvcGVydHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChWZWxvY2l0eVN0YXRpYy5DU1MuZml4Q29sb3JzKFZlbG9jaXR5U3RhdGljLkNTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnRzW2ldLCBwcm9wZXJ0eSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU0VUXG4gICAgICAgICAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlXzEgPSBwcm9wZXJ0eVtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWVfMSkgfHwgaXNOdW1iZXIodmFsdWVfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLkNTUy5zZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnRzW2ldLCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5W3Byb3BlcnR5TmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAoZXJyb3IgPyBlcnJvciArIFwiLCBcIiA6IFwiXCIpICsgXCJDYW5ub3Qgc2V0IGEgcHJvcGVydHkgJ1wiICsgcHJvcGVydHlOYW1lICsgXCInIHRvIGFuIHVua25vd24gdHlwZTogXCIgKyB0eXBlb2YgdmFsdWVfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlZlbG9jaXR5SlM6IENhbm5vdCBzZXQgYSBwcm9wZXJ0eSAnXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIicgdG8gYW4gdW5rbm93biB0eXBlOlwiLCB2YWx1ZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgVmVsb2NpdHlTdGF0aWMuQ1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudHNbaV0sIHByb3BlcnR5LCBTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yID0gXCJDYW5ub3Qgc2V0IGEgcHJvcGVydHkgJ1wiICsgcHJvcGVydHkgKyBcIicgdG8gYW4gdW5rbm93biB0eXBlOiBcIiArIHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlZlbG9jaXR5SlM6IENhbm5vdCBzZXQgYSBwcm9wZXJ0eSAnXCIgKyBwcm9wZXJ0eSArIFwiJyB0byBhbiB1bmtub3duIHR5cGU6XCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbWlzZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHByb21pc2VIYW5kbGVyLl9yZWplY3RlcihlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzVmVsb2NpdHlSZXN1bHQoZWxlbWVudHMpICYmIGVsZW1lbnRzLnZlbG9jaXR5LmFuaW1hdGlvbnMgJiYgZWxlbWVudHMudGhlbikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnRoZW4ocHJvbWlzZUhhbmRsZXIuX3Jlc29sdmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZUhhbmRsZXIuX3Jlc29sdmVyKGVsZW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBWZWxvY2l0eVN0YXRpYy5yZWdpc3RlckFjdGlvbihbIFwic3R5bGVcIiwgc3R5bGVBY3Rpb24gXSwgdHJ1ZSk7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJhY3Rpb25zLnRzXCIgLz5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICpcbiAqIEdldCBvciBzZXQgYSBwcm9wZXJ0eSBmcm9tIG9uZSBvciBtb3JlIGVsZW1lbnRzLlxuICovIHZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgZnVuY3Rpb24gdHdlZW4oZWxlbWVudHMsIHBlcmNlbnRDb21wbGV0ZSwgcHJvcGVydGllcywgcHJvcGVydHksIGVhc2luZykge1xuICAgICAgICByZXR1cm4gdHdlZW5BY3Rpb24oYXJndW1lbnRzLCBlbGVtZW50cyk7XG4gICAgfVxuICAgIFZlbG9jaXR5U3RhdGljLnR3ZWVuID0gdHdlZW47XG4gICAgLyoqXG4gICAgICpcbiAgICAgKi8gICAgZnVuY3Rpb24gdHdlZW5BY3Rpb24oYXJncywgZWxlbWVudHMsIHByb21pc2VIYW5kbGVyLCBhY3Rpb24pIHtcbiAgICAgICAgdmFyIHJlcXVpcmVGb3JjZWZlZWRpbmc7XG4gICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ1ZlbG9jaXR5KDxlbGVtZW50PiwgXCJ0d2VlblwiLCBwZXJjZW50Q29tcGxldGUsIHByb3BlcnR5LCBlbmQgfCBbZW5kLCA8ZWFzaW5nPiwgPHN0YXJ0Pl0sIDxlYXNpbmc+KSA9PiB2YWx1ZVxcbicgKyAnVmVsb2NpdHkoPGVsZW1lbnQ+LCBcInR3ZWVuXCIsIHBlcmNlbnRDb21wbGV0ZSwge3Byb3BlcnR5OiBlbmQgfCBbZW5kLCA8ZWFzaW5nPiwgPHN0YXJ0Pl0sIC4uLn0sIDxlYXNpbmc+KSA9PiB7cHJvcGVydHk6IHZhbHVlLCAuLi59Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50cyA9IFsgZG9jdW1lbnQuYm9keSBdO1xuICAgICAgICAgICAgcmVxdWlyZUZvcmNlZmVlZGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBBbGxvdyBtb3JlIHRoYW4gYSBzaW5nbGUgZWxlbWVudCB0byByZXR1cm4gYW4gYXJyYXkgb2YgcmVzdWx0c1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVsb2NpdHlKUzogQ2Fubm90IHR3ZWVuIG1vcmUgdGhhbiBvbmUgZWxlbWVudCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBlcmNlbnRDb21wbGV0ZSA9IGFyZ3NbMF0sIGZha2VBbmltYXRpb24gPSB7XG4gICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50c1swXSxcbiAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMWUzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHdlZW5zOiBudWxsXG4gICAgICAgIH0sIHJlc3VsdCA9IHt9O1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IGFyZ3NbMV0sIHNpbmdsZVJlc3VsdCwgZWFzaW5nID0gYXJnc1syXSwgY291bnQgPSAwO1xuICAgICAgICBpZiAoaXNTdHJpbmcoYXJnc1sxXSkpIHtcbiAgICAgICAgICAgIHNpbmdsZVJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gKF9hID0ge30sIF9hW2FyZ3NbMV1dID0gYXJnc1syXSwgX2EpO1xuICAgICAgICAgICAgZWFzaW5nID0gYXJnc1szXTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMV0pKSB7XG4gICAgICAgICAgICBzaW5nbGVSZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICB0d2VlbjogYXJnc1sxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVhc2luZyA9IGFyZ3NbMl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc051bWJlcihwZXJjZW50Q29tcGxldGUpIHx8IHBlcmNlbnRDb21wbGV0ZSA8IDAgfHwgcGVyY2VudENvbXBsZXRlID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVsb2NpdHlKUzogTXVzdCB0d2VlbiBhIHBlcmNlbnRhZ2UgZnJvbSAwIHRvIDEhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNQbGFpbk9iamVjdChwcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVsb2NpdHlKUzogQ2Fubm90IHR3ZWVuIGFuIGludmFsaWQgcHJvcGVydHkhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1aXJlRm9yY2VmZWVkaW5nKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpICYmICghQXJyYXkuaXNBcnJheShwcm9wZXJ0aWVzW3Byb3BlcnR5XSkgfHwgcHJvcGVydGllc1twcm9wZXJ0eV0ubGVuZ3RoIDwgMikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVsb2NpdHlKUzogV2hlbiBub3Qgc3VwcGx5aW5nIGFuIGVsZW1lbnQgeW91IG11c3QgZm9yY2UtZmVlZCB2YWx1ZXM6IFwiICsgcHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYWN0aXZlRWFzaW5nID0gdmFsaWRhdGVFYXNpbmcoZ2V0VmFsdWUoZWFzaW5nLCBWZWxvY2l0eVN0YXRpYy5kZWZhdWx0cy5lYXNpbmcpLCAxZTMpO1xuICAgICAgICBWZWxvY2l0eVN0YXRpYy5leHBhbmRQcm9wZXJ0aWVzKGZha2VBbmltYXRpb24sIHByb3BlcnRpZXMpO1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBmYWtlQW5pbWF0aW9uLnR3ZWVucykge1xuICAgICAgICAgICAgLy8gRm9yIGV2ZXJ5IGVsZW1lbnQsIGl0ZXJhdGUgdGhyb3VnaCBlYWNoIHByb3BlcnR5LlxuICAgICAgICAgICAgdmFyIHR3ZWVuXzIgPSBmYWtlQW5pbWF0aW9uLnR3ZWVuc1twcm9wZXJ0eV0sIGVhc2luZ18xID0gdHdlZW5fMi5lYXNpbmcgfHwgYWN0aXZlRWFzaW5nLCBwYXR0ZXJuID0gdHdlZW5fMi5wYXR0ZXJuO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSB0d2Vlbl8yLnN0YXJ0W2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgKz0gcGF0dGVybltpXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRfMSA9IGVhc2luZ18xKHBlcmNlbnRDb21wbGV0ZSwgc3RhcnRWYWx1ZSwgdHdlZW5fMi5lbmRbaV0sIHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSArPSBwYXR0ZXJuW2ldID09PSB0cnVlID8gTWF0aC5yb3VuZChyZXN1bHRfMSkgOiByZXN1bHRfMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSBjdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpbmdsZVJlc3VsdCAmJiBjb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHZhciBfYTtcbiAgICB9XG4gICAgVmVsb2NpdHlTdGF0aWMucmVnaXN0ZXJBY3Rpb24oWyBcInR3ZWVuXCIsIHR3ZWVuQWN0aW9uIF0sIHRydWUpO1xufSkoVmVsb2NpdHlTdGF0aWMgfHwgKFZlbG9jaXR5U3RhdGljID0ge30pKTtcblxuLypcbiAqIFZlbG9jaXR5SlMub3JnIChDKSAyMDE0LTIwMTcgSnVsaWFuIFNoYXBpcm8uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGRldGFpbHMuXG4gKi8gdmFyIFZlbG9jaXR5U3RhdGljO1xuXG4oZnVuY3Rpb24oVmVsb2NpdHlTdGF0aWMpIHtcbiAgICAvKipcbiAgICAgKiBDb250YWluZXIgZm9yIHBhZ2Utd2lkZSBWZWxvY2l0eSBzdGF0ZSBkYXRhLlxuICAgICAqL1xuICAgIHZhciBTdGF0ZTtcbiAgICAoZnVuY3Rpb24oU3RhdGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVjdCBpZiB0aGlzIGlzIGEgTm9kZUpTIG9yIHdlYiBicm93c2VyXG4gICAgICAgICAqL1xuICAgICAgICBTdGF0ZS5pc0NsaWVudCA9IHdpbmRvdyAmJiB3aW5kb3cgPT09IHdpbmRvdy53aW5kb3csXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlY3QgbW9iaWxlIGRldmljZXMgdG8gZGV0ZXJtaW5lIGlmIG1vYmlsZUhBIHNob3VsZCBiZSB0dXJuZWRcbiAgICAgICAgICogb24uXG4gICAgICAgICAqL1xuICAgICAgICBTdGF0ZS5pc01vYmlsZSA9IFN0YXRlLmlzQ2xpZW50ICYmIC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtb2JpbGVIQSBvcHRpb24ncyBiZWhhdmlvciBjaGFuZ2VzIG9uIG9sZGVyIEFuZHJvaWQgZGV2aWNlc1xuICAgICAgICAgKiAoR2luZ2VyYnJlYWQsIHZlcnNpb25zIDIuMy4zLTIuMy43KS5cbiAgICAgICAgICovXG4gICAgICAgIFN0YXRlLmlzQW5kcm9pZCA9IFN0YXRlLmlzQ2xpZW50ICYmIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtb2JpbGVIQSBvcHRpb24ncyBiZWhhdmlvciBjaGFuZ2VzIG9uIG9sZGVyIEFuZHJvaWQgZGV2aWNlc1xuICAgICAgICAgKiAoR2luZ2VyYnJlYWQsIHZlcnNpb25zIDIuMy4zLTIuMy43KS5cbiAgICAgICAgICovXG4gICAgICAgIFN0YXRlLmlzR2luZ2VyYnJlYWQgPSBTdGF0ZS5pc0NsaWVudCAmJiAvQW5kcm9pZCAyXFwuM1xcLlszLTddL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENocm9tZSBicm93c2VyXG4gICAgICAgICAqL1xuICAgICAgICBTdGF0ZS5pc0Nocm9tZSA9IFN0YXRlLmlzQ2xpZW50ICYmIHdpbmRvdy5jaHJvbWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZm94IGJyb3dzZXJcbiAgICAgICAgICovXG4gICAgICAgIFN0YXRlLmlzRmlyZWZveCA9IFN0YXRlLmlzQ2xpZW50ICYmIC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIGNhY2hlZCBlbGVtZW50IGZvciByZS11c2Ugd2hlbiBjaGVja2luZyBmb3IgQ1NTIHByb3BlcnR5XG4gICAgICAgICAqIHByZWZpeGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgU3RhdGUucHJlZml4RWxlbWVudCA9IFN0YXRlLmlzQ2xpZW50ICYmIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZSB0aGUgYXBwcm9wcmlhdGUgc2Nyb2xsIGFuY2hvciBhbmQgcHJvcGVydHkgbmFtZSBmb3IgdGhlXG4gICAgICAgICAqIGJyb3dzZXI6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cuc2Nyb2xsWVxuICAgICAgICAgKi9cbiAgICAgICAgU3RhdGUud2luZG93U2Nyb2xsQW5jaG9yID0gU3RhdGUuaXNDbGllbnQgJiYgd2luZG93LnBhZ2VZT2Zmc2V0ICE9PSB1bmRlZmluZWQsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWNoZSB0aGUgYW5jaG9yIHVzZWQgZm9yIGFuaW1hdGluZyB3aW5kb3cgc2Nyb2xsaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgU3RhdGUuc2Nyb2xsQW5jaG9yID0gU3RhdGUud2luZG93U2Nyb2xsQW5jaG9yID8gd2luZG93IDogIVN0YXRlLmlzQ2xpZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuYm9keSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hlIHRoZSBicm93c2VyLXNwZWNpZmljIHByb3BlcnR5IG5hbWVzIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICAgICAgICogc2Nyb2xsIGFuY2hvci5cbiAgICAgICAgICovXG4gICAgICAgIFN0YXRlLnNjcm9sbFByb3BlcnR5TGVmdCA9IFN0YXRlLndpbmRvd1Njcm9sbEFuY2hvciA/IFwicGFnZVhPZmZzZXRcIiA6IFwic2Nyb2xsTGVmdFwiLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FjaGUgdGhlIGJyb3dzZXItc3BlY2lmaWMgcHJvcGVydHkgbmFtZXMgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgICAgICAgKiBzY3JvbGwgYW5jaG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgU3RhdGUuc2Nyb2xsUHJvcGVydHlUb3AgPSBTdGF0ZS53aW5kb3dTY3JvbGxBbmNob3IgPyBcInBhZ2VZT2Zmc2V0XCIgOiBcInNjcm9sbFRvcFwiLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsYXNzTmFtZSB3ZSBhZGQgLyByZW1vdmUgd2hlbiBhbmltYXRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBTdGF0ZS5jbGFzc05hbWUgPSBDTEFTU05BTUUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwIHRyYWNrIG9mIHdoZXRoZXIgb3VyIFJBRiB0aWNrIGlzIHJ1bm5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBTdGF0ZS5pc1RpY2tpbmcgPSBmYWxzZTtcbiAgICB9KShTdGF0ZSA9IFZlbG9jaXR5U3RhdGljLlN0YXRlIHx8IChWZWxvY2l0eVN0YXRpYy5TdGF0ZSA9IHt9KSk7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vLy88cmVmZXJlbmNlIHBhdGg9XCIuLi9zdGF0ZS50c1wiIC8+XG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqL1xudmFyIFZlbG9jaXR5U3RhdGljO1xuXG4oZnVuY3Rpb24oVmVsb2NpdHlTdGF0aWMpIHtcbiAgICB2YXIgQ1NTO1xuICAgIChmdW5jdGlvbihDU1MpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hlIGV2ZXJ5IGNhbWVsQ2FzZSBtYXRjaCB0byBhdm9pZCByZXBlYXRpbmcgbG9va3Vwcy5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBjYWNoZSA9IGNyZWF0ZUVtcHR5T2JqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW1lbGNhc2UgYSBwcm9wZXJ0eSBuYW1lIGludG8gaXRzIEphdmFTY3JpcHQgbm90YXRpb24gKGUuZy5cbiAgICAgICAgICogXCJiYWNrZ3JvdW5kLWNvbG9yXCIgPT0+IFwiYmFja2dyb3VuZENvbG9yXCIpLiBDYW1lbGNhc2luZyBpcyB1c2VkIHRvXG4gICAgICAgICAqIG5vcm1hbGl6ZSBwcm9wZXJ0eSBuYW1lcyBiZXR3ZWVuIGFuZCBhY3Jvc3MgY2FsbHMuXG4gICAgICAgICAqLyAgICAgICAgZnVuY3Rpb24gY2FtZWxDYXNlKHByb3BlcnR5KSB7XG4gICAgICAgICAgICB2YXIgZml4ZWQgPSBjYWNoZVtwcm9wZXJ0eV07XG4gICAgICAgICAgICBpZiAoZml4ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml4ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVbcHJvcGVydHldID0gcHJvcGVydHkucmVwbGFjZSgvLShbYS16XSkvZywgZnVuY3Rpb24oJCwgbGV0dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgQ1NTLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbiAgICB9KShDU1MgPSBWZWxvY2l0eVN0YXRpYy5DU1MgfHwgKFZlbG9jaXR5U3RhdGljLkNTUyA9IHt9KSk7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqLyB2YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIHZhciBDU1M7XG4gICAgKGZ1bmN0aW9uKENTUykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyB0aGUgbGlzdCBvZiBjb2xvciBuYW1lcyAtPiByZ2IgdmFsdWVzLiBUaGUgb2JqZWN0IGlzIGluIGhlcmUgc29cbiAgICAgICAgICogdGhhdCB0aGUgYWN0dWFsIG5hbWUgY29udmVyc2lvbiBjYW4gYmUgaW4gYSBzZXBhcmF0ZSBmaWxlIGFuZCBub3RcbiAgICAgICAgICogaW5jbHVkZWQgZm9yIGN1c3RvbSBidWlsZHMuXG4gICAgICAgICAqL1xuICAgICAgICBDU1MuQ29sb3JOYW1lcyA9IGNyZWF0ZUVtcHR5T2JqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IGEgaGV4IGxpc3QgdG8gYW4gcmdiYSB2YWx1ZS4gRGVzaWduZWQgdG8gYmUgdXNlZCBpbiByZXBsYWNlLlxuICAgICAgICAgKi8gICAgICAgIGZ1bmN0aW9uIG1ha2VSR0JBKGlnbm9yZSwgciwgZywgYikge1xuICAgICAgICAgICAgcmV0dXJuIFwicmdiYShcIiArIHBhcnNlSW50KHIsIDE2KSArIFwiLFwiICsgcGFyc2VJbnQoZywgMTYpICsgXCIsXCIgKyBwYXJzZUludChiLCAxNikgKyBcIiwxKVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciByeENvbG9yNiA9IC8jKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pL2dpLCByeENvbG9yMyA9IC8jKFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pL2dpLCByeENvbG9yTmFtZSA9IC8ocmdiYT9cXChcXHMqKT8oXFxiW2Etel0rXFxiKS9nLCByeFJHQiA9IC9yZ2IoYT8pXFwoKFteXFwpXSspXFwpL2dpLCByeFNwYWNlcyA9IC9cXHMrL2c7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXBsYWNlIGFueSBjc3MgY29sb3VyIG5hbWUgd2l0aCBpdHMgcmdiYSgpIHZhbHVlLiBJdCBpcyBwb3NzaWJsZSB0byB1c2VcbiAgICAgICAgICogdGhlIG5hbWUgd2l0aGluIGFuIFwicmdiYShibHVlLCAwLjQpXCIgc3RyaW5nIHRoaXMgd2F5LlxuICAgICAgICAgKi8gICAgICAgIGZ1bmN0aW9uIGZpeENvbG9ycyhzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZShyeENvbG9yNiwgbWFrZVJHQkEpLnJlcGxhY2UocnhDb2xvcjMsIGZ1bmN0aW9uKCQwLCByLCBnLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VSR0JBKCQwLCByICsgciwgZyArIGcsIGIgKyBiKTtcbiAgICAgICAgICAgIH0pLnJlcGxhY2UocnhDb2xvck5hbWUsIGZ1bmN0aW9uKCQwLCAkMSwgJDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoQ1NTLkNvbG9yTmFtZXNbJDJdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoJDEgPyAkMSA6IFwicmdiYShcIikgKyBDU1MuQ29sb3JOYW1lc1skMl0gKyAoJDEgPyBcIlwiIDogXCIsMSlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkMDtcbiAgICAgICAgICAgIH0pLnJlcGxhY2UocnhSR0IsIGZ1bmN0aW9uKCQwLCAkMSwgJDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJyZ2JhKFwiICsgJDIucmVwbGFjZShyeFNwYWNlcywgXCJcIikgKyAoJDEgPyBcIlwiIDogXCIsMVwiKSArIFwiKVwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgQ1NTLmZpeENvbG9ycyA9IGZpeENvbG9ycztcbiAgICB9KShDU1MgPSBWZWxvY2l0eVN0YXRpYy5DU1MgfHwgKFZlbG9jaXR5U3RhdGljLkNTUyA9IHt9KSk7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJmaXhDb2xvcnMudHNcIiAvPlxuLypcbiAqIFZlbG9jaXR5SlMub3JnIChDKSAyMDE0LTIwMTcgSnVsaWFuIFNoYXBpcm8uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGRldGFpbHMuXG4gKi8gdmFyIFZlbG9jaXR5U3RhdGljO1xuXG4oZnVuY3Rpb24oVmVsb2NpdHlTdGF0aWMpIHtcbiAgICB2YXIgQ1NTO1xuICAgIChmdW5jdGlvbihDU1MpIHtcbiAgICAgICAgLy8gQ29udmVydGluZyBmcm9tIGhleCBhcyBpdCBtYWtlcyBmb3IgYSBzbWFsbGVyIGZpbGUuXG4gICAgICAgIC8vIFRPRE86IFdoZW4gYnVpbGQgc3lzdGVtIGNoYW5nZXMgdG8gd2VicGFjaywgbWFrZSB0aGlzIG9uZSBvcHRpb25hbC5cbiAgICAgICAgdmFyIGNvbG9yVmFsdWVzID0ge1xuICAgICAgICAgICAgYWxpY2VibHVlOiAxNTc5MjM4MyxcbiAgICAgICAgICAgIGFudGlxdWV3aGl0ZTogMTY0NDQzNzUsXG4gICAgICAgICAgICBhcXVhOiA2NTUzNSxcbiAgICAgICAgICAgIGFxdWFtYXJpbmU6IDgzODg1NjQsXG4gICAgICAgICAgICBhenVyZTogMTU3OTQxNzUsXG4gICAgICAgICAgICBiZWlnZTogMTYxMTkyNjAsXG4gICAgICAgICAgICBiaXNxdWU6IDE2NzcwMjQ0LFxuICAgICAgICAgICAgYmxhY2s6IDAsXG4gICAgICAgICAgICBibGFuY2hlZGFsbW9uZDogMTY3NzIwNDUsXG4gICAgICAgICAgICBibHVlOiAyNTUsXG4gICAgICAgICAgICBibHVldmlvbGV0OiA5MDU1MjAyLFxuICAgICAgICAgICAgYnJvd246IDEwODI0MjM0LFxuICAgICAgICAgICAgYnVybHl3b29kOiAxNDU5NjIzMSxcbiAgICAgICAgICAgIGNhZGV0Ymx1ZTogNjI2NjUyOCxcbiAgICAgICAgICAgIGNoYXJ0cmV1c2U6IDgzODgzNTIsXG4gICAgICAgICAgICBjaG9jb2xhdGU6IDEzNzg5NDcwLFxuICAgICAgICAgICAgY29yYWw6IDE2NzQ0MjcyLFxuICAgICAgICAgICAgY29ybmZsb3dlcmJsdWU6IDY1OTE5ODEsXG4gICAgICAgICAgICBjb3Juc2lsazogMTY3NzUzODgsXG4gICAgICAgICAgICBjcmltc29uOiAxNDQyMzEwMCxcbiAgICAgICAgICAgIGN5YW46IDY1NTM1LFxuICAgICAgICAgICAgZGFya2JsdWU6IDEzOSxcbiAgICAgICAgICAgIGRhcmtjeWFuOiAzNTcyMyxcbiAgICAgICAgICAgIGRhcmtnb2xkZW5yb2Q6IDEyMDkyOTM5LFxuICAgICAgICAgICAgZGFya2dyYXk6IDExMTE5MDE3LFxuICAgICAgICAgICAgZGFya2dyZXk6IDExMTE5MDE3LFxuICAgICAgICAgICAgZGFya2dyZWVuOiAyNTYwMCxcbiAgICAgICAgICAgIGRhcmtraGFraTogMTI0MzMyNTksXG4gICAgICAgICAgICBkYXJrbWFnZW50YTogOTEwOTY0MyxcbiAgICAgICAgICAgIGRhcmtvbGl2ZWdyZWVuOiA1NTk3OTk5LFxuICAgICAgICAgICAgZGFya29yYW5nZTogMTY3NDc1MjAsXG4gICAgICAgICAgICBkYXJrb3JjaGlkOiAxMDA0MDAxMixcbiAgICAgICAgICAgIGRhcmtyZWQ6IDkxMDk1MDQsXG4gICAgICAgICAgICBkYXJrc2FsbW9uOiAxNTMwODQxMCxcbiAgICAgICAgICAgIGRhcmtzZWFncmVlbjogOTQxOTkxOSxcbiAgICAgICAgICAgIGRhcmtzbGF0ZWJsdWU6IDQ3MzQzNDcsXG4gICAgICAgICAgICBkYXJrc2xhdGVncmF5OiAzMTAwNDk1LFxuICAgICAgICAgICAgZGFya3NsYXRlZ3JleTogMzEwMDQ5NSxcbiAgICAgICAgICAgIGRhcmt0dXJxdW9pc2U6IDUyOTQ1LFxuICAgICAgICAgICAgZGFya3Zpb2xldDogOTY5OTUzOSxcbiAgICAgICAgICAgIGRlZXBwaW5rOiAxNjcxNjk0NyxcbiAgICAgICAgICAgIGRlZXBza3libHVlOiA0OTE1MSxcbiAgICAgICAgICAgIGRpbWdyYXk6IDY5MDgyNjUsXG4gICAgICAgICAgICBkaW1ncmV5OiA2OTA4MjY1LFxuICAgICAgICAgICAgZG9kZ2VyYmx1ZTogMjAwMzE5OSxcbiAgICAgICAgICAgIGZpcmVicmljazogMTE2NzQxNDYsXG4gICAgICAgICAgICBmbG9yYWx3aGl0ZTogMTY3NzU5MjAsXG4gICAgICAgICAgICBmb3Jlc3RncmVlbjogMjI2Mzg0MixcbiAgICAgICAgICAgIGZ1Y2hzaWE6IDE2NzExOTM1LFxuICAgICAgICAgICAgZ2FpbnNib3JvOiAxNDQ3NDQ2MCxcbiAgICAgICAgICAgIGdob3N0d2hpdGU6IDE2MzE2NjcxLFxuICAgICAgICAgICAgZ29sZDogMTY3NjY3MjAsXG4gICAgICAgICAgICBnb2xkZW5yb2Q6IDE0MzI5MTIwLFxuICAgICAgICAgICAgZ3JheTogODQyMTUwNCxcbiAgICAgICAgICAgIGdyZXk6IDg0MjE1MDQsXG4gICAgICAgICAgICBncmVlbjogMzI3NjgsXG4gICAgICAgICAgICBncmVlbnllbGxvdzogMTE0MDMwNTUsXG4gICAgICAgICAgICBob25leWRldzogMTU3OTQxNjAsXG4gICAgICAgICAgICBob3RwaW5rOiAxNjczODc0MCxcbiAgICAgICAgICAgIGluZGlhbnJlZDogMTM0NTg1MjQsXG4gICAgICAgICAgICBpbmRpZ286IDQ5MTUzMzAsXG4gICAgICAgICAgICBpdm9yeTogMTY3NzcyMDAsXG4gICAgICAgICAgICBraGFraTogMTU3ODc2NjAsXG4gICAgICAgICAgICBsYXZlbmRlcjogMTUxMzI0MTAsXG4gICAgICAgICAgICBsYXZlbmRlcmJsdXNoOiAxNjc3MzM2NSxcbiAgICAgICAgICAgIGxhd25ncmVlbjogODE5MDk3NixcbiAgICAgICAgICAgIGxlbW9uY2hpZmZvbjogMTY3NzU4ODUsXG4gICAgICAgICAgICBsaWdodGJsdWU6IDExMzkzMjU0LFxuICAgICAgICAgICAgbGlnaHRjb3JhbDogMTU3NjE1MzYsXG4gICAgICAgICAgICBsaWdodGN5YW46IDE0NzQ1NTk5LFxuICAgICAgICAgICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDE2NDQ4MjEwLFxuICAgICAgICAgICAgbGlnaHRncmF5OiAxMzg4MjMyMyxcbiAgICAgICAgICAgIGxpZ2h0Z3JleTogMTM4ODIzMjMsXG4gICAgICAgICAgICBsaWdodGdyZWVuOiA5NDk4MjU2LFxuICAgICAgICAgICAgbGlnaHRwaW5rOiAxNjc1ODQ2NSxcbiAgICAgICAgICAgIGxpZ2h0c2FsbW9uOiAxNjc1Mjc2MixcbiAgICAgICAgICAgIGxpZ2h0c2VhZ3JlZW46IDIxNDI4OTAsXG4gICAgICAgICAgICBsaWdodHNreWJsdWU6IDg5MDAzNDYsXG4gICAgICAgICAgICBsaWdodHNsYXRlZ3JheTogNzgzMzc1MyxcbiAgICAgICAgICAgIGxpZ2h0c2xhdGVncmV5OiA3ODMzNzUzLFxuICAgICAgICAgICAgbGlnaHRzdGVlbGJsdWU6IDExNTg0NzM0LFxuICAgICAgICAgICAgbGlnaHR5ZWxsb3c6IDE2Nzc3MTg0LFxuICAgICAgICAgICAgbGltZTogNjUyODAsXG4gICAgICAgICAgICBsaW1lZ3JlZW46IDMzMjkzMzAsXG4gICAgICAgICAgICBsaW5lbjogMTY0NDU2NzAsXG4gICAgICAgICAgICBtYWdlbnRhOiAxNjcxMTkzNSxcbiAgICAgICAgICAgIG1hcm9vbjogODM4ODYwOCxcbiAgICAgICAgICAgIG1lZGl1bWFxdWFtYXJpbmU6IDY3MzczMjIsXG4gICAgICAgICAgICBtZWRpdW1ibHVlOiAyMDUsXG4gICAgICAgICAgICBtZWRpdW1vcmNoaWQ6IDEyMjExNjY3LFxuICAgICAgICAgICAgbWVkaXVtcHVycGxlOiA5NjYyNjgzLFxuICAgICAgICAgICAgbWVkaXVtc2VhZ3JlZW46IDM5NzgwOTcsXG4gICAgICAgICAgICBtZWRpdW1zbGF0ZWJsdWU6IDgwODc3OTAsXG4gICAgICAgICAgICBtZWRpdW1zcHJpbmdncmVlbjogNjQxNTQsXG4gICAgICAgICAgICBtZWRpdW10dXJxdW9pc2U6IDQ3NzIzMDAsXG4gICAgICAgICAgICBtZWRpdW12aW9sZXRyZWQ6IDEzMDQ3MTczLFxuICAgICAgICAgICAgbWlkbmlnaHRibHVlOiAxNjQ0OTEyLFxuICAgICAgICAgICAgbWludGNyZWFtOiAxNjEyMTg1MCxcbiAgICAgICAgICAgIG1pc3R5cm9zZTogMTY3NzAyNzMsXG4gICAgICAgICAgICBtb2NjYXNpbjogMTY3NzAyMjksXG4gICAgICAgICAgICBuYXZham93aGl0ZTogMTY3Njg2ODUsXG4gICAgICAgICAgICBuYXZ5OiAxMjgsXG4gICAgICAgICAgICBvbGRsYWNlOiAxNjY0MzU1OCxcbiAgICAgICAgICAgIG9saXZlOiA4NDIxMzc2LFxuICAgICAgICAgICAgb2xpdmVkcmFiOiA3MDQ4NzM5LFxuICAgICAgICAgICAgb3JhbmdlOiAxNjc1MzkyMCxcbiAgICAgICAgICAgIG9yYW5nZXJlZDogMTY3MjkzNDQsXG4gICAgICAgICAgICBvcmNoaWQ6IDE0MzE1NzM0LFxuICAgICAgICAgICAgcGFsZWdvbGRlbnJvZDogMTU2NTcxMzAsXG4gICAgICAgICAgICBwYWxlZ3JlZW46IDEwMDI1ODgwLFxuICAgICAgICAgICAgcGFsZXR1cnF1b2lzZTogMTE1Mjk5NjYsXG4gICAgICAgICAgICBwYWxldmlvbGV0cmVkOiAxNDM4MTIwMyxcbiAgICAgICAgICAgIHBhcGF5YXdoaXA6IDE2NzczMDc3LFxuICAgICAgICAgICAgcGVhY2hwdWZmOiAxNjc2NzY3MyxcbiAgICAgICAgICAgIHBlcnU6IDEzNDY4OTkxLFxuICAgICAgICAgICAgcGluazogMTY3NjEwMzUsXG4gICAgICAgICAgICBwbHVtOiAxNDUyNDYzNyxcbiAgICAgICAgICAgIHBvd2RlcmJsdWU6IDExNTkxOTEwLFxuICAgICAgICAgICAgcHVycGxlOiA4Mzg4NzM2LFxuICAgICAgICAgICAgcmViZWNjYXB1cnBsZTogNjY5Nzg4MSxcbiAgICAgICAgICAgIHJlZDogMTY3MTE2ODAsXG4gICAgICAgICAgICByb3N5YnJvd246IDEyMzU3NTE5LFxuICAgICAgICAgICAgcm95YWxibHVlOiA0Mjg2OTQ1LFxuICAgICAgICAgICAgc2FkZGxlYnJvd246IDkxMjcxODcsXG4gICAgICAgICAgICBzYWxtb246IDE2NDE2ODgyLFxuICAgICAgICAgICAgc2FuZHlicm93bjogMTYwMzI4NjQsXG4gICAgICAgICAgICBzZWFncmVlbjogMzA1MDMyNyxcbiAgICAgICAgICAgIHNlYXNoZWxsOiAxNjc3NDYzOCxcbiAgICAgICAgICAgIHNpZW5uYTogMTA1MDY3OTcsXG4gICAgICAgICAgICBzaWx2ZXI6IDEyNjMyMjU2LFxuICAgICAgICAgICAgc2t5Ymx1ZTogODkwMDMzMSxcbiAgICAgICAgICAgIHNsYXRlYmx1ZTogNjk3MDA2MSxcbiAgICAgICAgICAgIHNsYXRlZ3JheTogNzM3Mjk0NCxcbiAgICAgICAgICAgIHNsYXRlZ3JleTogNzM3Mjk0NCxcbiAgICAgICAgICAgIHNub3c6IDE2Nzc1OTMwLFxuICAgICAgICAgICAgc3ByaW5nZ3JlZW46IDY1NDA3LFxuICAgICAgICAgICAgc3RlZWxibHVlOiA0NjIwOTgwLFxuICAgICAgICAgICAgdGFuOiAxMzgwODc4MCxcbiAgICAgICAgICAgIHRlYWw6IDMyODk2LFxuICAgICAgICAgICAgdGhpc3RsZTogMTQyMDQ4ODgsXG4gICAgICAgICAgICB0b21hdG86IDE2NzM3MDk1LFxuICAgICAgICAgICAgdHVycXVvaXNlOiA0MjUxODU2LFxuICAgICAgICAgICAgdmlvbGV0OiAxNTYzMTA4NixcbiAgICAgICAgICAgIHdoZWF0OiAxNjExMzMzMSxcbiAgICAgICAgICAgIHdoaXRlOiAxNjc3NzIxNSxcbiAgICAgICAgICAgIHdoaXRlc21va2U6IDE2MTE5Mjg1LFxuICAgICAgICAgICAgeWVsbG93OiAxNjc3Njk2MCxcbiAgICAgICAgICAgIHllbGxvd2dyZWVuOiAxMDE0NTA3NFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBuYW1lXzIgaW4gY29sb3JWYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChjb2xvclZhbHVlcy5oYXNPd25Qcm9wZXJ0eShuYW1lXzIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gY29sb3JWYWx1ZXNbbmFtZV8yXTtcbiAgICAgICAgICAgICAgICBDU1MuQ29sb3JOYW1lc1tuYW1lXzJdID0gTWF0aC5mbG9vcihjb2xvciAvIDY1NTM2KSArIFwiLFwiICsgTWF0aC5mbG9vcihjb2xvciAvIDI1NiAlIDI1NikgKyBcIixcIiArIGNvbG9yICUgMjU2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkoQ1NTID0gVmVsb2NpdHlTdGF0aWMuQ1NTIHx8IChWZWxvY2l0eVN0YXRpYy5DU1MgPSB7fSkpO1xufSkoVmVsb2NpdHlTdGF0aWMgfHwgKFZlbG9jaXR5U3RhdGljID0ge30pKTtcblxuLypcbiAqIFZlbG9jaXR5SlMub3JnIChDKSAyMDE0LTIwMTcgSnVsaWFuIFNoYXBpcm8uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGRldGFpbHMuXG4gKi8gdmFyIFZlbG9jaXR5U3RhdGljO1xuXG4oZnVuY3Rpb24oVmVsb2NpdHlTdGF0aWMpIHtcbiAgICB2YXIgQ1NTO1xuICAgIChmdW5jdGlvbihDU1MpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBzdGlsbCBhIGNvbXBsZXRlIG1lc3NcbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVByb3BlcnR5VmFsdWUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gRGF0YShlbGVtZW50KSxcbiAgICAgICAgICAgIC8vIElmIGNvbXB1dGVkU3R5bGUgaXMgY2FjaGVkLCB1c2UgaXQuXG4gICAgICAgICAgICBjb21wdXRlZFN0eWxlID0gZGF0YSAmJiBkYXRhLmNvbXB1dGVkU3R5bGUgPyBkYXRhLmNvbXB1dGVkU3R5bGUgOiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgICAgICAgICAgIHZhciBjb21wdXRlZFZhbHVlID0gMDtcbiAgICAgICAgICAgIGlmIChkYXRhICYmICFkYXRhLmNvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmNvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSBcIndpZHRoXCIgfHwgcHJvcGVydHkgPT09IFwiaGVpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBCcm93c2VycyBkbyBub3QgcmV0dXJuIGhlaWdodCBhbmQgd2lkdGggdmFsdWVzIGZvciBlbGVtZW50c1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgYXJlIHNldCB0byBkaXNwbGF5Olwibm9uZVwiLiBUaHVzLCB3ZSB0ZW1wb3JhcmlseSB0b2dnbGVcbiAgICAgICAgICAgICAgICAvLyBkaXNwbGF5IHRvIHRoZSBlbGVtZW50IHR5cGUncyBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgICAgICAgIHZhciB0b2dnbGVEaXNwbGF5ID0gZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcImRpc3BsYXlcIikgPT09IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gYm94LXNpemluZyBpc24ndCBzZXQgdG8gYm9yZGVyLWJveCwgaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICAgICAgICAgIC8vIHN0eWxlIHZhbHVlcyBhcmUgaW5jb3JyZWN0bHkgY29tcHV0ZWQgd2hlbiBhbiBlbGVtZW50J3NcbiAgICAgICAgICAgICAgICAvLyBzY3JvbGxiYXJzIGFyZSB2aXNpYmxlICh3aGljaCBleHBhbmRzIHRoZSBlbGVtZW50J3NcbiAgICAgICAgICAgICAgICAvLyBkaW1lbnNpb25zKS4gVGh1cywgd2UgZGVmZXIgdG8gdGhlIG1vcmUgYWNjdXJhdGVcbiAgICAgICAgICAgICAgICAvLyBvZmZzZXRIZWlnaHQvV2lkdGggcHJvcGVydHksIHdoaWNoIGluY2x1ZGVzIHRoZSB0b3RhbFxuICAgICAgICAgICAgICAgIC8vIGRpbWVuc2lvbnMgZm9yIGludGVyaW9yLCBib3JkZXIsIHBhZGRpbmcsIGFuZCBzY3JvbGxiYXIuIFdlXG4gICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgYm9yZGVyIGFuZCBwYWRkaW5nIHRvIGdldCB0aGUgc3VtIG9mIGludGVyaW9yICtcbiAgICAgICAgICAgICAgICAvLyBzY3JvbGxiYXIuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogb2Zmc2V0SGVpZ2h0IGRvZXMgbm90IGV4aXN0IG9uIFNWR0VsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvZ2dsZURpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgQ1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJkaXNwbGF5XCIsIFwiYXV0b1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tcHV0ZWRWYWx1ZSA9IFZlbG9jaXR5U3RhdGljLmF1Z21lbnREaW1lbnNpb24oZWxlbWVudCwgcHJvcGVydHksIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICh0b2dnbGVEaXNwbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIENTUy5zZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcoY29tcHV0ZWRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBJRSBhbmQgRmlyZWZveCBkbyBub3QgcmV0dXJuIGEgdmFsdWUgZm9yIHRoZSBnZW5lcmljIGJvcmRlckNvbG9yIC0tIHRoZXkgb25seSByZXR1cm4gaW5kaXZpZHVhbCB2YWx1ZXMgZm9yIGVhY2ggYm9yZGVyIHNpZGUncyBjb2xvci5cbiAgICAgICAgICAgICBBbHNvLCBpbiBhbGwgYnJvd3NlcnMsIHdoZW4gYm9yZGVyIGNvbG9ycyBhcmVuJ3QgYWxsIHRoZSBzYW1lLCBhIGNvbXBvdW5kIHZhbHVlIGlzIHJldHVybmVkIHRoYXQgVmVsb2NpdHkgaXNuJ3Qgc2V0dXAgdG8gcGFyc2UuXG4gICAgICAgICAgICAgU28sIGFzIGEgcG9seWZpbGwgZm9yIHF1ZXJ5aW5nIGluZGl2aWR1YWwgYm9yZGVyIHNpZGUgY29sb3JzLCB3ZSBqdXN0IHJldHVybiB0aGUgdG9wIGJvcmRlcidzIGNvbG9yIGFuZCBhbmltYXRlIGFsbCBib3JkZXJzIGZyb20gdGhhdCB2YWx1ZS4gKi9cbiAgICAgICAgICAgIC8qIFRPRE86IFRoZXJlIGlzIGEgYm9yZGVyQ29sb3Igbm9ybWFsaXNhdGlvbiBpbiBsZWdhY3kvIC0gZmlndXJlIG91dCB3aGVyZSB0aGlzIGlzIG5lZWRlZC4uLiAqLyAgICAgICAgICAgIGNvbXB1dGVkVmFsdWUgPSBjb21wdXRlZFN0eWxlW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIC8qIEZhbGwgYmFjayB0byB0aGUgcHJvcGVydHkncyBzdHlsZSB2YWx1ZSAoaWYgZGVmaW5lZCkgd2hlbiBjb21wdXRlZFZhbHVlIHJldHVybnMgbm90aGluZyxcbiAgICAgICAgICAgICB3aGljaCBjYW4gaGFwcGVuIHdoZW4gdGhlIGVsZW1lbnQgaGFzbid0IGJlZW4gcGFpbnRlZC4gKi8gICAgICAgICAgICBpZiAoIWNvbXB1dGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlZFZhbHVlID0gZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBGb3IgdG9wLCByaWdodCwgYm90dG9tLCBhbmQgbGVmdCAoVFJCTCkgdmFsdWVzIHRoYXQgYXJlIHNldCB0byBcImF1dG9cIiBvbiBlbGVtZW50cyBvZiBcImZpeGVkXCIgb3IgXCJhYnNvbHV0ZVwiIHBvc2l0aW9uLFxuICAgICAgICAgICAgIGRlZmVyIHRvIGpRdWVyeSBmb3IgY29udmVydGluZyBcImF1dG9cIiB0byBhIG51bWVyaWMgdmFsdWUuIChGb3IgZWxlbWVudHMgd2l0aCBhIFwic3RhdGljXCIgb3IgXCJyZWxhdGl2ZVwiIHBvc2l0aW9uLCBcImF1dG9cIiBoYXMgdGhlIHNhbWVcbiAgICAgICAgICAgICBlZmZlY3QgYXMgYmVpbmcgc2V0IHRvIDAsIHNvIG5vIGNvbnZlcnNpb24gaXMgbmVjZXNzYXJ5LikgKi9cbiAgICAgICAgICAgIC8qIEFuIGV4YW1wbGUgb2Ygd2h5IG51bWVyaWMgY29udmVyc2lvbiBpcyBuZWNlc3Nhcnk6IFdoZW4gYW4gZWxlbWVudCB3aXRoIFwicG9zaXRpb246YWJzb2x1dGVcIiBoYXMgYW4gdW50b3VjaGVkIFwibGVmdFwiXG4gICAgICAgICAgICAgcHJvcGVydHksIHdoaWNoIHJldmVydHMgdG8gXCJhdXRvXCIsIGxlZnQncyB2YWx1ZSBpcyAwIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgZWxlbWVudCwgYnV0IGlzIG9mdGVuIG5vbi16ZXJvIHJlbGF0aXZlXG4gICAgICAgICAgICAgdG8gaXRzICpjb250YWluaW5nKiAobm90IHBhcmVudCkgZWxlbWVudCwgd2hpY2ggaXMgdGhlIG5lYXJlc3QgXCJwb3NpdGlvbjpyZWxhdGl2ZVwiIGFuY2VzdG9yIG9yIHRoZSB2aWV3cG9ydCAoYW5kIGFsd2F5cyB0aGUgdmlld3BvcnQgaW4gdGhlIGNhc2Ugb2YgXCJwb3NpdGlvbjpmaXhlZFwiKS4gKi8gICAgICAgICAgICBpZiAoY29tcHV0ZWRWYWx1ZSA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wTGVmdCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBnZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwicG9zaXRpb25cIik7XG4gLyogR0VUICovICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IFwiZml4ZWRcIiB8fCB0b3BMZWZ0ICYmIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgaGFzIG5vIHBpeGVsIHVuaXQgb24gaXRzIHJldHVybmVkIHZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHJlLWFkZCBpdCBoZXJlIHRvIGNvbmZvcm0gd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcHV0ZVByb3BlcnR5VmFsdWUncyBiZWhhdmlvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkVmFsdWUgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdFtwcm9wZXJ0eV0gKyBcInB4XCI7XG4gLyogR0VUICovICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlIGZhbGx0aHJvdWdoIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZFZhbHVlID0gXCIwcHhcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGVkVmFsdWUgPyBTdHJpbmcoY29tcHV0ZWRWYWx1ZSkgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIENTUy5jb21wdXRlUHJvcGVydHlWYWx1ZSA9IGNvbXB1dGVQcm9wZXJ0eVZhbHVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgcHJvcGVydHkgdmFsdWUuIFRoaXMgd2lsbCBncmFiIHZpYSB0aGUgY2FjaGUgaWYgaXQgZXhpc3RzLCB0aGVuXG4gICAgICAgICAqIHZpYSBhbnkgbm9ybWFsaXNhdGlvbnMuXG4gICAgICAgICAqLyAgICAgICAgZnVuY3Rpb24gZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBwcm9wZXJ0eU5hbWUsIGZuLCBza2lwQ2FjaGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gRGF0YShlbGVtZW50KTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eVZhbHVlO1xuICAgICAgICAgICAgaWYgKFZlbG9jaXR5U3RhdGljLk5vQ2FjaGVOb3JtYWxpemF0aW9ucy5oYXMocHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHNraXBDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNraXBDYWNoZSAmJiBkYXRhICYmIGRhdGEuY2FjaGVbcHJvcGVydHlOYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlWYWx1ZSA9IGRhdGEuY2FjaGVbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm4gPSBmbiB8fCBWZWxvY2l0eVN0YXRpYy5nZXROb3JtYWxpemF0aW9uKGVsZW1lbnQsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5VmFsdWUgPSBmbihlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2FjaGVbcHJvcGVydHlOYW1lXSA9IHByb3BlcnR5VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVmVsb2NpdHlTdGF0aWMuZGVidWcgPj0gMikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkdldCBcIiArIHByb3BlcnR5TmFtZSArIFwiOiBcIiArIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgQ1NTLmdldFByb3BlcnR5VmFsdWUgPSBnZXRQcm9wZXJ0eVZhbHVlO1xuICAgIH0pKENTUyA9IFZlbG9jaXR5U3RhdGljLkNTUyB8fCAoVmVsb2NpdHlTdGF0aWMuQ1NTID0ge30pKTtcbn0pKFZlbG9jaXR5U3RhdGljIHx8IChWZWxvY2l0eVN0YXRpYyA9IHt9KSk7XG5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICovIHZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgdmFyIENTUztcbiAgICAoZnVuY3Rpb24oQ1NTKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgcG9zc2libGUgdW5pdHMgaW4gQ1NTLiBVc2VkIHRvIHJlY29nbmlzZSB1bml0cyB3aGVuIHBhcnNpbmcgdHdlZW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIFVuaXRzID0gWyBcIiVcIiwgXCJlbVwiLCBcImV4XCIsIFwiY2hcIiwgXCJyZW1cIiwgXCJ2d1wiLCBcInZoXCIsIFwidm1pblwiLCBcInZtYXhcIiwgXCJjbVwiLCBcIm1tXCIsIFwiUVwiLCBcImluXCIsIFwicGNcIiwgXCJwdFwiLCBcInB4XCIsIFwiZGVnXCIsIFwiZ3JhZFwiLCBcInJhZFwiLCBcInR1cm5cIiwgXCJzXCIsIFwibXNcIiBdO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHVuaXQgZm9yIHRoaXMgcHJvcGVydHkuIE9ubHkgdXNlZCB3aGVuIHBhcnNpbmcgdHdlZW5zXG4gICAgICAgICAqIHRvIGNoZWNrIGlmIHRoZSB1bml0IGlzIGNoYW5naW5nIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzLlxuICAgICAgICAgKi8gICAgICAgIGZ1bmN0aW9uIGdldFVuaXQocHJvcGVydHksIHN0YXJ0KSB7XG4gICAgICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICAgICAgICBpZiAocHJvcGVydHlbc3RhcnRdICYmIHByb3BlcnR5W3N0YXJ0XSAhPT0gXCIgXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgdW5pdHMgPSBVbml0czsgaSA8IHVuaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1bml0ID0gdW5pdHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPj0gdW5pdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bml0W2pdICE9PSBwcm9wZXJ0eVtzdGFydCArIGpdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKCsraik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgQ1NTLmdldFVuaXQgPSBnZXRVbml0O1xuICAgIH0pKENTUyA9IFZlbG9jaXR5U3RhdGljLkNTUyB8fCAoVmVsb2NpdHlTdGF0aWMuQ1NTID0ge30pKTtcbn0pKFZlbG9jaXR5U3RhdGljIHx8IChWZWxvY2l0eVN0YXRpYyA9IHt9KSk7XG5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICovIHZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgdmFyIENTUztcbiAgICAoZnVuY3Rpb24oQ1NTKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2luZ3VsYXIgc2V0UHJvcGVydHlWYWx1ZSwgd2hpY2ggcm91dGVzIHRoZSBsb2dpYyBmb3IgYWxsXG4gICAgICAgICAqIG5vcm1hbGl6YXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUsIGZuKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IERhdGEoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcocHJvcGVydHlWYWx1ZSkgJiYgcHJvcGVydHlWYWx1ZVswXSA9PT0gXCJjXCIgJiYgcHJvcGVydHlWYWx1ZVsxXSA9PT0gXCJhXCIgJiYgcHJvcGVydHlWYWx1ZVsyXSA9PT0gXCJsXCIgJiYgcHJvcGVydHlWYWx1ZVszXSA9PT0gXCJjXCIgJiYgcHJvcGVydHlWYWx1ZVs0XSA9PT0gXCIoXCIgJiYgcHJvcGVydHlWYWx1ZVs1XSA9PT0gXCIwXCIgJiYgcHJvcGVydHlWYWx1ZVs1XSA9PT0gXCIgXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgdW4tY2FsYyB1bml0IGNoYW5naW5nIHZhbHVlcyAtIHRyeSBub3QgdG8gdHJpZ2dlclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBhbnkgbW9yZSBvZnRlbiB0aGFuIHdlIGhhdmUgdG8gc2luY2UgaXQncyBleHBlbnNpdmVcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eVZhbHVlID0gcHJvcGVydHlWYWx1ZS5yZXBsYWNlKC9eY2FsY1xcKDBbXlxcZF0qIFxcKyAoW15cXChcXCldKylcXCkkLywgXCIkMVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEuY2FjaGVbcHJvcGVydHlOYW1lXSAhPT0gcHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIEJ5IHNldHRpbmcgaXQgdG8gdW5kZWZpbmVkIHdlIGZvcmNlIGEgdHJ1ZSBcImdldFwiIGxhdGVyXG4gICAgICAgICAgICAgICAgZGF0YS5jYWNoZVtwcm9wZXJ0eU5hbWVdID0gcHJvcGVydHlWYWx1ZSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZm4gPSBmbiB8fCBWZWxvY2l0eVN0YXRpYy5nZXROb3JtYWxpemF0aW9uKGVsZW1lbnQsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoVmVsb2NpdHlTdGF0aWMuZGVidWcgPj0gMikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJTZXQgXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIjogXCIgKyBwcm9wZXJ0eVZhbHVlLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQ1NTLnNldFByb3BlcnR5VmFsdWUgPSBzZXRQcm9wZXJ0eVZhbHVlO1xuICAgIH0pKENTUyA9IFZlbG9jaXR5U3RhdGljLkNTUyB8fCAoVmVsb2NpdHlTdGF0aWMuQ1NTID0ge30pKTtcbn0pKFZlbG9jaXR5U3RhdGljIHx8IChWZWxvY2l0eVN0YXRpYyA9IHt9KSk7XG5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICovXG52YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIHZhciBFYXNpbmc7XG4gICAgKGZ1bmN0aW9uKEVhc2luZykge1xuICAgICAgICBFYXNpbmcuRWFzaW5ncyA9IGNyZWF0ZUVtcHR5T2JqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIHJlZ2lzdGVyIGEgZWFzaW5nLiBUaGlzIHNob3VsZCBuZXZlciBiZSBjYWxsZWQgYnkgdXNlcnNcbiAgICAgICAgICogZGlyZWN0bHksIGluc3RlYWQgaXQgc2hvdWxkIGJlIGNhbGxlZCB2aWEgYW4gYWN0aW9uOjxici8+XG4gICAgICAgICAqIDxjb2RlPlZlbG9jaXR5KFwicmVnaXN0ZXJFYXNpbmdcIiwgXCJuYW1lXCIsIFZlbG9jaXR5RWFzaW5nRm4pOzwvY29kZT5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovICAgICAgICBmdW5jdGlvbiByZWdpc3RlckVhc2luZyhhcmdzKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGFyZ3NbMF0sIGNhbGxiYWNrID0gYXJnc1sxXTtcbiAgICAgICAgICAgIGlmICghaXNTdHJpbmcobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJWZWxvY2l0eUpTOiBUcnlpbmcgdG8gc2V0ICdyZWdpc3RlckVhc2luZycgbmFtZSB0byBhbiBpbnZhbGlkIHZhbHVlOlwiLCBuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVmVsb2NpdHlKUzogVHJ5aW5nIHRvIHNldCAncmVnaXN0ZXJFYXNpbmcnIGNhbGxiYWNrIHRvIGFuIGludmFsaWQgdmFsdWU6XCIsIG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoRWFzaW5nLkVhc2luZ3NbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJWZWxvY2l0eUpTOiBUcnlpbmcgdG8gb3ZlcnJpZGUgJ3JlZ2lzdGVyRWFzaW5nJyBjYWxsYmFja1wiLCBuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgRWFzaW5nLkVhc2luZ3NbbmFtZV0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBFYXNpbmcucmVnaXN0ZXJFYXNpbmcgPSByZWdpc3RlckVhc2luZztcbiAgICAgICAgVmVsb2NpdHlTdGF0aWMucmVnaXN0ZXJBY3Rpb24oWyBcInJlZ2lzdGVyRWFzaW5nXCIsIHJlZ2lzdGVyRWFzaW5nIF0sIHRydWUpO1xuICAgICAgICAvKiBCYXNpYyAoc2FtZSBhcyBqUXVlcnkpIGVhc2luZ3MuICovICAgICAgICByZWdpc3RlckVhc2luZyhbIFwibGluZWFyXCIsIGZ1bmN0aW9uKHBlcmNlbnRDb21wbGV0ZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydFZhbHVlICsgcGVyY2VudENvbXBsZXRlICogKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgIH0gXSk7XG4gICAgICAgIHJlZ2lzdGVyRWFzaW5nKFsgXCJzd2luZ1wiLCBmdW5jdGlvbihwZXJjZW50Q29tcGxldGUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRWYWx1ZSArICguNSAtIE1hdGguY29zKHBlcmNlbnRDb21wbGV0ZSAqIE1hdGguUEkpIC8gMikgKiAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcbiAgICAgICAgfSBdKTtcbiAgICAgICAgLyogQm9udXMgXCJzcHJpbmdcIiBlYXNpbmcsIHdoaWNoIGlzIGEgbGVzcyBleGFnZ2VyYXRlZCB2ZXJzaW9uIG9mIGVhc2VJbk91dEVsYXN0aWMuICovICAgICAgICByZWdpc3RlckVhc2luZyhbIFwic3ByaW5nXCIsIGZ1bmN0aW9uKHBlcmNlbnRDb21wbGV0ZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydFZhbHVlICsgKDEgLSBNYXRoLmNvcyhwZXJjZW50Q29tcGxldGUgKiA0LjUgKiBNYXRoLlBJKSAqIE1hdGguZXhwKC1wZXJjZW50Q29tcGxldGUgKiA2KSkgKiAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcbiAgICAgICAgfSBdKTtcbiAgICB9KShFYXNpbmcgPSBWZWxvY2l0eVN0YXRpYy5FYXNpbmcgfHwgKFZlbG9jaXR5U3RhdGljLkVhc2luZyA9IHt9KSk7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJlYXNpbmdzLnRzXCIgLz5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICpcbiAqIEJhY2sgZWFzaW5ncywgYmFzZWQgb24gY29kZSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS95dWljaGlyb2hhcmFpL2Vhc2VwbHVzLXZlbG9jaXR5XG4gKi9cbnZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgdmFyIEVhc2luZztcbiAgICAoZnVuY3Rpb24oRWFzaW5nKSB7XG4gICAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVyQmFja0luKG5hbWUsIGFtb3VudCkge1xuICAgICAgICAgICAgRWFzaW5nLnJlZ2lzdGVyRWFzaW5nKFsgbmFtZSwgZnVuY3Rpb24ocGVyY2VudENvbXBsZXRlLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50Q29tcGxldGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50Q29tcGxldGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3cocGVyY2VudENvbXBsZXRlLCAyKSAqICgoYW1vdW50ICsgMSkgKiBwZXJjZW50Q29tcGxldGUgLSBhbW91bnQpICogKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICB9IF0pO1xuICAgICAgICB9XG4gICAgICAgIEVhc2luZy5yZWdpc3RlckJhY2tJbiA9IHJlZ2lzdGVyQmFja0luO1xuICAgICAgICBmdW5jdGlvbiByZWdpc3RlckJhY2tPdXQobmFtZSwgYW1vdW50KSB7XG4gICAgICAgICAgICBFYXNpbmcucmVnaXN0ZXJFYXNpbmcoWyBuYW1lLCBmdW5jdGlvbihwZXJjZW50Q29tcGxldGUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnRDb21wbGV0ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnRDb21wbGV0ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5kVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoTWF0aC5wb3coLS1wZXJjZW50Q29tcGxldGUsIDIpICogKChhbW91bnQgKyAxKSAqIHBlcmNlbnRDb21wbGV0ZSArIGFtb3VudCkgKyAxKSAqIChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgfSBdKTtcbiAgICAgICAgfVxuICAgICAgICBFYXNpbmcucmVnaXN0ZXJCYWNrT3V0ID0gcmVnaXN0ZXJCYWNrT3V0O1xuICAgICAgICBmdW5jdGlvbiByZWdpc3RlckJhY2tJbk91dChuYW1lLCBhbW91bnQpIHtcbiAgICAgICAgICAgIGFtb3VudCAqPSAxLjUyNTtcbiAgICAgICAgICAgIEVhc2luZy5yZWdpc3RlckVhc2luZyhbIG5hbWUsIGZ1bmN0aW9uKHBlcmNlbnRDb21wbGV0ZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudENvbXBsZXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudENvbXBsZXRlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICgocGVyY2VudENvbXBsZXRlICo9IDIpIDwgMSA/IE1hdGgucG93KHBlcmNlbnRDb21wbGV0ZSwgMikgKiAoKGFtb3VudCArIDEpICogcGVyY2VudENvbXBsZXRlIC0gYW1vdW50KSA6IE1hdGgucG93KHBlcmNlbnRDb21wbGV0ZSAtPSAyLCAyKSAqICgoYW1vdW50ICsgMSkgKiBwZXJjZW50Q29tcGxldGUgKyBhbW91bnQpICsgMikgKiAuNSAqIChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgfSBdKTtcbiAgICAgICAgfVxuICAgICAgICBFYXNpbmcucmVnaXN0ZXJCYWNrSW5PdXQgPSByZWdpc3RlckJhY2tJbk91dDtcbiAgICAgICAgcmVnaXN0ZXJCYWNrSW4oXCJlYXNlSW5CYWNrXCIsIDEuNyk7XG4gICAgICAgIHJlZ2lzdGVyQmFja091dChcImVhc2VPdXRCYWNrXCIsIDEuNyk7XG4gICAgICAgIHJlZ2lzdGVyQmFja0luT3V0KFwiZWFzZUluT3V0QmFja1wiLCAxLjcpO1xuICAgICAgICAvLyBUT0RPOiBFeHBvc2UgdGhlc2UgYXMgYWN0aW9ucyB0byByZWdpc3RlciBjdXN0b20gZWFzaW5ncz9cbiAgICAgICAgfSkoRWFzaW5nID0gVmVsb2NpdHlTdGF0aWMuRWFzaW5nIHx8IChWZWxvY2l0eVN0YXRpYy5FYXNpbmcgPSB7fSkpO1xufSkoVmVsb2NpdHlTdGF0aWMgfHwgKFZlbG9jaXR5U3RhdGljID0ge30pKTtcblxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiZWFzaW5ncy50c1wiIC8+XG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqXG4gKiBCZXppZXIgY3VydmUgZnVuY3Rpb24gZ2VuZXJhdG9yLiBDb3B5cmlnaHQgR2FldGFuIFJlbmF1ZGVhdS4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2VcbiAqL1xudmFyIFZlbG9jaXR5U3RhdGljO1xuXG4oZnVuY3Rpb24oVmVsb2NpdHlTdGF0aWMpIHtcbiAgICB2YXIgRWFzaW5nO1xuICAgIChmdW5jdGlvbihFYXNpbmcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpeCB0byBhIHJhbmdlIG9mIDxjb2RlPjAgPD0gbnVtIDw9IDE8L2NvZGU+LlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZml4UmFuZ2UobnVtKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobnVtLCAwKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gQShhQTEsIGFBMikge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSAzICogYUEyICsgMyAqIGFBMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBCKGFBMSwgYUEyKSB7XG4gICAgICAgICAgICByZXR1cm4gMyAqIGFBMiAtIDYgKiBhQTE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gQyhhQTEpIHtcbiAgICAgICAgICAgIHJldHVybiAzICogYUExO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7XG4gICAgICAgICAgICByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0U2xvcGUoYVQsIGFBMSwgYUEyKSB7XG4gICAgICAgICAgICByZXR1cm4gMyAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlQmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICAgICAgICAgICAgdmFyIE5FV1RPTl9JVEVSQVRJT05TID0gNCwgTkVXVE9OX01JTl9TTE9QRSA9IC4wMDEsIFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDFlLTcsIFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TID0gMTAsIGtTcGxpbmVUYWJsZVNpemUgPSAxMSwga1NhbXBsZVN0ZXBTaXplID0gMSAvIChrU3BsaW5lVGFibGVTaXplIC0gMSksIGZsb2F0MzJBcnJheVN1cHBvcnRlZCA9IFwiRmxvYXQzMkFycmF5XCIgaW4gd2luZG93O1xuICAgICAgICAgICAgLyogTXVzdCBjb250YWluIGZvdXIgYXJndW1lbnRzLiAqLyAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogQXJndW1lbnRzIG11c3QgYmUgbnVtYmVycy4gKi8gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldICE9PSBcIm51bWJlclwiIHx8IGlzTmFOKGFyZ3VtZW50c1tpXSkgfHwgIWlzRmluaXRlKGFyZ3VtZW50c1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFggdmFsdWVzIG11c3QgYmUgaW4gdGhlIFswLCAxXSByYW5nZS4gKi8gICAgICAgICAgICBtWDEgPSBmaXhSYW5nZShtWDEpO1xuICAgICAgICAgICAgbVgyID0gZml4UmFuZ2UobVgyKTtcbiAgICAgICAgICAgIHZhciBtU2FtcGxlVmFsdWVzID0gZmxvYXQzMkFycmF5U3VwcG9ydGVkID8gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKSA6IG5ldyBBcnJheShrU3BsaW5lVGFibGVTaXplKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NUKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBORVdUT05fSVRFUkFUSU9OUzsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICAgICAgICAgICAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gY2FsY1NhbXBsZVZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBtU2FtcGxlVmFsdWVzW2ldID0gY2FsY0JlemllcihpICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFgsIGN1cnJlbnRULCBpID0gMDtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhQiA9IGN1cnJlbnRUO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJ2YWxTdGFydCA9IDAsIGN1cnJlbnRTYW1wbGUgPSAxLCBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG4gICAgICAgICAgICAgICAgZm9yICg7Y3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC0tY3VycmVudFNhbXBsZTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IChhWCAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSksIGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplLCBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5pdGlhbFNsb3BlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9wcmVjb21wdXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZnVuY3Rpb24gcHJlY29tcHV0ZSgpIHtcbiAgICAgICAgICAgICAgICBfcHJlY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgICAgICAgICAgICAgICAgICBjYWxjU2FtcGxlVmFsdWVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGYgPSBmdW5jdGlvbihwZXJjZW50Q29tcGxldGUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGlmICghX3ByZWNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNvbXB1dGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnRDb21wbGV0ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnRDb21wbGV0ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5kVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRWYWx1ZSArIHBlcmNlbnRDb21wbGV0ZSAqIChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRWYWx1ZSArIGNhbGNCZXppZXIoZ2V0VEZvclgocGVyY2VudENvbXBsZXRlKSwgbVkxLCBtWTIpICogKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZi5nZXRDb250cm9sUG9pbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsge1xuICAgICAgICAgICAgICAgICAgICB4OiBtWDEsXG4gICAgICAgICAgICAgICAgICAgIHk6IG1ZMVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgeDogbVgyLFxuICAgICAgICAgICAgICAgICAgICB5OiBtWTJcbiAgICAgICAgICAgICAgICB9IF07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHN0ciA9IFwiZ2VuZXJhdGVCZXppZXIoXCIgKyBbIG1YMSwgbVkxLCBtWDIsIG1ZMiBdICsgXCIpXCI7XG4gICAgICAgICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfVxuICAgICAgICBFYXNpbmcuZ2VuZXJhdGVCZXppZXIgPSBnZW5lcmF0ZUJlemllcjtcbiAgICAgICAgLyogQ29tbW9uIGVhc2luZ3MgKi8gICAgICAgIHZhciBlYXNlSW4gPSBnZW5lcmF0ZUJlemllciguNDIsIDAsIDEsIDEpLCBlYXNlT3V0ID0gZ2VuZXJhdGVCZXppZXIoMCwgMCwgLjU4LCAxKSwgZWFzZUluT3V0ID0gZ2VuZXJhdGVCZXppZXIoLjQyLCAwLCAuNTgsIDEpO1xuICAgICAgICBFYXNpbmcucmVnaXN0ZXJFYXNpbmcoWyBcImVhc2VcIiwgZ2VuZXJhdGVCZXppZXIoLjI1LCAuMSwgLjI1LCAxKSBdKTtcbiAgICAgICAgRWFzaW5nLnJlZ2lzdGVyRWFzaW5nKFsgXCJlYXNlSW5cIiwgZWFzZUluIF0pO1xuICAgICAgICBFYXNpbmcucmVnaXN0ZXJFYXNpbmcoWyBcImVhc2UtaW5cIiwgZWFzZUluIF0pO1xuICAgICAgICBFYXNpbmcucmVnaXN0ZXJFYXNpbmcoWyBcImVhc2VPdXRcIiwgZWFzZU91dCBdKTtcbiAgICAgICAgRWFzaW5nLnJlZ2lzdGVyRWFzaW5nKFsgXCJlYXNlLW91dFwiLCBlYXNlT3V0IF0pO1xuICAgICAgICBFYXNpbmcucmVnaXN0ZXJFYXNpbmcoWyBcImVhc2VJbk91dFwiLCBlYXNlSW5PdXQgXSk7XG4gICAgICAgIEVhc2luZy5yZWdpc3RlckVhc2luZyhbIFwiZWFzZS1pbi1vdXRcIiwgZWFzZUluT3V0IF0pO1xuICAgICAgICBFYXNpbmcucmVnaXN0ZXJFYXNpbmcoWyBcImVhc2VJblNpbmVcIiwgZ2VuZXJhdGVCZXppZXIoLjQ3LCAwLCAuNzQ1LCAuNzE1KSBdKTtcbiAgICAgICAgRWFzaW5nLnJlZ2lzdGVyRWFzaW5nKFsgXCJlYXNlT3V0U2luZVwiLCBnZW5lcmF0ZUJlemllciguMzksIC41NzUsIC41NjUsIDEpIF0pO1xuICAgICAgICBFYXNpbmcucmVnaXN0ZXJFYXNpbmcoWyBcImVhc2VJbk91dFNpbmVcIiwgZ2VuZXJhdGVCZXppZXIoLjQ0NSwgLjA1LCAuNTUsIC45NSkgXSk7XG4gICAgICAgIEVhc2luZy5yZWdpc3RlckVhc2luZyhbIFwiZWFzZUluUXVhZFwiLCBnZW5lcmF0ZUJlemllciguNTUsIC4wODUsIC42OCwgLjUzKSBdKTtcbiAgICAgICAgRWFzaW5nLnJlZ2lzdGVyRWFzaW5nKFsgXCJlYXNlT3V0UXVhZFwiLCBnZW5lcmF0ZUJlemllciguMjUsIC40NiwgLjQ1LCAuOTQpIF0pO1xuICAgICAgICBFYXNpbmcucmVnaXN0ZXJFYXNpbmcoWyBcImVhc2VJbk91dFF1YWRcIiwgZ2VuZXJhdGVCZXppZXIoLjQ1NSwgLjAzLCAuNTE1LCAuOTU1KSBdKTtcbiAgICAgICAgRWFzaW5nLnJlZ2lzdGVyRWFzaW5nKFsgXCJlYXNlSW5DdWJpY1wiLCBnZW5lcmF0ZUJlemllciguNTUsIC4wNTUsIC42NzUsIC4xOSkgXSk7XG4gICAgICAgIEVhc2luZy5yZWdpc3RlckVhc2luZyhbIFwiZWFzZU91dEN1YmljXCIsIGdlbmVyYXRlQmV6aWVyKC4yMTUsIC42MSwgLjM1NSwgMSkgXSk7XG4gICAgICAgIEVhc2luZy5yZWdpc3RlckVhc2luZyhbIFwiZWFzZUluT3V0Q3ViaWNcIiwgZ2VuZXJhdGVCZXppZXIoLjY0NSwgLjA0NSwgLjM1NSwgMSkgXSk7XG4gICAgICAgIEVhc2luZy5yZWdpc3RlckVhc2luZyhbIFwiZWFzZUluUXVhcnRcIiwgZ2VuZXJhdGVCZXppZXIoLjg5NSwgLjAzLCAuNjg1LCAuMjIpIF0pO1xuICAgICAgICBFYXNpbmcucmVnaXN0ZXJFYXNpbmcoWyBcImVhc2VPdXRRdWFydFwiLCBnZW5lcmF0ZUJlemllciguMTY1LCAuODQsIC40NCwgMSkgXSk7XG4gICAgICAgIEVhc2luZy5yZWdpc3RlckVhc2luZyhbIFwiZWFzZUluT3V0UXVhcnRcIiwgZ2VuZXJhdGVCZXppZXIoLjc3LCAwLCAuMTc1LCAxKSBdKTtcbiAgICAgICAgRWFzaW5nLnJlZ2lzdGVyRWFzaW5nKFsgXCJlYXNlSW5RdWludFwiLCBnZW5lcmF0ZUJlemllciguNzU1LCAuMDUsIC44NTUsIC4wNikgXSk7XG4gICAgICAgIEVhc2luZy5yZWdpc3RlckVhc2luZyhbIFwiZWFzZU91dFF1aW50XCIsIGdlbmVyYXRlQmV6aWVyKC4yMywgMSwgLjMyLCAxKSBdKTtcbiAgICAgICAgRWFzaW5nLnJlZ2lzdGVyRWFzaW5nKFsgXCJlYXNlSW5PdXRRdWludFwiLCBnZW5lcmF0ZUJlemllciguODYsIDAsIC4wNywgMSkgXSk7XG4gICAgICAgIEVhc2luZy5yZWdpc3RlckVhc2luZyhbIFwiZWFzZUluRXhwb1wiLCBnZW5lcmF0ZUJlemllciguOTUsIC4wNSwgLjc5NSwgLjAzNSkgXSk7XG4gICAgICAgIEVhc2luZy5yZWdpc3RlckVhc2luZyhbIFwiZWFzZU91dEV4cG9cIiwgZ2VuZXJhdGVCZXppZXIoLjE5LCAxLCAuMjIsIDEpIF0pO1xuICAgICAgICBFYXNpbmcucmVnaXN0ZXJFYXNpbmcoWyBcImVhc2VJbk91dEV4cG9cIiwgZ2VuZXJhdGVCZXppZXIoMSwgMCwgMCwgMSkgXSk7XG4gICAgICAgIEVhc2luZy5yZWdpc3RlckVhc2luZyhbIFwiZWFzZUluQ2lyY1wiLCBnZW5lcmF0ZUJlemllciguNiwgLjA0LCAuOTgsIC4zMzUpIF0pO1xuICAgICAgICBFYXNpbmcucmVnaXN0ZXJFYXNpbmcoWyBcImVhc2VPdXRDaXJjXCIsIGdlbmVyYXRlQmV6aWVyKC4wNzUsIC44MiwgLjE2NSwgMSkgXSk7XG4gICAgICAgIEVhc2luZy5yZWdpc3RlckVhc2luZyhbIFwiZWFzZUluT3V0Q2lyY1wiLCBnZW5lcmF0ZUJlemllciguNzg1LCAuMTM1LCAuMTUsIC44NikgXSk7XG4gICAgfSkoRWFzaW5nID0gVmVsb2NpdHlTdGF0aWMuRWFzaW5nIHx8IChWZWxvY2l0eVN0YXRpYy5FYXNpbmcgPSB7fSkpO1xufSkoVmVsb2NpdHlTdGF0aWMgfHwgKFZlbG9jaXR5U3RhdGljID0ge30pKTtcblxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiZWFzaW5ncy50c1wiIC8+XG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqXG4gKiBCb3VuY2UgZWFzaW5ncywgYmFzZWQgb24gY29kZSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS95dWljaGlyb2hhcmFpL2Vhc2VwbHVzLXZlbG9jaXR5XG4gKi9cbnZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgdmFyIEVhc2luZztcbiAgICAoZnVuY3Rpb24oRWFzaW5nKSB7XG4gICAgICAgIGZ1bmN0aW9uIGVhc2VPdXRCb3VuY2UocGVyY2VudENvbXBsZXRlKSB7XG4gICAgICAgICAgICBpZiAocGVyY2VudENvbXBsZXRlIDwgMSAvIDIuNzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogcGVyY2VudENvbXBsZXRlICogcGVyY2VudENvbXBsZXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBlcmNlbnRDb21wbGV0ZSA8IDIgLyAyLjc1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChwZXJjZW50Q29tcGxldGUgLT0gMS41IC8gMi43NSkgKiBwZXJjZW50Q29tcGxldGUgKyAuNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGVyY2VudENvbXBsZXRlIDwgMi41IC8gMi43NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAocGVyY2VudENvbXBsZXRlIC09IDIuMjUgLyAyLjc1KSAqIHBlcmNlbnRDb21wbGV0ZSArIC45Mzc1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChwZXJjZW50Q29tcGxldGUgLT0gMi42MjUgLyAyLjc1KSAqIHBlcmNlbnRDb21wbGV0ZSArIC45ODQzNzU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZWFzZUluQm91bmNlKHBlcmNlbnRDb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBlYXNlT3V0Qm91bmNlKDEgLSBwZXJjZW50Q29tcGxldGUpO1xuICAgICAgICB9XG4gICAgICAgIEVhc2luZy5yZWdpc3RlckVhc2luZyhbIFwiZWFzZUluQm91bmNlXCIsIGZ1bmN0aW9uKHBlcmNlbnRDb21wbGV0ZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwZXJjZW50Q29tcGxldGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwZXJjZW50Q29tcGxldGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWFzZUluQm91bmNlKHBlcmNlbnRDb21wbGV0ZSkgKiAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcbiAgICAgICAgfSBdKTtcbiAgICAgICAgRWFzaW5nLnJlZ2lzdGVyRWFzaW5nKFsgXCJlYXNlT3V0Qm91bmNlXCIsIGZ1bmN0aW9uKHBlcmNlbnRDb21wbGV0ZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwZXJjZW50Q29tcGxldGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwZXJjZW50Q29tcGxldGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWFzZU91dEJvdW5jZShwZXJjZW50Q29tcGxldGUpICogKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgIH0gXSk7XG4gICAgICAgIEVhc2luZy5yZWdpc3RlckVhc2luZyhbIFwiZWFzZUluT3V0Qm91bmNlXCIsIGZ1bmN0aW9uKHBlcmNlbnRDb21wbGV0ZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwZXJjZW50Q29tcGxldGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwZXJjZW50Q29tcGxldGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKHBlcmNlbnRDb21wbGV0ZSA8IC41ID8gZWFzZUluQm91bmNlKHBlcmNlbnRDb21wbGV0ZSAqIDIpICogLjUgOiBlYXNlT3V0Qm91bmNlKHBlcmNlbnRDb21wbGV0ZSAqIDIgLSAxKSAqIC41ICsgLjUpICogKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgIH0gXSk7XG4gICAgfSkoRWFzaW5nID0gVmVsb2NpdHlTdGF0aWMuRWFzaW5nIHx8IChWZWxvY2l0eVN0YXRpYy5FYXNpbmcgPSB7fSkpO1xufSkoVmVsb2NpdHlTdGF0aWMgfHwgKFZlbG9jaXR5U3RhdGljID0ge30pKTtcblxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiZWFzaW5ncy50c1wiIC8+XG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqXG4gKiBFbGFzdGljIGVhc2luZ3MsIGJhc2VkIG9uIGNvZGUgZnJvbSBodHRwczovL2dpdGh1Yi5jb20veXVpY2hpcm9oYXJhaS9lYXNlcGx1cy12ZWxvY2l0eVxuICovXG52YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIHZhciBFYXNpbmc7XG4gICAgKGZ1bmN0aW9uKEVhc2luZykge1xuICAgICAgICB2YXIgcGkyID0gTWF0aC5QSSAqIDI7XG4gICAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRWxhc3RpY0luKG5hbWUsIGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gICAgICAgICAgICBFYXNpbmcucmVnaXN0ZXJFYXNpbmcoWyBuYW1lLCBmdW5jdGlvbihwZXJjZW50Q29tcGxldGUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnRDb21wbGV0ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnRDb21wbGV0ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5kVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAtKGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIDEwICogKHBlcmNlbnRDb21wbGV0ZSAtPSAxKSkgKiBNYXRoLnNpbigocGVyY2VudENvbXBsZXRlIC0gcGVyaW9kIC8gcGkyICogTWF0aC5hc2luKDEgLyBhbXBsaXR1ZGUpKSAqIHBpMiAvIHBlcmlvZCkpICogKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICB9IF0pO1xuICAgICAgICB9XG4gICAgICAgIEVhc2luZy5yZWdpc3RlckVsYXN0aWNJbiA9IHJlZ2lzdGVyRWxhc3RpY0luO1xuICAgICAgICBmdW5jdGlvbiByZWdpc3RlckVsYXN0aWNPdXQobmFtZSwgYW1wbGl0dWRlLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIEVhc2luZy5yZWdpc3RlckVhc2luZyhbIG5hbWUsIGZ1bmN0aW9uKHBlcmNlbnRDb21wbGV0ZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudENvbXBsZXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudENvbXBsZXRlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhbXBsaXR1ZGUgKiBNYXRoLnBvdygyLCAtMTAgKiBwZXJjZW50Q29tcGxldGUpICogTWF0aC5zaW4oKHBlcmNlbnRDb21wbGV0ZSAtIHBlcmlvZCAvIHBpMiAqIE1hdGguYXNpbigxIC8gYW1wbGl0dWRlKSkgKiBwaTIgLyBwZXJpb2QpICsgMSkgKiAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcbiAgICAgICAgICAgIH0gXSk7XG4gICAgICAgIH1cbiAgICAgICAgRWFzaW5nLnJlZ2lzdGVyRWxhc3RpY091dCA9IHJlZ2lzdGVyRWxhc3RpY091dDtcbiAgICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJFbGFzdGljSW5PdXQobmFtZSwgYW1wbGl0dWRlLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIEVhc2luZy5yZWdpc3RlckVhc2luZyhbIG5hbWUsIGZ1bmN0aW9uKHBlcmNlbnRDb21wbGV0ZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudENvbXBsZXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudENvbXBsZXRlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBwZXJpb2QgLyBwaTIgKiBNYXRoLmFzaW4oMSAvIGFtcGxpdHVkZSk7XG4gICAgICAgICAgICAgICAgcGVyY2VudENvbXBsZXRlID0gcGVyY2VudENvbXBsZXRlICogMiAtIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwZXJjZW50Q29tcGxldGUgPCAwID8gLS41ICogKGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIDEwICogcGVyY2VudENvbXBsZXRlKSAqIE1hdGguc2luKChwZXJjZW50Q29tcGxldGUgLSBzKSAqIHBpMiAvIHBlcmlvZCkpIDogYW1wbGl0dWRlICogTWF0aC5wb3coMiwgLTEwICogcGVyY2VudENvbXBsZXRlKSAqIE1hdGguc2luKChwZXJjZW50Q29tcGxldGUgLSBzKSAqIHBpMiAvIHBlcmlvZCkgKiAuNSArIDEpICogKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICB9IF0pO1xuICAgICAgICB9XG4gICAgICAgIEVhc2luZy5yZWdpc3RlckVsYXN0aWNJbk91dCA9IHJlZ2lzdGVyRWxhc3RpY0luT3V0O1xuICAgICAgICByZWdpc3RlckVsYXN0aWNJbihcImVhc2VJbkVsYXN0aWNcIiwgMSwgLjMpO1xuICAgICAgICByZWdpc3RlckVsYXN0aWNPdXQoXCJlYXNlT3V0RWxhc3RpY1wiLCAxLCAuMyk7XG4gICAgICAgIHJlZ2lzdGVyRWxhc3RpY0luT3V0KFwiZWFzZUluT3V0RWxhc3RpY1wiLCAxLCAuMyAqIDEuNSk7XG4gICAgICAgIC8vIFRPRE86IEV4cG9zZSB0aGVzZSBhcyBhY3Rpb25zIHRvIHJlZ2lzdGVyIGN1c3RvbSBlYXNpbmdzP1xuICAgICAgICB9KShFYXNpbmcgPSBWZWxvY2l0eVN0YXRpYy5FYXNpbmcgfHwgKFZlbG9jaXR5U3RhdGljLkVhc2luZyA9IHt9KSk7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJlYXNpbmdzLnRzXCIgLz5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICovXG52YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIHZhciBFYXNpbmc7XG4gICAgKGZ1bmN0aW9uKEVhc2luZykge1xuICAgICAgICAvKiBSdW5nZS1LdXR0YSBzcHJpbmcgcGh5c2ljcyBmdW5jdGlvbiBnZW5lcmF0b3IuIEFkYXB0ZWQgZnJvbSBGcmFtZXIuanMsIGNvcHlyaWdodCBLb2VuIEJvay4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cbiAgICAgICAgLyogR2l2ZW4gYSB0ZW5zaW9uLCBmcmljdGlvbiwgYW5kIGR1cmF0aW9uLCBhIHNpbXVsYXRpb24gYXQgNjBGUFMgd2lsbCBmaXJzdCBydW4gd2l0aG91dCBhIGRlZmluZWQgZHVyYXRpb24gaW4gb3JkZXIgdG8gY2FsY3VsYXRlIHRoZSBmdWxsIHBhdGguIEEgc2Vjb25kIHBhc3NcbiAgICAgICAgIHRoZW4gYWRqdXN0cyB0aGUgdGltZSBkZWx0YSAtLSB1c2luZyB0aGUgcmVsYXRpb24gYmV0d2VlbiBhY3R1YWwgdGltZSBhbmQgZHVyYXRpb24gLS0gdG8gY2FsY3VsYXRlIHRoZSBwYXRoIGZvciB0aGUgZHVyYXRpb24tY29uc3RyYWluZWQgYW5pbWF0aW9uLiAqL1xuICAgICAgICBmdW5jdGlvbiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIC1zdGF0ZS50ZW5zaW9uICogc3RhdGUueCAtIHN0YXRlLmZyaWN0aW9uICogc3RhdGUudjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoaW5pdGlhbFN0YXRlLCBkdCwgZGVyaXZhdGl2ZSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgIHg6IGluaXRpYWxTdGF0ZS54ICsgZGVyaXZhdGl2ZS5keCAqIGR0LFxuICAgICAgICAgICAgICAgIHY6IGluaXRpYWxTdGF0ZS52ICsgZGVyaXZhdGl2ZS5kdiAqIGR0LFxuICAgICAgICAgICAgICAgIHRlbnNpb246IGluaXRpYWxTdGF0ZS50ZW5zaW9uLFxuICAgICAgICAgICAgICAgIGZyaWN0aW9uOiBpbml0aWFsU3RhdGUuZnJpY3Rpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGR4OiBzdGF0ZS52LFxuICAgICAgICAgICAgICAgIGR2OiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3ByaW5nSW50ZWdyYXRlU3RhdGUoc3RhdGUsIGR0KSB7XG4gICAgICAgICAgICB2YXIgYSA9IHtcbiAgICAgICAgICAgICAgICBkeDogc3RhdGUudixcbiAgICAgICAgICAgICAgICBkdjogc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpXG4gICAgICAgICAgICB9LCBiID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCAqIC41LCBhKSwgYyA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQgKiAuNSwgYiksIGQgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0LCBjKSwgZHhkdCA9IDEgLyA2ICogKGEuZHggKyAyICogKGIuZHggKyBjLmR4KSArIGQuZHgpLCBkdmR0ID0gMSAvIDYgKiAoYS5kdiArIDIgKiAoYi5kdiArIGMuZHYpICsgZC5kdik7XG4gICAgICAgICAgICBzdGF0ZS54ID0gc3RhdGUueCArIGR4ZHQgKiBkdDtcbiAgICAgICAgICAgIHN0YXRlLnYgPSBzdGF0ZS52ICsgZHZkdCAqIGR0O1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlU3ByaW5nUks0KHRlbnNpb24sIGZyaWN0aW9uLCBkdXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIGluaXRTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICB4OiAtMSxcbiAgICAgICAgICAgICAgICB2OiAwLFxuICAgICAgICAgICAgICAgIHRlbnNpb246IHBhcnNlRmxvYXQodGVuc2lvbikgfHwgNTAwLFxuICAgICAgICAgICAgICAgIGZyaWN0aW9uOiBwYXJzZUZsb2F0KGZyaWN0aW9uKSB8fCAyMFxuICAgICAgICAgICAgfSwgcGF0aCA9IFsgMCBdLCB0aW1lX2xhcHNlZCA9IDAsIHRvbGVyYW5jZSA9IDEgLyAxZTQsIERUID0gMTYgLyAxZTMsIGhhdmVfZHVyYXRpb24gPSBkdXJhdGlvbiAhPSBudWxsLCAvLyBkZWxpYmVyYXRlIFwiPT1cIiwgYXMgdW5kZWZpbmVkID09IG51bGwgIT0gMFxuICAgICAgICAgICAgZHQsIGxhc3Rfc3RhdGU7XG4gICAgICAgICAgICAvKiBDYWxjdWxhdGUgdGhlIGFjdHVhbCB0aW1lIGl0IHRha2VzIGZvciB0aGlzIGFuaW1hdGlvbiB0byBjb21wbGV0ZSB3aXRoIHRoZSBwcm92aWRlZCBjb25kaXRpb25zLiAqLyAgICAgICAgICAgIGlmIChoYXZlX2R1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLyogUnVuIHRoZSBzaW11bGF0aW9uIHdpdGhvdXQgYSBkdXJhdGlvbi4gKi9cbiAgICAgICAgICAgICAgICB0aW1lX2xhcHNlZCA9IGdlbmVyYXRlU3ByaW5nUks0KGluaXRTdGF0ZS50ZW5zaW9uLCBpbml0U3RhdGUuZnJpY3Rpb24pO1xuICAgICAgICAgICAgICAgIC8qIENvbXB1dGUgdGhlIGFkanVzdGVkIHRpbWUgZGVsdGEuICovICAgICAgICAgICAgICAgIGR0ID0gdGltZV9sYXBzZWQgLyBkdXJhdGlvbiAqIERUO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdCA9IERUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAvKiBOZXh0L3N0ZXAgZnVuY3Rpb24gLiovXG4gICAgICAgICAgICAgICAgbGFzdF9zdGF0ZSA9IHNwcmluZ0ludGVncmF0ZVN0YXRlKGxhc3Rfc3RhdGUgfHwgaW5pdFN0YXRlLCBkdCk7XG4gICAgICAgICAgICAgICAgLyogU3RvcmUgdGhlIHBvc2l0aW9uLiAqLyAgICAgICAgICAgICAgICBwYXRoLnB1c2goMSArIGxhc3Rfc3RhdGUueCk7XG4gICAgICAgICAgICAgICAgdGltZV9sYXBzZWQgKz0gMTY7XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlIGNoYW5nZSB0aHJlc2hvbGQgaXMgcmVhY2hlZCwgYnJlYWsuICovICAgICAgICAgICAgICAgIGlmICghKE1hdGguYWJzKGxhc3Rfc3RhdGUueCkgPiB0b2xlcmFuY2UgJiYgTWF0aC5hYnMobGFzdF9zdGF0ZS52KSA+IHRvbGVyYW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogSWYgZHVyYXRpb24gaXMgbm90IGRlZmluZWQsIHJldHVybiB0aGUgYWN0dWFsIHRpbWUgcmVxdWlyZWQgZm9yIGNvbXBsZXRpbmcgdGhpcyBhbmltYXRpb24uIE90aGVyd2lzZSwgcmV0dXJuIGEgY2xvc3VyZSB0aGF0IGhvbGRzIHRoZVxuICAgICAgICAgICAgIGNvbXB1dGVkIHBhdGggYW5kIHJldHVybnMgYSBzbmFwc2hvdCBvZiB0aGUgcG9zaXRpb24gYWNjb3JkaW5nIHRvIGEgZ2l2ZW4gcGVyY2VudENvbXBsZXRlLiAqLyAgICAgICAgICAgIHJldHVybiAhaGF2ZV9kdXJhdGlvbiA/IHRpbWVfbGFwc2VkIDogZnVuY3Rpb24ocGVyY2VudENvbXBsZXRlLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50Q29tcGxldGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50Q29tcGxldGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRWYWx1ZSArIHBhdGhbcGVyY2VudENvbXBsZXRlICogKHBhdGgubGVuZ3RoIC0gMSkgfCAwXSAqIChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBFYXNpbmcuZ2VuZXJhdGVTcHJpbmdSSzQgPSBnZW5lcmF0ZVNwcmluZ1JLNDtcbiAgICB9KShFYXNpbmcgPSBWZWxvY2l0eVN0YXRpYy5FYXNpbmcgfHwgKFZlbG9jaXR5U3RhdGljLkVhc2luZyA9IHt9KSk7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJlYXNpbmdzLnRzXCIgLz5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzXG4gKlxuICogU3RlcCBlYXNpbmcgZ2VuZXJhdG9yLlxuICovXG52YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIHZhciBFYXNpbmc7XG4gICAgKGZ1bmN0aW9uKEVhc2luZykge1xuICAgICAgICB2YXIgY2FjaGUgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVTdGVwKHN0ZXBzKSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBjYWNoZVtzdGVwc107XG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVbc3RlcHNdID0gZnVuY3Rpb24ocGVyY2VudENvbXBsZXRlLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50Q29tcGxldGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50Q29tcGxldGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRWYWx1ZSArIE1hdGgucm91bmQocGVyY2VudENvbXBsZXRlICogc3RlcHMpICogKDEgLyBzdGVwcykgKiAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgRWFzaW5nLmdlbmVyYXRlU3RlcCA9IGdlbmVyYXRlU3RlcDtcbiAgICB9KShFYXNpbmcgPSBWZWxvY2l0eVN0YXRpYy5FYXNpbmcgfHwgKFZlbG9jaXR5U3RhdGljLkVhc2luZyA9IHt9KSk7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJlYXNpbmdzLnRzXCIgLz5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICpcbiAqIEVhc2luZ3MgdG8gYWN0IG9uIHN0cmluZ3MsIGVpdGhlciBzZXQgYXQgdGhlIHN0YXJ0IG9yIGF0IHRoZSBlbmQgZGVwZW5kaW5nIG9uXG4gKiBuZWVkLlxuICovXG52YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIHZhciBFYXNpbmc7XG4gICAgKGZ1bmN0aW9uKEVhc2luZykge1xuICAgICAgICAvKipcbiAgICAgICAgICogRWFzaW5nIGZ1bmN0aW9uIHRoYXQgc2V0cyB0byB0aGUgc3BlY2lmaWVkIHZhbHVlIGltbWVkaWF0ZWx5IGFmdGVyIHRoZVxuICAgICAgICAgKiBhbmltYXRpb24gc3RhcnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgRWFzaW5nLnJlZ2lzdGVyRWFzaW5nKFsgXCJhdC1zdGFydFwiLCBmdW5jdGlvbihwZXJjZW50Q29tcGxldGUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGVyY2VudENvbXBsZXRlID09PSAwID8gc3RhcnRWYWx1ZSA6IGVuZFZhbHVlO1xuICAgICAgICB9IF0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogRWFzaW5nIGZ1bmN0aW9uIHRoYXQgc2V0cyB0byB0aGUgc3BlY2lmaWVkIHZhbHVlIHdoaWxlIHRoZSBhbmltYXRpb24gaXNcbiAgICAgICAgICogcnVubmluZy5cbiAgICAgICAgICovICAgICAgICBFYXNpbmcucmVnaXN0ZXJFYXNpbmcoWyBcImR1cmluZ1wiLCBmdW5jdGlvbihwZXJjZW50Q29tcGxldGUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGVyY2VudENvbXBsZXRlID09PSAwIHx8IHBlcmNlbnRDb21wbGV0ZSA9PT0gMSA/IHN0YXJ0VmFsdWUgOiBlbmRWYWx1ZTtcbiAgICAgICAgfSBdKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVhc2luZyBmdW5jdGlvbiB0aGF0IHNldHMgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZSB3aGVuIHRoZSBhbmltYXRpb24gZW5kcy5cbiAgICAgICAgICovICAgICAgICBFYXNpbmcucmVnaXN0ZXJFYXNpbmcoWyBcImF0LWVuZFwiLCBmdW5jdGlvbihwZXJjZW50Q29tcGxldGUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGVyY2VudENvbXBsZXRlID09PSAxID8gZW5kVmFsdWUgOiBzdGFydFZhbHVlO1xuICAgICAgICB9IF0pO1xuICAgIH0pKEVhc2luZyA9IFZlbG9jaXR5U3RhdGljLkVhc2luZyB8fCAoVmVsb2NpdHlTdGF0aWMuRWFzaW5nID0ge30pKTtcbn0pKFZlbG9jaXR5U3RhdGljIHx8IChWZWxvY2l0eVN0YXRpYyA9IHt9KSk7XG5cbi8vLzxyZWZlcmVuY2UgcGF0aD1cIi4uL2FjdGlvbnMvX2FsbC5kLnRzXCIgLz5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICpcbiAqIE5vcm1hbGlzYXRpb25zIGFyZSB1c2VkIHdoZW4gZ2V0dGluZyBvciBzZXR0aW5nIGEgKG5vcm1hbGx5IGNzcyBjb21wb3VuZFxuICogcHJvcGVydGllcykgdmFsdWUgdGhhdCBjYW4gaGF2ZSBhIGRpZmZlcmVudCBvcmRlciBpbiBkaWZmZXJlbnQgYnJvd3NlcnMuXG4gKlxuICogSXQgY2FuIGFsc28gYmUgdXNlZCB0byBleHRlbmQgYW5kIGNyZWF0ZSBzcGVjaWZpYyBwcm9wZXJ0aWVzIHRoYXQgb3RoZXJ3aXNlXG4gKiBkb24ndCBleGlzdCAoc3VjaCBhcyBmb3Igc2Nyb2xsaW5nLCBvciBpbm5lci9vdXRlciBkaW1lbnNpb25zKS5cbiAqL1xudmFyIFZlbG9jaXR5U3RhdGljO1xuXG4oZnVuY3Rpb24oVmVsb2NpdHlTdGF0aWMpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaGlnaGVzdCB0eXBlIGluZGV4IGZvciBmaW5kaW5nIHRoZSBiZXN0IG5vcm1hbGl6YXRpb24gZm9yIGEgcHJvcGVydHkuXG4gICAgICovXG4gICAgVmVsb2NpdHlTdGF0aWMuTWF4VHlwZSA9IC0xO1xuICAgIC8qKlxuICAgICAqIFVubGlrZSBcImFjdGlvbnNcIiwgbm9ybWFsaXphdGlvbnMgY2FuIGFsd2F5cyBiZSByZXBsYWNlZCBieSB1c2Vycy5cbiAgICAgKi8gICAgVmVsb2NpdHlTdGF0aWMuTm9ybWFsaXphdGlvbnMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBTdG9yZSBhIGNyb3NzLXJlZmVyZW5jZSB0byB1bml0cyB0byBiZSBhZGRlZCB0byBzcGVjaWZpYyBub3JtYWxpemF0aW9uXG4gICAgICogZnVuY3Rpb25zIGlmIHRoZSB1c2VyIHN1cHBsaWVzIGEgdW5pdC1sZXNzIG51bWJlci5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgcHJldHR5IG11Y2ggY29uZmluZWQgdG8gYWRkaW5nIFwicHhcIiB0byBzZXZlcmFsIGNzcyBwcm9wZXJ0aWVzLlxuICAgICAqLyAgICBWZWxvY2l0eVN0YXRpYy5Ob3JtYWxpemF0aW9uVW5pdHMgPSBjcmVhdGVFbXB0eU9iamVjdCgpO1xuICAgIC8qKlxuICAgICAqIEFueSBub3JtYWxpc2F0aW9ucyB0aGF0IHNob3VsZCBuZXZlciBiZSBjYWNoZWQgYXJlIGxpc3RlZCBoZXJlLlxuICAgICAqIEZhc3RlciB0aGFuIGFuIGFycmF5IC0gaHR0cHM6Ly9qc3BlcmYuY29tL2FycmF5LWluY2x1ZGVzLWFuZC1maW5kLW1ldGhvZHMtdnMtc2V0LWhhc1xuICAgICAqLyAgICBWZWxvY2l0eVN0YXRpYy5Ob0NhY2hlTm9ybWFsaXphdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgY2xhc3NlcyB1c2VkIGZvciB0aGUgcGVyLWNsYXNzIG5vcm1hbGl6YXRpb25zLiBUaGlzXG4gICAgICogdHJhbnNsYXRlcyBpbnRvIGEgYml0d2lzZSBlbnVtIGZvciBxdWljayBjcm9zcy1yZWZlcmVuY2UsIGFuZCBzbyB0aGF0XG4gICAgICogdGhlIGVsZW1lbnQgZG9lc24ndCBuZWVkIG11bHRpcGxlIDxjb2RlPmluc3RhbmNlb2Y8L2NvZGU+IGNhbGxzIGV2ZXJ5XG4gICAgICogZnJhbWUuXG4gICAgICovICAgIFZlbG9jaXR5U3RhdGljLmNvbnN0cnVjdG9ycyA9IFtdO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVnaXN0ZXIgYSBub3JtYWxpemF0aW9uLiBUaGlzIHNob3VsZCBuZXZlciBiZSBjYWxsZWQgYnkgdXNlcnNcbiAgICAgKiBkaXJlY3RseSwgaW5zdGVhZCBpdCBzaG91bGQgYmUgY2FsbGVkIHZpYSBhbiBhY3Rpb246PGJyLz5cbiAgICAgKiA8Y29kZT5WZWxvY2l0eShcInJlZ2lzdGVyTm9ybWFsaXphdGlvblwiLCBFbGVtZW50LCBcIm5hbWVcIiwgVmVsb2NpdHlOb3JtYWxpemF0aW9uc0ZuWywgZmFsc2VdKTs8L2NvZGU+XG4gICAgICpcbiAgICAgKiBUaGUgZm91cnRoIGFyZ3VtZW50IGNhbiBiZSBhbiBleHBsaWNpdCA8Y29kZT5mYWxzZTwvY29kZT4sIHdoaWNoIHByZXZlbnRzXG4gICAgICogdGhlIHByb3BlcnR5IGZyb20gYmVpbmcgY2FjaGVkLiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgY2FuIGJlIGRhbmdlcm91c1xuICAgICAqIGZvciBwZXJmb3JtYW5jZSFcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovICAgIGZ1bmN0aW9uIHJlZ2lzdGVyTm9ybWFsaXphdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGFyZ3NbMF0sIG5hbWUgPSBhcmdzWzFdLCBjYWxsYmFjayA9IGFyZ3NbMl07XG4gICAgICAgIGlmIChpc1N0cmluZyhjb25zdHJ1Y3RvcikgfHwgIShjb25zdHJ1Y3RvciBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlZlbG9jaXR5SlM6IFRyeWluZyB0byBzZXQgJ3JlZ2lzdGVyTm9ybWFsaXphdGlvbicgY29uc3RydWN0b3IgdG8gYW4gaW52YWxpZCB2YWx1ZTpcIiwgY29uc3RydWN0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmluZyhuYW1lKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVmVsb2NpdHlKUzogVHJ5aW5nIHRvIHNldCAncmVnaXN0ZXJOb3JtYWxpemF0aW9uJyBuYW1lIHRvIGFuIGludmFsaWQgdmFsdWU6XCIsIG5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVmVsb2NpdHlKUzogVHJ5aW5nIHRvIHNldCAncmVnaXN0ZXJOb3JtYWxpemF0aW9uJyBjYWxsYmFjayB0byBhbiBpbnZhbGlkIHZhbHVlOlwiLCBuYW1lLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBWZWxvY2l0eVN0YXRpYy5jb25zdHJ1Y3RvcnMuaW5kZXhPZihjb25zdHJ1Y3RvciksIG5leHRBcmcgPSAzO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLk1heFR5cGUgPSBpbmRleCA9IFZlbG9jaXR5U3RhdGljLmNvbnN0cnVjdG9ycy5wdXNoKGNvbnN0cnVjdG9yKSAtIDE7XG4gICAgICAgICAgICAgICAgVmVsb2NpdHlTdGF0aWMuTm9ybWFsaXphdGlvbnNbaW5kZXhdID0gY3JlYXRlRW1wdHlPYmplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLk5vcm1hbGl6YXRpb25zW2luZGV4XVtuYW1lXSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGFyZ3NbbmV4dEFyZ10pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVuaXQgPSBhcmdzW25leHRBcmcrK10sIHVuaXRzID0gVmVsb2NpdHlTdGF0aWMuTm9ybWFsaXphdGlvblVuaXRzW3VuaXRdO1xuICAgICAgICAgICAgICAgIGlmICghdW5pdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdHMgPSBWZWxvY2l0eVN0YXRpYy5Ob3JtYWxpemF0aW9uVW5pdHNbdW5pdF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5pdHMucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJnc1tuZXh0QXJnXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBWZWxvY2l0eVN0YXRpYy5Ob0NhY2hlTm9ybWFsaXphdGlvbnMuYWRkKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFZlbG9jaXR5U3RhdGljLnJlZ2lzdGVyTm9ybWFsaXphdGlvbiA9IHJlZ2lzdGVyTm9ybWFsaXphdGlvbjtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGEgbm9ybWFsaXNhdGlvbiBleGlzdHMgb24gYSBzcGVjaWZpYyBjbGFzcy5cbiAgICAgKi8gICAgZnVuY3Rpb24gaGFzTm9ybWFsaXphdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGFyZ3NbMF0sIG5hbWUgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgaW5kZXggPSBWZWxvY2l0eVN0YXRpYy5jb25zdHJ1Y3RvcnMuaW5kZXhPZihjb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiAhIVZlbG9jaXR5U3RhdGljLk5vcm1hbGl6YXRpb25zW2luZGV4XVtuYW1lXTtcbiAgICB9XG4gICAgVmVsb2NpdHlTdGF0aWMuaGFzTm9ybWFsaXphdGlvbiA9IGhhc05vcm1hbGl6YXRpb247XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1bml0IHRvIGFkZCB0byBhIHVuaXRsZXNzIG51bWJlciBiYXNlZCBvbiB0aGUgbm9ybWFsaXphdGlvbiB1c2VkLlxuICAgICAqLyAgICBmdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVW5pdChmbikge1xuICAgICAgICBmb3IgKHZhciB1bml0IGluIFZlbG9jaXR5U3RhdGljLk5vcm1hbGl6YXRpb25Vbml0cykge1xuICAgICAgICAgICAgaWYgKF9pbkFycmF5KFZlbG9jaXR5U3RhdGljLk5vcm1hbGl6YXRpb25Vbml0c1t1bml0XSwgZm4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIFZlbG9jaXR5U3RhdGljLmdldE5vcm1hbGl6YXRpb25Vbml0ID0gZ2V0Tm9ybWFsaXphdGlvblVuaXQ7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBub3JtYWxpemF0aW9uIGZvciBhbiBlbGVtZW50IGFuZCBwcm9wZXJ0eU5hbWUgY29tYmluYXRpb24uIFRoaXNcbiAgICAgKiB2YWx1ZSBzaG91bGQgYmUgY2FjaGVkIGF0IGFza2luZyB0aW1lLCBhcyBpdCBtYXkgY2hhbmdlIGlmIHRoZSB1c2VyIGFkZHNcbiAgICAgKiBtb3JlIG5vcm1hbGl6YXRpb25zLlxuICAgICAqLyAgICBmdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uKGVsZW1lbnQsIHByb3BlcnR5TmFtZSkge1xuICAgICAgICB2YXIgZGF0YSA9IERhdGEoZWxlbWVudCk7XG4gICAgICAgIHZhciBmbjtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSBWZWxvY2l0eVN0YXRpYy5NYXhUeXBlLCB0eXBlcyA9IGRhdGEudHlwZXM7ICFmbiAmJiBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAodHlwZXMgJiAxIDw8IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgZm4gPSBWZWxvY2l0eVN0YXRpYy5Ob3JtYWxpemF0aW9uc1tpbmRleF1bcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuICAgIFZlbG9jaXR5U3RhdGljLmdldE5vcm1hbGl6YXRpb24gPSBnZXROb3JtYWxpemF0aW9uO1xuICAgIFZlbG9jaXR5U3RhdGljLnJlZ2lzdGVyQWN0aW9uKFsgXCJyZWdpc3Rlck5vcm1hbGl6YXRpb25cIiwgcmVnaXN0ZXJOb3JtYWxpemF0aW9uIF0pO1xuICAgIFZlbG9jaXR5U3RhdGljLnJlZ2lzdGVyQWN0aW9uKFsgXCJoYXNOb3JtYWxpemF0aW9uXCIsIGhhc05vcm1hbGl6YXRpb24gXSk7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vLy88cmVmZXJlbmNlIHBhdGg9XCIuLi9ub3JtYWxpemF0aW9ucy50c1wiIC8+XG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqLyB2YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIHZhciBDU1M7XG4gICAgKGZ1bmN0aW9uKENTUykge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0L3NldCBhbiBhdHRyaWJ1dGUuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgcnhTdWJ0eXBlID0gL15TVkcoLiopRWxlbWVudCQvLCByeEVsZW1lbnQgPSAvRWxlbWVudCQvO1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpLmZvckVhY2goZnVuY3Rpb24oZ2xvYmFscykge1xuICAgICAgICAgICAgdmFyIHN1YnR5cGUgPSByeFN1YnR5cGUuZXhlYyhnbG9iYWxzKTtcbiAgICAgICAgICAgIGlmIChzdWJ0eXBlICYmIHN1YnR5cGVbMV0gIT09IFwiU1ZHXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHN1YnR5cGVbMV0gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCAoc3VidHlwZVsxXSB8fCBcInN2Z1wiKS50b0xvd2VyQ2FzZSgpKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiksIGNvbnN0cnVjdG9yID0gZWxlbWVudC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYXR0cmlidXRlIGluIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVsZW1lbnRbYXR0cmlidXRlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhhdHRyaWJ1dGUpICYmICEoYXR0cmlidXRlWzBdID09PSBcIm9cIiAmJiBhdHRyaWJ1dGVbMV0gPT09IFwiblwiKSAmJiBhdHRyaWJ1dGUgIT09IGF0dHJpYnV0ZS50b1VwcGVyQ2FzZSgpICYmICFyeEVsZW1lbnQudGVzdChhdHRyaWJ1dGUpICYmICEoYXR0cmlidXRlIGluIGJhc2UpICYmICFpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGFsbCBiZSBzZXQgb24gdGhlIGdlbmVyaWMgU1ZHRWxlbWVudCwgaXQgd291bGQgc2F2ZSBzcGFjZSBhbmQgdGltZSwgYnV0IG5vdCBhcyBwb3dlcmZ1bFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLnJlZ2lzdGVyTm9ybWFsaXphdGlvbihbIGNvbnN0cnVjdG9yLCBhdHRyaWJ1dGUsIGdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVmVsb2NpdHlKUzogRXJyb3Igd2hlbiB0cnlpbmcgdG8gaWRlbnRpZnkgU1ZHIGF0dHJpYnV0ZXMgb24gXCIgKyBnbG9iYWxzICsgXCIuXCIsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSkoQ1NTID0gVmVsb2NpdHlTdGF0aWMuQ1NTIHx8IChWZWxvY2l0eVN0YXRpYy5DU1MgPSB7fSkpO1xufSkoVmVsb2NpdHlTdGF0aWMgfHwgKFZlbG9jaXR5U3RhdGljID0ge30pKTtcblxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi4vbm9ybWFsaXphdGlvbnMudHNcIiAvPlxuLypcbiAqIFZlbG9jaXR5SlMub3JnIChDKSAyMDE0LTIwMTcgSnVsaWFuIFNoYXBpcm8uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGRldGFpbHMuXG4gKi8gdmFyIFZlbG9jaXR5U3RhdGljO1xuXG4oZnVuY3Rpb24oVmVsb2NpdHlTdGF0aWMpIHtcbiAgICB2YXIgQ1NTO1xuICAgIChmdW5jdGlvbihDU1MpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldC9zZXQgdGhlIHdpZHRoIG9yIGhlaWdodC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldERpbWVuc2lvbihuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCB0aHJvd3MgYW4gZXJyb3IgaWYgLmdldEJCb3goKSBpcyBjYWxsZWQgb24gYW4gU1ZHIHRoYXQgaXNuJ3QgYXR0YWNoZWQgdG8gdGhlIERPTS5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEJCb3goKVtuYW1lXSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiMHB4XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIFZlbG9jaXR5U3RhdGljLnJlZ2lzdGVyTm9ybWFsaXphdGlvbihbIFNWR0VsZW1lbnQsIFwid2lkdGhcIiwgZ2V0RGltZW5zaW9uKFwid2lkdGhcIikgXSk7XG4gICAgICAgIFZlbG9jaXR5U3RhdGljLnJlZ2lzdGVyTm9ybWFsaXphdGlvbihbIFNWR0VsZW1lbnQsIFwiaGVpZ2h0XCIsIGdldERpbWVuc2lvbihcImhlaWdodFwiKSBdKTtcbiAgICB9KShDU1MgPSBWZWxvY2l0eVN0YXRpYy5DU1MgfHwgKFZlbG9jaXR5U3RhdGljLkNTUyA9IHt9KSk7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJub3JtYWxpemF0aW9ucy50c1wiIC8+XG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqLyB2YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIC8qKlxuICAgICAqIEZpZ3VyZSBvdXQgdGhlIGRpbWVuc2lvbnMgZm9yIHRoaXMgd2lkdGggLyBoZWlnaHQgYmFzZWQgb24gdGhlXG4gICAgICogcG90ZW50aWFsIGJvcmRlcnMgYW5kIHdoZXRoZXIgd2UgY2FyZSBhYm91dCB0aGVtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1Z21lbnREaW1lbnNpb24oZWxlbWVudCwgbmFtZSwgd2FudElubmVyKSB7XG4gICAgICAgIHZhciBpc0JvcmRlckJveCA9IFZlbG9jaXR5U3RhdGljLkNTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiYm94U2l6aW5nXCIpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gXCJib3JkZXItYm94XCI7XG4gICAgICAgIGlmIChpc0JvcmRlckJveCA9PT0gd2FudElubmVyKSB7XG4gICAgICAgICAgICAvLyBpbiBib3gtc2l6aW5nIG1vZGUsIHRoZSBDU1Mgd2lkdGggLyBoZWlnaHQgYWNjZXNzb3JzIGFscmVhZHlcbiAgICAgICAgICAgIC8vIGdpdmUgdGhlIG91dGVyV2lkdGggLyBvdXRlckhlaWdodC5cbiAgICAgICAgICAgIHZhciBzaWRlcyA9IG5hbWUgPT09IFwid2lkdGhcIiA/IFsgXCJMZWZ0XCIsIFwiUmlnaHRcIiBdIDogWyBcIlRvcFwiLCBcIkJvdHRvbVwiIF0sIGZpZWxkcyA9IFsgXCJwYWRkaW5nXCIgKyBzaWRlc1swXSwgXCJwYWRkaW5nXCIgKyBzaWRlc1sxXSwgXCJib3JkZXJcIiArIHNpZGVzWzBdICsgXCJXaWR0aFwiLCBcImJvcmRlclwiICsgc2lkZXNbMV0gKyBcIldpZHRoXCIgXTtcbiAgICAgICAgICAgIHZhciBpID0gdm9pZCAwLCB2YWx1ZSA9IHZvaWQgMCwgYXVnbWVudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KFZlbG9jaXR5U3RhdGljLkNTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIGZpZWxkc1tpXSkpO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF1Z21lbnQgKz0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdhbnRJbm5lciA/IC1hdWdtZW50IDogYXVnbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgVmVsb2NpdHlTdGF0aWMuYXVnbWVudERpbWVuc2lvbiA9IGF1Z21lbnREaW1lbnNpb247XG4gICAgLyoqXG4gICAgICogR2V0L3NldCB0aGUgaW5uZXIvb3V0ZXIgZGltZW5zaW9uLlxuICAgICAqLyAgICBmdW5jdGlvbiBnZXREaW1lbnNpb24obmFtZSwgd2FudElubmVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydHlWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF1Z21lbnREaW1lbnNpb24oZWxlbWVudCwgbmFtZSwgd2FudElubmVyKSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLkNTUy5zZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIG5hbWUsIHBhcnNlRmxvYXQocHJvcGVydHlWYWx1ZSkgLSBhdWdtZW50RGltZW5zaW9uKGVsZW1lbnQsIG5hbWUsIHdhbnRJbm5lcikgKyBcInB4XCIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBWZWxvY2l0eVN0YXRpYy5yZWdpc3Rlck5vcm1hbGl6YXRpb24oWyBFbGVtZW50LCBcImlubmVyV2lkdGhcIiwgZ2V0RGltZW5zaW9uKFwid2lkdGhcIiwgdHJ1ZSkgXSk7XG4gICAgVmVsb2NpdHlTdGF0aWMucmVnaXN0ZXJOb3JtYWxpemF0aW9uKFsgRWxlbWVudCwgXCJpbm5lckhlaWdodFwiLCBnZXREaW1lbnNpb24oXCJoZWlnaHRcIiwgdHJ1ZSkgXSk7XG4gICAgVmVsb2NpdHlTdGF0aWMucmVnaXN0ZXJOb3JtYWxpemF0aW9uKFsgRWxlbWVudCwgXCJvdXRlcldpZHRoXCIsIGdldERpbWVuc2lvbihcIndpZHRoXCIsIGZhbHNlKSBdKTtcbiAgICBWZWxvY2l0eVN0YXRpYy5yZWdpc3Rlck5vcm1hbGl6YXRpb24oWyBFbGVtZW50LCBcIm91dGVySGVpZ2h0XCIsIGdldERpbWVuc2lvbihcImhlaWdodFwiLCBmYWxzZSkgXSk7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJub3JtYWxpemF0aW9ucy50c1wiIC8+XG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqLyB2YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIFZlbG9jaXR5U3RhdGljLmlubGluZVJ4ID0gL14oYnxiaWd8aXxzbWFsbHx0dHxhYmJyfGFjcm9ueW18Y2l0ZXxjb2RlfGRmbnxlbXxrYmR8c3Ryb25nfHNhbXB8bGV0fGF8YmRvfGJyfGltZ3xtYXB8b2JqZWN0fHF8c2NyaXB0fHNwYW58c3VifHN1cHxidXR0b258aW5wdXR8bGFiZWx8c2VsZWN0fHRleHRhcmVhKSQvaSxcbiAgICBWZWxvY2l0eVN0YXRpYy5saXN0SXRlbVJ4ID0gL14obGkpJC9pLCBWZWxvY2l0eVN0YXRpYy50YWJsZVJvd1J4ID0gL14odHIpJC9pLCBWZWxvY2l0eVN0YXRpYy50YWJsZVJ4ID0gL14odGFibGUpJC9pLFxuICAgIFZlbG9jaXR5U3RhdGljLnRhYmxlUm93R3JvdXBSeCA9IC9eKHRib2R5KSQvaTtcbiAgICBmdW5jdGlvbiBkaXNwbGF5KGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICAgICAgaWYgKHByb3BlcnR5VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlbG9jaXR5U3RhdGljLkNTUy5jb21wdXRlUHJvcGVydHlWYWx1ZShlbGVtZW50LCBcImRpc3BsYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnR5VmFsdWUgPT09IFwiYXV0b1wiKSB7XG4gICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50ICYmIGVsZW1lbnQubm9kZU5hbWUsIGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKFZlbG9jaXR5U3RhdGljLmlubGluZVJ4LnRlc3Qobm9kZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlWYWx1ZSA9IFwiaW5saW5lXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFZlbG9jaXR5U3RhdGljLmxpc3RJdGVtUngudGVzdChub2RlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eVZhbHVlID0gXCJsaXN0LWl0ZW1cIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoVmVsb2NpdHlTdGF0aWMudGFibGVSb3dSeC50ZXN0KG5vZGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5VmFsdWUgPSBcInRhYmxlLXJvd1wiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChWZWxvY2l0eVN0YXRpYy50YWJsZVJ4LnRlc3Qobm9kZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlWYWx1ZSA9IFwidGFibGVcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoVmVsb2NpdHlTdGF0aWMudGFibGVSb3dHcm91cFJ4LnRlc3Qobm9kZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlWYWx1ZSA9IFwidGFibGUtcm93LWdyb3VwXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gXCJibG9ja1wiIHdoZW4gbm8gbWF0Y2ggaXMgZm91bmQuXG4gICAgICAgICAgICAgICAgcHJvcGVydHlWYWx1ZSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogV2UgbmVlZCB0byBkbyB0aGlzIGFzIGdldFByb3BlcnR5VmFsdWUgYnlwYXNzZXMgdGhlXG4gICAgICAgICAgICAvLyBOb3JtYWxpc2F0aW9uIHdoZW4gaXQgZXhpc3RzIGluIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2FjaGVbXCJkaXNwbGF5XCJdID0gcHJvcGVydHlWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS5kaXNwbGF5ID0gcHJvcGVydHlWYWx1ZTtcbiAgICB9XG4gICAgVmVsb2NpdHlTdGF0aWMucmVnaXN0ZXJOb3JtYWxpemF0aW9uKFsgRWxlbWVudCwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgXSk7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJub3JtYWxpemF0aW9ucy50c1wiIC8+XG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqLyB2YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIGZ1bmN0aW9uIGNsaWVudFdpZHRoKGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xpZW50V2lkdGggKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2Nyb2xsV2lkdGgoZWxlbWVudCwgcHJvcGVydHlWYWx1ZSkge1xuICAgICAgICBpZiAocHJvcGVydHlWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5zY3JvbGxXaWR0aCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjbGllbnRIZWlnaHQoZWxlbWVudCwgcHJvcGVydHlWYWx1ZSkge1xuICAgICAgICBpZiAocHJvcGVydHlWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5jbGllbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2Nyb2xsSGVpZ2h0KGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuc2Nyb2xsSGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjcm9sbChkaXJlY3Rpb24sIGVuZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIHRoZXNlIHZhbHVlcyBjYWNoZWQuXG4gICAgICAgICAgICAgICAgVmVsb2NpdHlTdGF0aWMuQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJjbGllbnRcIiArIGRpcmVjdGlvbiwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgVmVsb2NpdHlTdGF0aWMuQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJzY3JvbGxcIiArIGRpcmVjdGlvbiwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgVmVsb2NpdHlTdGF0aWMuQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJzY3JvbGxcIiArIGVuZCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRbXCJzY3JvbGxcIiArIGVuZF0gKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1x0XHRjb25zb2xlLmxvZyhcInNldFNjcm9sbFRvcFwiLCBwcm9wZXJ0eVZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VGbG9hdChwcm9wZXJ0eVZhbHVlKSwgdW5pdCA9IHByb3BlcnR5VmFsdWUucmVwbGFjZShTdHJpbmcodmFsdWUpLCBcIlwiKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJweFwiOlxuICAgICAgICAgICAgICAgIGVsZW1lbnRbXCJzY3JvbGxcIiArIGVuZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwiJVwiOlxuICAgICAgICAgICAgICAgIHZhciBjbGllbnQgPSBwYXJzZUZsb2F0KFZlbG9jaXR5U3RhdGljLkNTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiY2xpZW50XCIgKyBkaXJlY3Rpb24pKSwgc2Nyb2xsXzEgPSBwYXJzZUZsb2F0KFZlbG9jaXR5U3RhdGljLkNTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwic2Nyb2xsXCIgKyBkaXJlY3Rpb24pKTtcbiAgICAgICAgICAgICAgICAvL1x0XHRcdFx0Y29uc29sZS5sb2coXCJzZXRTY3JvbGxUb3AgcGVyY2VudFwiLCBzY3JvbGxIZWlnaHQsIGNsaWVudEhlaWdodCwgdmFsdWUsIE1hdGgubWF4KDAsIHNjcm9sbEhlaWdodCAtIGNsaWVudEhlaWdodCkgKiB2YWx1ZSAvIDEwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFtcInNjcm9sbFwiICsgZW5kXSA9IE1hdGgubWF4KDAsIHNjcm9sbF8xIC0gY2xpZW50KSAqIHZhbHVlIC8gMTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBWZWxvY2l0eVN0YXRpYy5yZWdpc3Rlck5vcm1hbGl6YXRpb24oWyBIVE1MRWxlbWVudCwgXCJzY3JvbGxcIiwgc2Nyb2xsKFwiSGVpZ2h0XCIsIFwiVG9wXCIpLCBmYWxzZSBdKTtcbiAgICBWZWxvY2l0eVN0YXRpYy5yZWdpc3Rlck5vcm1hbGl6YXRpb24oWyBIVE1MRWxlbWVudCwgXCJzY3JvbGxUb3BcIiwgc2Nyb2xsKFwiSGVpZ2h0XCIsIFwiVG9wXCIpLCBmYWxzZSBdKTtcbiAgICBWZWxvY2l0eVN0YXRpYy5yZWdpc3Rlck5vcm1hbGl6YXRpb24oWyBIVE1MRWxlbWVudCwgXCJzY3JvbGxMZWZ0XCIsIHNjcm9sbChcIldpZHRoXCIsIFwiTGVmdFwiKSwgZmFsc2UgXSk7XG4gICAgVmVsb2NpdHlTdGF0aWMucmVnaXN0ZXJOb3JtYWxpemF0aW9uKFsgSFRNTEVsZW1lbnQsIFwic2Nyb2xsV2lkdGhcIiwgc2Nyb2xsV2lkdGggXSk7XG4gICAgVmVsb2NpdHlTdGF0aWMucmVnaXN0ZXJOb3JtYWxpemF0aW9uKFsgSFRNTEVsZW1lbnQsIFwiY2xpZW50V2lkdGhcIiwgY2xpZW50V2lkdGggXSk7XG4gICAgVmVsb2NpdHlTdGF0aWMucmVnaXN0ZXJOb3JtYWxpemF0aW9uKFsgSFRNTEVsZW1lbnQsIFwic2Nyb2xsSGVpZ2h0XCIsIHNjcm9sbEhlaWdodCBdKTtcbiAgICBWZWxvY2l0eVN0YXRpYy5yZWdpc3Rlck5vcm1hbGl6YXRpb24oWyBIVE1MRWxlbWVudCwgXCJjbGllbnRIZWlnaHRcIiwgY2xpZW50SGVpZ2h0IF0pO1xufSkoVmVsb2NpdHlTdGF0aWMgfHwgKFZlbG9jaXR5U3RhdGljID0ge30pKTtcblxuLy8vPHJlZmVyZW5jZSBwYXRoPVwibm9ybWFsaXphdGlvbnMudHNcIiAvPlxuLypcbiAqIFZlbG9jaXR5SlMub3JnIChDKSAyMDE0LTIwMTcgSnVsaWFuIFNoYXBpcm8uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGRldGFpbHMuXG4gKlxuICogVGhpcyBoYW5kbGVzIGFsbCBDU1Mgc3R5bGUgcHJvcGVydGllcy4gV2l0aCBicm93c2VyIHByZWZpeGVkIHByb3BlcnRpZXMgaXRcbiAqIHdpbGwgcmVnaXN0ZXIgYSB2ZXJzaW9uIHRoYXQgaGFuZGxlcyBzZXR0aW5nIChhbmQgZ2V0dGluZykgYm90aCB0aGUgcHJlZml4ZWRcbiAqIGFuZCBub24tcHJlZml4ZWQgdmVyc2lvbi5cbiAqLyB2YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIC8qKlxuICAgICAqIEFuIFJlZ0V4cCBwYXR0ZXJuIGZvciB0aGUgZm9sbG93aW5nIGxpc3Qgb2YgY3NzIHdvcmRzIHVzaW5nXG4gICAgICogaHR0cDovL2tlbWlvLmNvbS5hci90b29scy9sc3QtdHJpZS1yZS5waHAgdG8gZ2VuZXJhdGU6XG4gICAgICpcbiAgICAgKiBibG9ja1NpemVcbiAgICAgKiBib3JkZXJCb3R0b21MZWZ0UmFkaXVzXG4gICAgICogYm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcbiAgICAgKiBib3JkZXJCb3R0b21XaWR0aFxuICAgICAqIGJvcmRlckltYWdlT3V0c2V0XG4gICAgICogYm9yZGVySW1hZ2VXaWR0aFxuICAgICAqIGJvcmRlckxlZnRXaWR0aFxuICAgICAqIGJvcmRlclJhZGl1c1xuICAgICAqIGJvcmRlclJpZ2h0V2lkdGhcbiAgICAgKiBib3JkZXJTcGFjaW5nXG4gICAgICogYm9yZGVyVG9wTGVmdFJhZGl1c1xuICAgICAqIGJvcmRlclRvcFJpZ2h0UmFkaXVzXG4gICAgICogYm9yZGVyVG9wV2lkdGhcbiAgICAgKiBib3JkZXJXaWR0aFxuICAgICAqIGJvdHRvbVxuICAgICAqIGNvbHVtbkdhcFxuICAgICAqIGNvbHVtblJ1bGVXaWR0aFxuICAgICAqIGNvbHVtbldpZHRoXG4gICAgICogZmxleEJhc2lzXG4gICAgICogZm9udFNpemVcbiAgICAgKiBncmlkQ29sdW1uR2FwXG4gICAgICogZ3JpZEdhcFxuICAgICAqIGdyaWRSb3dHYXBcbiAgICAgKiBoZWlnaHRcbiAgICAgKiBpbmxpbmVTaXplXG4gICAgICogbGVmdFxuICAgICAqIGxldHRlclNwYWNpbmdcbiAgICAgKiBtYXJnaW5cbiAgICAgKiBtYXJnaW5Cb3R0b21cbiAgICAgKiBtYXJnaW5MZWZ0XG4gICAgICogbWFyZ2luUmlnaHRcbiAgICAgKiBtYXJnaW5Ub3BcbiAgICAgKiBtYXhCbG9ja1NpemVcbiAgICAgKiBtYXhIZWlnaHRcbiAgICAgKiBtYXhJbmxpbmVTaXplXG4gICAgICogbWF4V2lkdGhcbiAgICAgKiBtaW5CbG9ja1NpemVcbiAgICAgKiBtaW5IZWlnaHRcbiAgICAgKiBtaW5JbmxpbmVTaXplXG4gICAgICogbWluV2lkdGhcbiAgICAgKiBvYmplY3RQb3NpdGlvblxuICAgICAqIG91dGxpbmVPZmZzZXRcbiAgICAgKiBvdXRsaW5lV2lkdGhcbiAgICAgKiBwYWRkaW5nXG4gICAgICogcGFkZGluZ0JvdHRvbVxuICAgICAqIHBhZGRpbmdMZWZ0XG4gICAgICogcGFkZGluZ1JpZ2h0XG4gICAgICogcGFkZGluZ1RvcFxuICAgICAqIHBlcnNwZWN0aXZlXG4gICAgICogcmlnaHRcbiAgICAgKiBzaGFwZU1hcmdpblxuICAgICAqIHN0cm9rZURhc2hvZmZzZXRcbiAgICAgKiBzdHJva2VXaWR0aFxuICAgICAqIHRleHRJbmRlbnRcbiAgICAgKiB0b3BcbiAgICAgKiB0cmFuc2Zvcm1PcmlnaW5cbiAgICAgKiB3aWR0aFxuICAgICAqIHdvcmRTcGFjaW5nXG4gICAgICovXG4gICAgdmFyIHJ4QWRkUHggPSAvXihiKGxvY2tTaXplfG8ocmRlcihCb3R0b20oTGVmdFJhZGl1c3xSaWdodFJhZGl1c3xXaWR0aCl8SW1hZ2UoT3V0c2V0fFdpZHRoKXxMZWZ0V2lkdGh8UihhZGl1c3xpZ2h0V2lkdGgpfFNwYWNpbmd8VG9wKExlZnRSYWRpdXN8UmlnaHRSYWRpdXN8V2lkdGgpfFdpZHRoKXx0dG9tKSl8Y29sdW1uKEdhcHxSdWxlV2lkdGh8V2lkdGgpfGYobGV4QmFzaXN8b250U2l6ZSl8Z3JpZChDb2x1bW5HYXB8R2FwfFJvd0dhcCl8aGVpZ2h0fGlubGluZVNpemV8bGUoZnR8dHRlclNwYWNpbmcpfG0oYShyZ2luKEJvdHRvbXxMZWZ0fFJpZ2h0fFRvcCl8eChCbG9ja1NpemV8SGVpZ2h0fElubGluZVNpemV8V2lkdGgpKXxpbihCbG9ja1NpemV8SGVpZ2h0fElubGluZVNpemV8V2lkdGgpKXxvKGJqZWN0UG9zaXRpb258dXRsaW5lKE9mZnNldHxXaWR0aCkpfHAoYWRkaW5nKEJvdHRvbXxMZWZ0fFJpZ2h0fFRvcCl8ZXJzcGVjdGl2ZSl8cmlnaHR8cyhoYXBlTWFyZ2lufHRyb2tlKERhc2hvZmZzZXR8V2lkdGgpKXx0KGV4dEluZGVudHxvcHxyYW5zZm9ybU9yaWdpbil8dyhpZHRofG9yZFNwYWNpbmcpKSQvO1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhIE5vcm1hbGlzYXRpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBzZXQgLyBnZXQgYSBwcmVmaXhlZCBzdHlsZVxuICAgICAqIHByb3BlcnR5LlxuICAgICAqLyAgICBmdW5jdGlvbiBnZXRTZXRQcmVmaXhlZChwcm9wZXJ0eU5hbWUsIHVucHJlZml4ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVsb2NpdHlTdGF0aWMuQ1NTLmNvbXB1dGVQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5TmFtZSkgfHwgVmVsb2NpdHlTdGF0aWMuQ1NTLmNvbXB1dGVQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIHVucHJlZml4ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wZXJ0eU5hbWVdID0gZWxlbWVudC5zdHlsZVt1bnByZWZpeGVkXSA9IHByb3BlcnR5VmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIE5vcm1hbGlzYXRpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBzZXQgLyBnZXQgYSBzdHlsZSBwcm9wZXJ0eS5cbiAgICAgKi8gICAgZnVuY3Rpb24gZ2V0U2V0U3R5bGUocHJvcGVydHlOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydHlWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlbG9jaXR5U3RhdGljLkNTUy5jb21wdXRlUHJvcGVydHlWYWx1ZShlbGVtZW50LCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wZXJ0eU5hbWVdID0gcHJvcGVydHlWYWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVuZG9yIHByZWZpeGVzLiBDaHJvbWUgLyBTYWZhcmksIEZpcmVmb3gsIElFIC8gRWRnZSwgT3BlcmEuXG4gICAgICovICAgIHZhciByeFZlbmRvcnMgPSAvXih3ZWJraXR8bW96fG1zfG8pW0EtWl0vLCBwcmVmaXhFbGVtZW50ID0gVmVsb2NpdHlTdGF0aWMuU3RhdGUucHJlZml4RWxlbWVudDtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gcHJlZml4RWxlbWVudC5zdHlsZSkge1xuICAgICAgICBpZiAocnhWZW5kb3JzLnRlc3QocHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgdmFyIHVucHJlZml4ZWQgPSBwcm9wZXJ0eU5hbWUucmVwbGFjZSgvXlthLXpdKyhbQS1aXSkvLCBmdW5jdGlvbigkLCBsZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGV0dGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChBTExfVkVORE9SX1BSRUZJWEVTIHx8IGlzU3RyaW5nKHByZWZpeEVsZW1lbnQuc3R5bGVbdW5wcmVmaXhlZF0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkZFVuaXQgPSByeEFkZFB4LnRlc3QodW5wcmVmaXhlZCkgPyBcInB4XCIgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgVmVsb2NpdHlTdGF0aWMucmVnaXN0ZXJOb3JtYWxpemF0aW9uKFsgRWxlbWVudCwgdW5wcmVmaXhlZCwgZ2V0U2V0UHJlZml4ZWQocHJvcGVydHlOYW1lLCB1bnByZWZpeGVkKSwgYWRkVW5pdCBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghVmVsb2NpdHlTdGF0aWMuaGFzTm9ybWFsaXphdGlvbihbIEVsZW1lbnQsIHByb3BlcnR5TmFtZSBdKSkge1xuICAgICAgICAgICAgdmFyIGFkZFVuaXQgPSByeEFkZFB4LnRlc3QocHJvcGVydHlOYW1lKSA/IFwicHhcIiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLnJlZ2lzdGVyTm9ybWFsaXphdGlvbihbIEVsZW1lbnQsIHByb3BlcnR5TmFtZSwgZ2V0U2V0U3R5bGUocHJvcGVydHlOYW1lKSwgYWRkVW5pdCBdKTtcbiAgICAgICAgfVxuICAgIH1cbn0pKFZlbG9jaXR5U3RhdGljIHx8IChWZWxvY2l0eVN0YXRpYyA9IHt9KSk7XG5cbi8vLzxyZWZlcmVuY2UgcGF0aD1cIm5vcm1hbGl6YXRpb25zLnRzXCIgLz5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICovIHZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgLyoqXG4gICAgICogQSBmYWtlIG5vcm1hbGl6YXRpb24gdXNlZCB0byBhbGxvdyB0aGUgXCJ0d2VlblwiIHByb3BlcnR5IGVhc3kgYWNjZXNzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNldFR3ZWVuKGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVmVsb2NpdHlTdGF0aWMucmVnaXN0ZXJOb3JtYWxpemF0aW9uKFsgRWxlbWVudCwgXCJ0d2VlblwiLCBnZXRTZXRUd2VlbiBdKTtcbn0pKFZlbG9jaXR5U3RhdGljIHx8IChWZWxvY2l0eVN0YXRpYyA9IHt9KSk7XG5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICpcbiAqIENhbGwgQ29tcGxldGlvblxuICovIHZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgY29tcGxldGUgbWV0aG9kIG9mIGFuIGFuaW1hdGlvbiBpbiBhIHNlcGFyYXRlIGZ1bmN0aW9uIHNvIGl0IGNhblxuICAgICAqIGJlbmVmaXQgZnJvbSBKSVQgY29tcGlsaW5nIHdoaWxlIHN0aWxsIGhhdmluZyBhIHRyeS9jYXRjaCBibG9jay5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxsQ29tcGxldGUoYWN0aXZlQ2FsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gYWN0aXZlQ2FsbC5lbGVtZW50cztcbiAgICAgICAgICAgIGFjdGl2ZUNhbGwub3B0aW9ucy5jb21wbGV0ZS5jYWxsKGVsZW1lbnRzLCBlbGVtZW50cywgYWN0aXZlQ2FsbCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGxldGUgYW4gYW5pbWF0aW9uLiBUaGlzIG1pZ2h0IGludm9sdmUgcmVzdGFydGluZyAoZm9yIGxvb3Agb3IgcmVwZWF0XG4gICAgICogb3B0aW9ucykuIE9uY2UgaXQgaXMgZmluaXNoZWQgd2UgYWxzbyBjaGVjayBmb3IgYW55IGNhbGxiYWNrcyBvciBQcm9taXNlc1xuICAgICAqIHRoYXQgbmVlZCB1cGRhdGluZy5cbiAgICAgKi8gICAgZnVuY3Rpb24gY29tcGxldGVDYWxsKGFjdGl2ZUNhbGwpIHtcbiAgICAgICAgLy9cdFx0Y29uc29sZS5sb2coXCJjb21wbGV0ZVwiLCBhY3RpdmVDYWxsKVxuICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiBpdCdzIG5vdCBiZWVuIGNvbXBsZXRlZCBhbHJlYWR5XG4gICAgICAgIHZhciBvcHRpb25zID0gYWN0aXZlQ2FsbC5vcHRpb25zLCBxdWV1ZSA9IGdldFZhbHVlKGFjdGl2ZUNhbGwucXVldWUsIG9wdGlvbnMucXVldWUpLCBpc0xvb3AgPSBnZXRWYWx1ZShhY3RpdmVDYWxsLmxvb3AsIG9wdGlvbnMubG9vcCwgVmVsb2NpdHlTdGF0aWMuZGVmYXVsdHMubG9vcCksIGlzUmVwZWF0ID0gZ2V0VmFsdWUoYWN0aXZlQ2FsbC5yZXBlYXQsIG9wdGlvbnMucmVwZWF0LCBWZWxvY2l0eVN0YXRpYy5kZWZhdWx0cy5yZXBlYXQpLCBpc1N0b3BwZWQgPSBhY3RpdmVDYWxsLl9mbGFncyAmIDggLyogU1RPUFBFRCAqLztcbiAgICAgICAgaWYgKCFpc1N0b3BwZWQgJiYgKGlzTG9vcCB8fCBpc1JlcGVhdCkpIHtcbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBPcHRpb246IExvb3AgICAvL1xuICAgICAgICAgICAgLy8gT3B0aW9uOiBSZXBlYXQgLy9cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICBpZiAoaXNSZXBlYXQgJiYgaXNSZXBlYXQgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVDYWxsLnJlcGVhdCA9IGlzUmVwZWF0IC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMb29wICYmIGlzTG9vcCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUNhbGwubG9vcCA9IGlzTG9vcCAtIDE7XG4gICAgICAgICAgICAgICAgYWN0aXZlQ2FsbC5yZXBlYXQgPSBnZXRWYWx1ZShhY3RpdmVDYWxsLnJlcGVhdEFnYWluLCBvcHRpb25zLnJlcGVhdEFnYWluLCBWZWxvY2l0eVN0YXRpYy5kZWZhdWx0cy5yZXBlYXRBZ2Fpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNMb29wKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlQ2FsbC5fZmxhZ3MgXj0gNjQgLyogUkVWRVJTRSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxdWV1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW4ndCBiZSBjYWxsZWQgd2hlbiBzdG9wcGVkIHNvIG5vIG5lZWQgZm9yIGFuIGV4dHJhIGNoZWNrLlxuICAgICAgICAgICAgICAgIERhdGEoYWN0aXZlQ2FsbC5lbGVtZW50KS5sYXN0RmluaXNoTGlzdFtxdWV1ZV0gPSBhY3RpdmVDYWxsLnRpbWVTdGFydCArIGdldFZhbHVlKGFjdGl2ZUNhbGwuZHVyYXRpb24sIG9wdGlvbnMuZHVyYXRpb24sIFZlbG9jaXR5U3RhdGljLmRlZmF1bHRzLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGl2ZUNhbGwudGltZVN0YXJ0ID0gYWN0aXZlQ2FsbC5lbGxhcHNlZFRpbWUgPSBhY3RpdmVDYWxsLnBlcmNlbnRDb21wbGV0ZSA9IDA7XG4gICAgICAgICAgICBhY3RpdmVDYWxsLl9mbGFncyAmPSB+NCAvKiBTVEFSVEVEICovO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBhY3RpdmVDYWxsLmVsZW1lbnQsIGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCEtLWRhdGEuY291bnQgJiYgIWlzU3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgICAgIC8vIEZlYXR1cmU6IENsYXNzbmFtZSAvL1xuICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIFZlbG9jaXR5U3RhdGljLlN0YXRlLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBPcHRpb246IENvbXBsZXRlIC8vXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBsYXN0IGFuaW1hdGlvbiBpbiB0aGlzIGxpc3QgdGhlbiB3ZSBjYW4gY2hlY2sgZm9yXG4gICAgICAgICAgICAvLyBhbmQgY29tcGxldGUgY2FsbHMgb3IgUHJvbWlzZXMuXG4gICAgICAgICAgICAvLyBUT0RPOiBXaGVuIGRlbGV0aW5nIGFuIGVsZW1lbnQgd2UgbmVlZCB0byBhZGp1c3QgdGhlc2UgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgKytvcHRpb25zLl9jb21wbGV0ZWQgPT09IG9wdGlvbnMuX3RvdGFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0b3BwZWQgJiYgb3B0aW9ucy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBjYWxsIHRoZSBjb21wbGV0ZSBpZiB0aGUgYW5pbWF0aW9uIGlzIHN0b3BwZWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSBjbGVhciB0aGUga2V5IHRvIHByZXZlbnQgaXQgYmVpbmcgY2FsbGVkIGFnYWluLlxuICAgICAgICAgICAgICAgICAgICBjYWxsQ29tcGxldGUoYWN0aXZlQ2FsbCk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29tcGxldGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZXIgPSBvcHRpb25zLl9yZXNvbHZlcjtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRnVsZmlsIHRoZSBQcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVyKGFjdGl2ZUNhbGwuZWxlbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5fcmVzb2x2ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8gT3B0aW9uOiBRdWV1ZSAvL1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXVlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgZG8gY2xldmVyIHRoaW5ncyB3aXRoIHF1ZXVlcy4uLlxuICAgICAgICAgICAgICAgIGlmICghaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBzdG9wcGluZyBhbiBhbmltYXRpb24sIHdlIG5lZWQgdG8gcmVtZW1iZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hhdCB0aW1lIGl0IGZpbmlzaGVkIHNvIHRoYXQgdGhlIG5leHQgYW5pbWF0aW9uIGluXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlcXVlbmNlIGdldHMgdGhlIGNvcnJlY3Qgc3RhcnQgdGltZS5cbiAgICAgICAgICAgICAgICAgICAgZGF0YS5sYXN0RmluaXNoTGlzdFtxdWV1ZV0gPSBhY3RpdmVDYWxsLnRpbWVTdGFydCArIGdldFZhbHVlKGFjdGl2ZUNhbGwuZHVyYXRpb24sIG9wdGlvbnMuZHVyYXRpb24sIFZlbG9jaXR5U3RhdGljLmRlZmF1bHRzLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIG5leHQgYW5pbWF0aW9uIGluIHNlcXVlbmNlLCBvciBkZWxldGUgdGhlIHF1ZXVlIGlmXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgdGhlIGxhc3Qgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWxvY2l0eVN0YXRpYy5kZXF1ZXVlKGVsZW1lbnQsIHF1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENsZWFudXAgYW55IHBvaW50ZXJzLCBhbmQgcmVtZW1iZXIgdGhlIGxhc3QgYW5pbWF0aW9uIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLmZyZWVBbmltYXRpb25DYWxsKGFjdGl2ZUNhbGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFZlbG9jaXR5U3RhdGljLmNvbXBsZXRlQ2FsbCA9IGNvbXBsZXRlQ2FsbDtcbn0pKFZlbG9jaXR5U3RhdGljIHx8IChWZWxvY2l0eVN0YXRpYyA9IHt9KSk7XG5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICovXG4vKipcbiAqIEdldCAoYW5kIGNyZWF0ZSkgdGhlIGludGVybmFsIGRhdGEgc3RvcmUgZm9yIGFuIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIERhdGEoZWxlbWVudCkge1xuICAgIC8vIFVzZSBhIHN0cmluZyBtZW1iZXIgc28gVWdsaWZ5IGRvZXNuJ3QgbWFuZ2xlIGl0LlxuICAgIHZhciBkYXRhID0gZWxlbWVudFtcInZlbG9jaXR5RGF0YVwiXTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgdmFyIHR5cGVzID0gMDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGNvbnN0cnVjdG9ycyA9IFZlbG9jaXR5U3RhdGljLmNvbnN0cnVjdG9yczsgaW5kZXggPCBjb25zdHJ1Y3RvcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgY29uc3RydWN0b3JzW2luZGV4XSkge1xuICAgICAgICAgICAgdHlwZXMgfD0gMSA8PCBpbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEbyBpdCB0aGlzIHdheSBzbyBpdCBlcnJvcnMgb24gaW5jb3JyZWN0IGRhdGEuXG4gICAgICAgIHZhciBuZXdEYXRhID0ge1xuICAgICAgICB0eXBlczogdHlwZXMsXG4gICAgICAgIGNvdW50OiAwLFxuICAgICAgICBjb21wdXRlZFN0eWxlOiBudWxsLFxuICAgICAgICBjYWNoZTogY3JlYXRlRW1wdHlPYmplY3QoKSxcbiAgICAgICAgcXVldWVMaXN0OiBjcmVhdGVFbXB0eU9iamVjdCgpLFxuICAgICAgICBsYXN0QW5pbWF0aW9uTGlzdDogY3JlYXRlRW1wdHlPYmplY3QoKSxcbiAgICAgICAgbGFzdEZpbmlzaExpc3Q6IGNyZWF0ZUVtcHR5T2JqZWN0KClcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCBcInZlbG9jaXR5RGF0YVwiLCB7XG4gICAgICAgIHZhbHVlOiBuZXdEYXRhXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0RhdGE7XG59XG5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICovIHZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUsIDEgb3IgMiAobW9zdCB2ZXJib3NlKSB0byBvdXRwdXQgZGVidWcgaW5mbyB0byBjb25zb2xlLlxuICAgICAqL1xuICAgIFZlbG9jaXR5U3RhdGljLmRlYnVnID0gZmFsc2U7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqXG4gKiBWZWxvY2l0eSBvcHRpb24gZGVmYXVsdHMsIHdoaWNoIGNhbiBiZSBvdmVycmlkZW4gYnkgdGhlIHVzZXIuXG4gKi9cbnZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgLy8gTk9URTogQWRkIHRoZSB2YXJpYWJsZSBoZXJlLCB0aGVuIGFkZCB0aGUgZGVmYXVsdCBzdGF0ZSBpbiBcInJlc2V0XCIgYmVsb3cuXG4gICAgdmFyIF9jYWNoZSwgX2JlZ2luLCBfY29tcGxldGUsIF9kZWxheSwgX2R1cmF0aW9uLCBfZWFzaW5nLCBfZnBzTGltaXQsIF9sb29wLCBfbWluRnJhbWVUaW1lLCBfcHJvbWlzZSwgX3Byb21pc2VSZWplY3RFbXB0eSwgX3F1ZXVlLCBfcmVwZWF0LCBfc3BlZWQsIF9zeW5jO1xuICAgIFZlbG9jaXR5U3RhdGljLmRlZmF1bHRzID0ge1xuICAgICAgICBtb2JpbGVIQTogdHJ1ZVxuICAgIH07XG4gICAgLy8gSU1QT1JUQU5UOiBNYWtlIHN1cmUgYW55IG5ldyBkZWZhdWx0cyBnZXQgYWRkZWQgdG8gdGhlIGFjdGlvbnMvc2V0LnRzIGxpc3RcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVmVsb2NpdHlTdGF0aWMuZGVmYXVsdHMsIHtcbiAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgX2NhY2hlID0gREVGQVVMVF9DQUNIRTtcbiAgICAgICAgICAgICAgICBfYmVnaW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgX2NvbXBsZXRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIF9kZWxheSA9IERFRkFVTFRfREVMQVk7XG4gICAgICAgICAgICAgICAgX2R1cmF0aW9uID0gREVGQVVMVF9EVVJBVElPTjtcbiAgICAgICAgICAgICAgICBfZWFzaW5nID0gdmFsaWRhdGVFYXNpbmcoREVGQVVMVF9FQVNJTkcsIERFRkFVTFRfRFVSQVRJT04pO1xuICAgICAgICAgICAgICAgIF9mcHNMaW1pdCA9IERFRkFVTFRfRlBTTElNSVQ7XG4gICAgICAgICAgICAgICAgX2xvb3AgPSBERUZBVUxUX0xPT1A7XG4gICAgICAgICAgICAgICAgX21pbkZyYW1lVGltZSA9IEZVWlpZX01TX1BFUl9TRUNPTkQgLyBERUZBVUxUX0ZQU0xJTUlUO1xuICAgICAgICAgICAgICAgIF9wcm9taXNlID0gREVGQVVMVF9QUk9NSVNFO1xuICAgICAgICAgICAgICAgIF9wcm9taXNlUmVqZWN0RW1wdHkgPSBERUZBVUxUX1BST01JU0VfUkVKRUNUX0VNUFRZO1xuICAgICAgICAgICAgICAgIF9xdWV1ZSA9IERFRkFVTFRfUVVFVUU7XG4gICAgICAgICAgICAgICAgX3JlcGVhdCA9IERFRkFVTFRfUkVQRUFUO1xuICAgICAgICAgICAgICAgIF9zcGVlZCA9IERFRkFVTFRfU1BFRUQ7XG4gICAgICAgICAgICAgICAgX3N5bmMgPSBERUZBVUxUX1NZTkM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhY2hlOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhY2hlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbGlkYXRlQ2FjaGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYWNoZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYmVnaW46IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfYmVnaW47XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsaWRhdGVCZWdpbih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2JlZ2luID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb21wbGV0ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWxpZGF0ZUNvbXBsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBfY29tcGxldGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGF5OiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2RlbGF5O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbGlkYXRlRGVsYXkodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9kZWxheSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZHVyYXRpb246IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZHVyYXRpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsaWRhdGVEdXJhdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2R1cmF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlYXNpbmc6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZWFzaW5nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbGlkYXRlRWFzaW5nKHZhbHVlLCBfZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lYXNpbmcgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZwc0xpbWl0OiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Zwc0xpbWl0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbGlkYXRlRnBzTGltaXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9mcHNMaW1pdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfbWluRnJhbWVUaW1lID0gRlVaWllfTVNfUEVSX1NFQ09ORCAvIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbG9vcDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9sb29wO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbGlkYXRlTG9vcCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2xvb3AgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1pbkZyYW1lVGltZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9taW5GcmFtZVRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByb21pc2U6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcHJvbWlzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWxpZGF0ZVByb21pc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wcm9taXNlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcm9taXNlUmVqZWN0RW1wdHk6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcHJvbWlzZVJlamVjdEVtcHR5O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbGlkYXRlUHJvbWlzZVJlamVjdEVtcHR5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBfcHJvbWlzZVJlamVjdEVtcHR5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBxdWV1ZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9xdWV1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWxpZGF0ZVF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBfcXVldWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlcGVhdDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZXBlYXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsaWRhdGVSZXBlYXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9yZXBlYXQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNwZWVkOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NwZWVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbGlkYXRlU3BlZWQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zcGVlZCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3luYzoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zeW5jO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbGlkYXRlU3luYyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3N5bmMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBWZWxvY2l0eVN0YXRpYy5kZWZhdWx0cy5yZXNldCgpO1xufSkoVmVsb2NpdHlTdGF0aWMgfHwgKFZlbG9jaXR5U3RhdGljID0ge30pKTtcblxuLypcbiAqIFZlbG9jaXR5SlMub3JnIChDKSAyMDE0LTIwMTcgSnVsaWFuIFNoYXBpcm8uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGRldGFpbHMuXG4gKlxuICogVmVsb2NpdHktd2lkZSBhbmltYXRpb24gdGltZSByZW1hcHBpbmcgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gKi9cbnZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgLyoqXG4gICAgICogSW4gbW9jayBtb2RlLCBhbGwgYW5pbWF0aW9ucyBhcmUgZm9yY2VkIHRvIGNvbXBsZXRlIGltbWVkaWF0ZWx5IHVwb24gdGhlXG4gICAgICogbmV4dCByQUYgdGljay4gSWYgdGhlcmUgYXJlIGZ1cnRoZXIgYW5pbWF0aW9ucyBxdWV1ZWQgdGhlbiB0aGV5IHdpbGwgZWFjaFxuICAgICAqIHRha2Ugb25lIHNpbmdsZSBmcmFtZSBpbiB0dXJuLiBMb29wcyBhbmQgcmVwZWF0cyB3aWxsIGJlIGRpc2FibGVkIHdoaWxlXG4gICAgICogPGNvZGU+bW9jayA9IHRydWU8L2NvZGU+LlxuICAgICAqL1xuICAgIFZlbG9jaXR5U3RhdGljLm1vY2sgPSBmYWxzZTtcbn0pKFZlbG9jaXR5U3RhdGljIHx8IChWZWxvY2l0eVN0YXRpYyA9IHt9KSk7XG5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICovXG52YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcGF0Y2ggYW55IG9iamVjdCB0byBhbGxvdyBWZWxvY2l0eSBjaGFpbmluZy4gSW4gb3JkZXIgdG8gY2hhaW4gYW5cbiAgICAgKiBvYmplY3QgbXVzdCBlaXRoZXIgYmUgdHJlYXRhYmxlIGFzIGFuIGFycmF5IC0gd2l0aCBhIDxjb2RlPi5sZW5ndGg8L2NvZGU+XG4gICAgICogcHJvcGVydHksIGFuZCBlYWNoIG1lbWJlciBhIE5vZGUsIG9yIGEgTm9kZSBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQgVmVsb2NpdHkgd2lsbCB0cnkgdG8gcGF0Y2ggPGNvZGU+d2luZG93PC9jb2RlPixcbiAgICAgKiA8Y29kZT5qUXVlcnk8L2NvZGU+LCA8Y29kZT5aZXB0bzwvY29kZT4sIGFuZCBzZXZlcmFsIGNsYXNzZXMgdGhhdCByZXR1cm5cbiAgICAgKiBOb2RlcyBvciBsaXN0cyBvZiBOb2Rlcy5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXRjaChwcm90bywgZ2xvYmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShwcm90bywgKGdsb2JhbCA/IFwiVlwiIDogXCJ2XCIpICsgXCJlbG9jaXR5XCIsIFZlbG9jaXR5Rm4pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJWZWxvY2l0eUpTOiBFcnJvciB3aGVuIHRyeWluZyB0byBhZGQgcHJvdG90eXBlLlwiLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBWZWxvY2l0eVN0YXRpYy5wYXRjaCA9IHBhdGNoO1xufSkoVmVsb2NpdHlTdGF0aWMgfHwgKFZlbG9jaXR5U3RhdGljID0ge30pKTtcblxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiZGF0YS50c1wiIC8+XG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqXG4gKiBBbmltYXRpb25DYWxsIHF1ZXVlXG4gKi9cbnZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgLyoqXG4gICAgICogU2ltcGxlIHF1ZXVlIG1hbmFnZW1lbnQuIFVuLW5hbWVkIHF1ZXVlIGlzIGRpcmVjdGx5IHdpdGhpbiB0aGUgZWxlbWVudCBkYXRhLFxuICAgICAqIG5hbWVkIHF1ZXVlIGlzIHdpdGhpbiBhbiBvYmplY3Qgd2l0aGluIGl0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFuaW1hdGUoYW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciBwcmV2ID0gVmVsb2NpdHlTdGF0aWMuU3RhdGUubGFzdDtcbiAgICAgICAgYW5pbWF0aW9uLl9wcmV2ID0gcHJldjtcbiAgICAgICAgYW5pbWF0aW9uLl9uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgcHJldi5fbmV4dCA9IGFuaW1hdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLlN0YXRlLmZpcnN0ID0gYW5pbWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIFZlbG9jaXR5U3RhdGljLlN0YXRlLmxhc3QgPSBhbmltYXRpb247XG4gICAgICAgIGlmICghVmVsb2NpdHlTdGF0aWMuU3RhdGUuZmlyc3ROZXcpIHtcbiAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLlN0YXRlLmZpcnN0TmV3ID0gYW5pbWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gYW5pbWF0aW9uLmVsZW1lbnQsIGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuICAgICAgICBpZiAoIWRhdGEuY291bnQrKykge1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBGZWF0dXJlOiBDbGFzc25hbWUgLy9cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgVmVsb2NpdHlTdGF0aWMuU3RhdGUuY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gaXRlbSB0byBhbiBhbmltYXRpb24gcXVldWUuXG4gICAgICovICAgIGZ1bmN0aW9uIHF1ZXVlKGVsZW1lbnQsIGFuaW1hdGlvbiwgcXVldWUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuICAgICAgICBpZiAocXVldWUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgbGFzdCBhbmltYXRpb24gYWRkZWQgc28gd2UgY2FuIHVzZSBpdCBmb3IgdGhlXG4gICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgdGhlIG5leHQgb25lLlxuICAgICAgICAgICAgZGF0YS5sYXN0QW5pbWF0aW9uTGlzdFtxdWV1ZV0gPSBhbmltYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYW5pbWF0ZShhbmltYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhxdWV1ZSkpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGFzdCA9IGRhdGEucXVldWVMaXN0W3F1ZXVlXTtcbiAgICAgICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucXVldWVMaXN0W3F1ZXVlXSA9IGFuaW1hdGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnF1ZXVlTGlzdFtxdWV1ZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRlKGFuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobGFzdC5fbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gbGFzdC5fbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdC5fbmV4dCA9IGFuaW1hdGlvbjtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24uX3ByZXYgPSBsYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFZlbG9jaXR5U3RhdGljLnF1ZXVlID0gcXVldWU7XG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIG5leHQgYW5pbWF0aW9uIG9uIHRoaXMgZWxlbWVudCdzIHF1ZXVlIChuYW1lZCBvciBkZWZhdWx0KS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBuZXh0IGFuaW1hdGlvbiB0aGF0IGlzIHN0YXJ0aW5nLlxuICAgICAqLyAgICBmdW5jdGlvbiBkZXF1ZXVlKGVsZW1lbnQsIHF1ZXVlLCBza2lwKSB7XG4gICAgICAgIGlmIChxdWV1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICghaXNTdHJpbmcocXVldWUpKSB7XG4gICAgICAgICAgICAgICAgcXVldWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRhdGEgPSBEYXRhKGVsZW1lbnQpLCBhbmltYXRpb24gPSBkYXRhLnF1ZXVlTGlzdFtxdWV1ZV07XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5xdWV1ZUxpc3RbcXVldWVdID0gYW5pbWF0aW9uLl9uZXh0IHx8IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFza2lwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoYW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFuaW1hdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhLnF1ZXVlTGlzdFtxdWV1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIFZlbG9jaXR5U3RhdGljLmRlcXVldWUgPSBkZXF1ZXVlO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBhbmltYXRpb24gZnJvbSB0aGUgYWN0aXZlIGFuaW1hdGlvbiBsaXN0LiBJZiBpdCBoYXMgYSBxdWV1ZSBzZXRcbiAgICAgKiB0aGVuIHJlbWVtYmVyIGl0IGFzIHRoZSBsYXN0IGFuaW1hdGlvbiBmb3IgdGhhdCBxdWV1ZSwgYW5kIGZyZWUgdGhlIG9uZVxuICAgICAqIHRoYXQgd2FzIHByZXZpb3VzbHkgdGhlcmUuIElmIHRoZSBhbmltYXRpb24gbGlzdCBpcyBjb21wbGV0ZWx5IGVtcHR5IHRoZW5cbiAgICAgKiBtYXJrIHVzIGFzIGZpbmlzaGVkLlxuICAgICAqLyAgICBmdW5jdGlvbiBmcmVlQW5pbWF0aW9uQ2FsbChhbmltYXRpb24pIHtcbiAgICAgICAgdmFyIG5leHQgPSBhbmltYXRpb24uX25leHQsIHByZXYgPSBhbmltYXRpb24uX3ByZXYsIHF1ZXVlID0gYW5pbWF0aW9uLnF1ZXVlID09IG51bGwgPyBhbmltYXRpb24ub3B0aW9ucy5xdWV1ZSA6IGFuaW1hdGlvbi5xdWV1ZTtcbiAgICAgICAgaWYgKFZlbG9jaXR5U3RhdGljLlN0YXRlLmZpcnN0TmV3ID09PSBhbmltYXRpb24pIHtcbiAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLlN0YXRlLmZpcnN0TmV3ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVmVsb2NpdHlTdGF0aWMuU3RhdGUuZmlyc3QgPT09IGFuaW1hdGlvbikge1xuICAgICAgICAgICAgVmVsb2NpdHlTdGF0aWMuU3RhdGUuZmlyc3QgPSBuZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIHByZXYuX25leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChWZWxvY2l0eVN0YXRpYy5TdGF0ZS5sYXN0ID09PSBhbmltYXRpb24pIHtcbiAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLlN0YXRlLmxhc3QgPSBwcmV2O1xuICAgICAgICB9IGVsc2UgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIG5leHQuX3ByZXYgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWV1ZSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBEYXRhKGFuaW1hdGlvbi5lbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLl9uZXh0ID0gYW5pbWF0aW9uLl9wcmV2ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFZlbG9jaXR5U3RhdGljLmZyZWVBbmltYXRpb25DYWxsID0gZnJlZUFuaW1hdGlvbkNhbGw7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqLyB2YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIC8qIENvbnRhaW5lciBmb3IgdGhlIHVzZXIncyBjdXN0b20gYW5pbWF0aW9uIHJlZGlyZWN0cyB0aGF0IGFyZSByZWZlcmVuY2VkIGJ5IG5hbWUgaW4gcGxhY2Ugb2YgdGhlIHByb3BlcnRpZXMgbWFwIGFyZ3VtZW50LiAqL1xuICAgIFZlbG9jaXR5U3RhdGljLlJlZGlyZWN0cyA9IHt9O1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBQYWNrYWdlZCBSZWRpcmVjdHNcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgLyogc2xpZGVVcCwgc2xpZGVEb3duICovICAgIFsgXCJEb3duXCIsIFwiVXBcIiBdLmZvckVhY2goZnVuY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgICAgIFZlbG9jaXR5U3RhdGljLlJlZGlyZWN0c1tcInNsaWRlXCIgKyBkaXJlY3Rpb25dID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucywgZWxlbWVudHNJbmRleCwgZWxlbWVudHNTaXplLCBlbGVtZW50cywgcmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gX19hc3NpZ24oe30sIG9wdGlvbnMpLCBiZWdpbiA9IG9wdHMuYmVnaW4sIGNvbXBsZXRlID0gb3B0cy5jb21wbGV0ZSwgaW5saW5lVmFsdWVzID0ge30sIGNvbXB1dGVkVmFsdWVzID0ge1xuICAgICAgICAgICAgICAgIGhlaWdodDogXCJcIixcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IFwiXCIsXG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiBcIlwiLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdUb3A6IFwiXCIsXG4gICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogXCJcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvcHRzLmRpc3BsYXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBpc0lubGluZSA9IFZlbG9jaXR5U3RhdGljLmlubGluZVJ4LnRlc3QoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAvKiBTaG93IHRoZSBlbGVtZW50IGJlZm9yZSBzbGlkZURvd24gYmVnaW5zIGFuZCBoaWRlIHRoZSBlbGVtZW50IGFmdGVyIHNsaWRlVXAgY29tcGxldGVzLiAqL1xuICAgICAgICAgICAgICAgIC8qIE5vdGU6IElubGluZSBlbGVtZW50cyBjYW5ub3QgaGF2ZSBkaW1lbnNpb25zIGFuaW1hdGVkLCBzbyB0aGV5J3JlIHJldmVydGVkIHRvIGlubGluZS1ibG9jay4gKi8gICAgICAgICAgICAgICAgb3B0cy5kaXNwbGF5ID0gZGlyZWN0aW9uID09PSBcIkRvd25cIiA/IGlzSW5saW5lID8gXCJpbmxpbmUtYmxvY2tcIiA6IFwiYmxvY2tcIiA6IFwibm9uZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0cy5iZWdpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8qIElmIHRoZSB1c2VyIHBhc3NlZCBpbiBhIGJlZ2luIGNhbGxiYWNrLCBmaXJlIGl0IG5vdy4gKi9cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHNJbmRleCA9PT0gMCAmJiBiZWdpbikge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbi5jYWxsKGVsZW1lbnRzLCBlbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIENhY2hlIHRoZSBlbGVtZW50cycgb3JpZ2luYWwgdmVydGljYWwgZGltZW5zaW9uYWwgcHJvcGVydHkgdmFsdWVzIHNvIHRoYXQgd2UgY2FuIGFuaW1hdGUgYmFjayB0byB0aGVtLiAqLyAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBjb21wdXRlZFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXB1dGVkVmFsdWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5saW5lVmFsdWVzW3Byb3BlcnR5XSA9IGVsZW1lbnQuc3R5bGVbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgICAgICAvKiBGb3Igc2xpZGVEb3duLCB1c2UgZm9yY2VmZWVkaW5nIHRvIGFuaW1hdGUgYWxsIHZlcnRpY2FsIHByb3BlcnRpZXMgZnJvbSAwLiBGb3Igc2xpZGVVcCxcbiAgICAgICAgICAgICAgICAgICAgIHVzZSBmb3JjZWZlZWRpbmcgdG8gc3RhcnQgZnJvbSBjb21wdXRlZCB2YWx1ZXMgYW5kIGFuaW1hdGUgZG93biB0byAwLiAqLyAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSBWZWxvY2l0eVN0YXRpYy5DU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkVmFsdWVzW3Byb3BlcnR5XSA9IGRpcmVjdGlvbiA9PT0gXCJEb3duXCIgPyBbIHByb3BlcnR5VmFsdWUsIDAgXSA6IFsgMCwgcHJvcGVydHlWYWx1ZSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBGb3JjZSB2ZXJ0aWNhbCBvdmVyZmxvdyBjb250ZW50IHRvIGNsaXAgc28gdGhhdCBzbGlkaW5nIHdvcmtzIGFzIGV4cGVjdGVkLiAqLyAgICAgICAgICAgICAgICBpbmxpbmVWYWx1ZXMub3ZlcmZsb3cgPSBlbGVtZW50LnN0eWxlLm92ZXJmbG93O1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9wdHMuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvKiBSZXNldCBlbGVtZW50IHRvIGl0cyBwcmUtc2xpZGUgaW5saW5lIHZhbHVlcyBvbmNlIGl0cyBzbGlkZSBhbmltYXRpb24gaXMgY29tcGxldGUuICovXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gaW5saW5lVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmxpbmVWYWx1ZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IGlubGluZVZhbHVlc1twcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlIHVzZXIgcGFzc2VkIGluIGEgY29tcGxldGUgY2FsbGJhY2ssIGZpcmUgaXQgbm93LiAqLyAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHNJbmRleCA9PT0gZWxlbWVudHNTaXplIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLmNhbGwoZWxlbWVudHMsIGVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyKGVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBWZWxvY2l0eUZuKGVsZW1lbnQsIGNvbXB1dGVkVmFsdWVzLCBvcHRzKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvKiBmYWRlSW4sIGZhZGVPdXQgKi8gICAgWyBcIkluXCIsIFwiT3V0XCIgXS5mb3JFYWNoKGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICAgICAgICBWZWxvY2l0eVN0YXRpYy5SZWRpcmVjdHNbXCJmYWRlXCIgKyBkaXJlY3Rpb25dID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucywgZWxlbWVudHNJbmRleCwgZWxlbWVudHNTaXplLCBlbGVtZW50cywgcHJvbWlzZURhdGEpIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gX19hc3NpZ24oe30sIG9wdGlvbnMpLCBjb21wbGV0ZSA9IG9wdHMuY29tcGxldGUsIHByb3BlcnRpZXNNYXAgPSB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogZGlyZWN0aW9uID09PSBcIkluXCIgPyAxIDogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qIFNpbmNlIHJlZGlyZWN0cyBhcmUgdHJpZ2dlcmVkIGluZGl2aWR1YWxseSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBhbmltYXRlZCBzZXQsIGF2b2lkIHJlcGVhdGVkbHkgdHJpZ2dlcmluZ1xuICAgICAgICAgICAgIGNhbGxiYWNrcyBieSBmaXJpbmcgdGhlbSBvbmx5IHdoZW4gdGhlIGZpbmFsIGVsZW1lbnQgaGFzIGJlZW4gcmVhY2hlZC4gKi8gICAgICAgICAgICBpZiAoZWxlbWVudHNJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG9wdHMuYmVnaW4gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsZW1lbnRzSW5kZXggIT09IGVsZW1lbnRzU2l6ZSAtIDEpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmNvbXBsZXRlID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0cy5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLmNhbGwoZWxlbWVudHMsIGVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VEYXRhLnJlc29sdmVyKGVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBJZiBhIGRpc3BsYXkgd2FzIHBhc3NlZCBpbiwgdXNlIGl0LiBPdGhlcndpc2UsIGRlZmF1bHQgdG8gXCJub25lXCIgZm9yIGZhZGVPdXQgb3IgdGhlIGVsZW1lbnQtc3BlY2lmaWMgZGVmYXVsdCBmb3IgZmFkZUluLiAqL1xuICAgICAgICAgICAgLyogTm90ZTogV2UgYWxsb3cgdXNlcnMgdG8gcGFzcyBpbiBcIm51bGxcIiB0byBza2lwIGRpc3BsYXkgc2V0dGluZyBhbHRvZ2V0aGVyLiAqLyAgICAgICAgICAgIGlmIChvcHRzLmRpc3BsYXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wdHMuZGlzcGxheSA9IGRpcmVjdGlvbiA9PT0gXCJJblwiID8gXCJhdXRvXCIgOiBcIm5vbmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFZlbG9jaXR5Rm4odGhpcywgcHJvcGVydGllc01hcCwgb3B0cyk7XG4gICAgICAgIH07XG4gICAgfSk7XG59KShWZWxvY2l0eVN0YXRpYyB8fCAoVmVsb2NpdHlTdGF0aWMgPSB7fSkpO1xuXG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqXG4gKiBFZmZlY3QgUmVnaXN0cmF0aW9uXG4gKi9cbnZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgLyogQW5pbWF0ZSB0aGUgZXhwYW5zaW9uL2NvbnRyYWN0aW9uIG9mIHRoZSBlbGVtZW50cycgcGFyZW50J3MgaGVpZ2h0IGZvciBJbi9PdXQgZWZmZWN0cy4gKi9cbiAgICBmdW5jdGlvbiBhbmltYXRlUGFyZW50SGVpZ2h0KGVsZW1lbnRzLCBkaXJlY3Rpb24sIHRvdGFsRHVyYXRpb24sIHN0YWdnZXIpIHtcbiAgICAgICAgdmFyIHRvdGFsSGVpZ2h0RGVsdGEgPSAwLCBwYXJlbnROb2RlO1xuICAgICAgICAvKiBTdW0gdGhlIHRvdGFsIGhlaWdodCAoaW5jbHVkaW5nIHBhZGRpbmcgYW5kIG1hcmdpbikgb2YgYWxsIHRhcmdldGVkIGVsZW1lbnRzLiAqL1xuICAgICAgICAvKiBTdW0gdGhlIHRvdGFsIGhlaWdodCAoaW5jbHVkaW5nIHBhZGRpbmcgYW5kIG1hcmdpbikgb2YgYWxsIHRhcmdldGVkIGVsZW1lbnRzLiAqL1xuICAgICAgICAoZWxlbWVudHMubm9kZVR5cGUgPyBbIGVsZW1lbnRzIF0gOiBlbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LCBpKSB7XG4gICAgICAgICAgICBpZiAoc3RhZ2dlcikge1xuICAgICAgICAgICAgICAgIC8qIEluY3JlYXNlIHRoZSB0b3RhbER1cmF0aW9uIGJ5IHRoZSBzdWNjZXNzaXZlIGRlbGF5IGFtb3VudHMgcHJvZHVjZWQgYnkgdGhlIHN0YWdnZXIgb3B0aW9uLiAqL1xuICAgICAgICAgICAgICAgIHRvdGFsRHVyYXRpb24gKz0gaSAqIHN0YWdnZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnROb2RlID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXNUb1N1bSA9IFsgXCJoZWlnaHRcIiwgXCJwYWRkaW5nVG9wXCIsIFwicGFkZGluZ0JvdHRvbVwiLCBcIm1hcmdpblRvcFwiLCBcIm1hcmdpbkJvdHRvbVwiIF07XG4gICAgICAgICAgICAvKiBJZiBib3gtc2l6aW5nIGlzIGJvcmRlci1ib3gsIHRoZSBoZWlnaHQgYWxyZWFkeSBpbmNsdWRlcyBwYWRkaW5nIGFuZCBtYXJnaW4gKi8gICAgICAgICAgICBpZiAoVmVsb2NpdHlTdGF0aWMuQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJib3hTaXppbmdcIikudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSBcImJvcmRlci1ib3hcIikge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNUb1N1bSA9IFsgXCJoZWlnaHRcIiBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcGVydGllc1RvU3VtLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB0b3RhbEhlaWdodERlbHRhICs9IHBhcnNlRmxvYXQoVmVsb2NpdHlTdGF0aWMuQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgcHJvcGVydHkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLyogQW5pbWF0ZSB0aGUgcGFyZW50IGVsZW1lbnQncyBoZWlnaHQgYWRqdXN0bWVudCAod2l0aCBhIHZhcnlpbmcgZHVyYXRpb24gbXVsdGlwbGllciBmb3IgYWVzdGhldGljIGJlbmVmaXRzKS4gKi9cbiAgICAgICAgLy8gVE9ETzogR2V0IHRoaXMgdHlwZXNhZmUgYWdhaW5cbiAgICAgICAgICAgICAgICBWZWxvY2l0eUZuKHBhcmVudE5vZGUsIHtcbiAgICAgICAgICAgIGhlaWdodDogKGRpcmVjdGlvbiA9PT0gXCJJblwiID8gXCIrXCIgOiBcIi1cIikgKyBcIj1cIiArIHRvdGFsSGVpZ2h0RGVsdGFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgcXVldWU6IGZhbHNlLFxuICAgICAgICAgICAgZWFzaW5nOiBcImVhc2UtaW4tb3V0XCIsXG4gICAgICAgICAgICBkdXJhdGlvbjogdG90YWxEdXJhdGlvbiAqIChkaXJlY3Rpb24gPT09IFwiSW5cIiA/IC42IDogMSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qIE5vdGU6IFJlZ2lzdGVyVUkgaXMgYSBsZWdhY3kgbmFtZS4gKi8gICAgZnVuY3Rpb24gUmVnaXN0ZXJFZmZlY3QoZWZmZWN0TmFtZSwgcHJvcGVydGllcykge1xuICAgICAgICAvKiBSZWdpc3RlciBhIGN1c3RvbSByZWRpcmVjdCBmb3IgZWFjaCBlZmZlY3QuICovXG4gICAgICAgIFZlbG9jaXR5U3RhdGljLlJlZGlyZWN0c1tlZmZlY3ROYW1lXSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHJlZGlyZWN0T3B0aW9ucywgZWxlbWVudHNJbmRleCwgZWxlbWVudHNTaXplLCBlbGVtZW50cywgcmVzb2x2ZXIsIGxvb3ApIHtcbiAgICAgICAgICAgIHZhciBmaW5hbEVsZW1lbnQgPSBlbGVtZW50c0luZGV4ID09PSBlbGVtZW50c1NpemUgLSAxLCB0b3RhbER1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIGxvb3AgPSBsb29wIHx8IHByb3BlcnRpZXMubG9vcDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydGllcy5kZWZhdWx0RHVyYXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMuZGVmYXVsdER1cmF0aW9uID0gcHJvcGVydGllcy5kZWZhdWx0RHVyYXRpb24uY2FsbChlbGVtZW50cywgZWxlbWVudHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmRlZmF1bHREdXJhdGlvbiA9IHBhcnNlRmxvYXQocHJvcGVydGllcy5kZWZhdWx0RHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogR2V0IHRoZSB0b3RhbCBkdXJhdGlvbiB1c2VkLCBzbyB3ZSBjYW4gc2hhcmUgaXQgb3V0IHdpdGggZXZlcnl0aGluZyB0aGF0IGRvZXNuJ3QgaGF2ZSBhIGR1cmF0aW9uICovICAgICAgICAgICAgZm9yICh2YXIgY2FsbEluZGV4ID0gMDsgY2FsbEluZGV4IDwgcHJvcGVydGllcy5jYWxscy5sZW5ndGg7IGNhbGxJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uUGVyY2VudGFnZSA9IHByb3BlcnRpZXMuY2FsbHNbY2FsbEluZGV4XVsxXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGR1cmF0aW9uUGVyY2VudGFnZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3RhbER1cmF0aW9uICs9IGR1cmF0aW9uUGVyY2VudGFnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2hhcmVEdXJhdGlvbiA9IHRvdGFsRHVyYXRpb24gPj0gMSA/IDAgOiBwcm9wZXJ0aWVzLmNhbGxzLmxlbmd0aCA/ICgxIC0gdG90YWxEdXJhdGlvbikgLyBwcm9wZXJ0aWVzLmNhbGxzLmxlbmd0aCA6IDE7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uKGNhbGxJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsID0gcHJvcGVydGllcy5jYWxsc1tjYWxsSW5kZXhdLCBwcm9wZXJ0eU1hcCA9IGNhbGxbMF0sIHJlZGlyZWN0RHVyYXRpb24gPSAxZTMsIGR1cmF0aW9uUGVyY2VudGFnZSA9IGNhbGxbMV0sIGNhbGxPcHRpb25zID0gY2FsbFsyXSB8fCB7fSwgb3B0cyA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdE9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdER1cmF0aW9uID0gcmVkaXJlY3RPcHRpb25zLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcGVydGllcy5kZWZhdWx0RHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdER1cmF0aW9uID0gcHJvcGVydGllcy5kZWZhdWx0RHVyYXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIEFzc2lnbiB0aGUgd2hpdGVsaXN0ZWQgcGVyLWNhbGwgb3B0aW9ucy4gKi8gICAgICAgICAgICAgICAgb3B0cy5kdXJhdGlvbiA9IHJlZGlyZWN0RHVyYXRpb24gKiAodHlwZW9mIGR1cmF0aW9uUGVyY2VudGFnZSA9PT0gXCJudW1iZXJcIiA/IGR1cmF0aW9uUGVyY2VudGFnZSA6IHNoYXJlRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIG9wdHMucXVldWUgPSByZWRpcmVjdE9wdGlvbnMucXVldWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICBvcHRzLmVhc2luZyA9IGNhbGxPcHRpb25zLmVhc2luZyB8fCBcImVhc2VcIjtcbiAgICAgICAgICAgICAgICBvcHRzLmRlbGF5ID0gcGFyc2VGbG9hdChjYWxsT3B0aW9ucy5kZWxheSkgfHwgMDtcbiAgICAgICAgICAgICAgICBvcHRzLmxvb3AgPSAhcHJvcGVydGllcy5sb29wICYmIGNhbGxPcHRpb25zLmxvb3A7XG4gICAgICAgICAgICAgICAgb3B0cy5jYWNoZSA9IGNhbGxPcHRpb25zLmNhY2hlIHx8IHRydWU7XG4gICAgICAgICAgICAgICAgLyogU3BlY2lhbCBwcm9jZXNzaW5nIGZvciB0aGUgZmlyc3QgZWZmZWN0IGNhbGwuICovICAgICAgICAgICAgICAgIGlmIChjYWxsSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLyogSWYgYSBkZWxheSB3YXMgcGFzc2VkIGludG8gdGhlIHJlZGlyZWN0LCBjb21iaW5lIGl0IHdpdGggdGhlIGZpcnN0IGNhbGwncyBkZWxheS4gKi9cbiAgICAgICAgICAgICAgICAgICAgb3B0cy5kZWxheSArPSBwYXJzZUZsb2F0KHJlZGlyZWN0T3B0aW9ucy5kZWxheSkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuYmVnaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBPbmx5IHRyaWdnZXIgYSBiZWdpbiBjYWxsYmFjayBvbiB0aGUgZmlyc3QgZWZmZWN0IGNhbGwgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0LiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdE9wdGlvbnMuYmVnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RPcHRpb25zLmJlZ2luLmNhbGwoZWxlbWVudHMsIGVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGVmZmVjdE5hbWUubWF0Y2goLyhJbnxPdXQpJC8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIE1ha2UgXCJpblwiIHRyYW5zaXRpb25pbmcgZWxlbWVudHMgaW52aXNpYmxlIGltbWVkaWF0ZWx5IHNvIHRoYXQgdGhlcmUncyBubyBGT1VDIGJldHdlZW4gbm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgZmlyc3QgUkFGIHRpY2suICovICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gJiYgZGlyZWN0aW9uWzBdID09PSBcIkluXCIgJiYgcHJvcGVydHlNYXAub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbGVtZW50cy5ub2RlVHlwZSA/IFsgZWxlbWVudHMgXSA6IGVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLkNTUy5zZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIE9ubHkgdHJpZ2dlciBhbmltYXRlUGFyZW50SGVpZ2h0KCkgaWYgd2UncmUgdXNpbmcgYW4gSW4vT3V0IHRyYW5zaXRpb24uICovICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdE9wdGlvbnMuYW5pbWF0ZVBhcmVudEhlaWdodCAmJiBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZVBhcmVudEhlaWdodChlbGVtZW50cywgZGlyZWN0aW9uWzBdLCByZWRpcmVjdER1cmF0aW9uICsgb3B0cy5kZWxheSwgcmVkaXJlY3RPcHRpb25zLnN0YWdnZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyogSWYgdGhlIHVzZXIgaXNuJ3Qgb3ZlcnJpZGluZyB0aGUgZGlzcGxheSBvcHRpb24sIGRlZmF1bHQgdG8gXCJhdXRvXCIgZm9yIFwiSW5cIi1zdWZmaXhlZCB0cmFuc2l0aW9ucy4gKi9cbiAgICAgICAgICAgICAgICAgICAgLy9cdFx0XHRcdFx0aWYgKHJlZGlyZWN0T3B0aW9ucy5kaXNwbGF5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vXHRcdFx0XHRcdFx0aWYgKHJlZGlyZWN0T3B0aW9ucy5kaXNwbGF5ICE9PSB1bmRlZmluZWQgJiYgcmVkaXJlY3RPcHRpb25zLmRpc3BsYXkgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vXHRcdFx0XHRcdFx0XHRvcHRzLmRpc3BsYXkgPSByZWRpcmVjdE9wdGlvbnMuZGlzcGxheTtcbiAgICAgICAgICAgICAgICAgICAgLy9cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKC9JbiQvLnRlc3QoZWZmZWN0TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cdFx0XHRcdFx0XHRcdC8qIElubGluZSBlbGVtZW50cyBjYW5ub3QgYmUgc3ViamVjdGVkIHRvIHRyYW5zZm9ybXMsIHNvIHdlIHN3aXRjaCB0aGVtIHRvIGlubGluZS1ibG9jay4gKi9cbiAgICAgICAgICAgICAgICAgICAgLy9cdFx0XHRcdFx0XHRcdGxldCBkZWZhdWx0RGlzcGxheSA9IENTUy5WYWx1ZXMuZ2V0RGlzcGxheVR5cGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIC8vXHRcdFx0XHRcdFx0XHRvcHRzLmRpc3BsYXkgPSAoZGVmYXVsdERpc3BsYXkgPT09IFwiaW5saW5lXCIpID8gXCJpbmxpbmUtYmxvY2tcIiA6IGRlZmF1bHREaXNwbGF5O1xuICAgICAgICAgICAgICAgICAgICAvL1x0XHRcdFx0XHRcdH1cbiAgICAgICAgICAgICAgICAgICAgLy9cdFx0XHRcdFx0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdE9wdGlvbnMudmlzaWJpbGl0eSAmJiByZWRpcmVjdE9wdGlvbnMudmlzaWJpbGl0eSAhPT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy52aXNpYmlsaXR5ID0gcmVkaXJlY3RPcHRpb25zLnZpc2liaWxpdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogU3BlY2lhbCBwcm9jZXNzaW5nIGZvciB0aGUgbGFzdCBlZmZlY3QgY2FsbC4gKi8gICAgICAgICAgICAgICAgaWYgKGNhbGxJbmRleCA9PT0gcHJvcGVydGllcy5jYWxscy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIEFwcGVuZCBwcm9taXNlIHJlc29sdmluZyBvbnRvIHRoZSB1c2VyJ3MgcmVkaXJlY3QgY2FsbGJhY2suICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmplY3RGaW5hbENhbGxiYWNrc18xID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlZGlyZWN0T3B0aW9ucy5kaXNwbGF5ID09PSB1bmRlZmluZWQgfHwgcmVkaXJlY3RPcHRpb25zLmRpc3BsYXkgPT09IFwibm9uZVwiKSAmJiAvT3V0JC8udGVzdChlZmZlY3ROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbGVtZW50cy5ub2RlVHlwZSA/IFsgZWxlbWVudHMgXSA6IGVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVsb2NpdHlTdGF0aWMuQ1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdE9wdGlvbnMuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcmVjdE9wdGlvbnMuY29tcGxldGUuY2FsbChlbGVtZW50cywgZWxlbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXIoZWxlbWVudHMgfHwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb29wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVsb2NpdHlTdGF0aWMuUmVkaXJlY3RzW2VmZmVjdE5hbWVdKGVsZW1lbnQsIHJlZGlyZWN0T3B0aW9ucywgZWxlbWVudHNJbmRleCwgZWxlbWVudHNTaXplLCBlbGVtZW50cywgcmVzb2x2ZXIsIGxvb3AgPT09IHRydWUgPyB0cnVlIDogTWF0aC5tYXgoMCwgbG9vcCAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnJlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcmVzZXRQcm9wZXJ0eSBpbiBwcm9wZXJ0aWVzLnJlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvcGVydGllcy5yZXNldC5oYXNPd25Qcm9wZXJ0eShyZXNldFByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2V0VmFsdWUgPSBwcm9wZXJ0aWVzLnJlc2V0W3Jlc2V0UHJvcGVydHldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBGb3JtYXQgZWFjaCBub24tYXJyYXkgdmFsdWUgaW4gdGhlIHJlc2V0IHByb3BlcnR5IG1hcCB0byBbIHZhbHVlLCB2YWx1ZSBdIHNvIHRoYXQgY2hhbmdlcyBhcHBseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1tZWRpYXRlbHkgYW5kIERPTSBxdWVyeWluZyBpcyBhdm9pZGVkICh2aWEgZm9yY2VmZWVkaW5nKS4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogTm90ZTogRG9uJ3QgZm9yY2VmZWVkIGhvb2tzLCBvdGhlcndpc2UgdGhlaXIgaG9vayByb290cyB3aWxsIGJlIGRlZmF1bHRlZCB0byB0aGVpciBudWxsIHZhbHVlcy4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRml4IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cdFx0XHRcdFx0XHRcdFx0aWYgKENTUy5Ib29rcy5yZWdpc3RlcmVkW3Jlc2V0UHJvcGVydHldID09PSB1bmRlZmluZWQgJiYgKHR5cGVvZiByZXNldFZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiByZXNldFZhbHVlID09PSBcIm51bWJlclwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1x0XHRcdFx0XHRcdFx0XHRcdHByb3BlcnRpZXMucmVzZXRbcmVzZXRQcm9wZXJ0eV0gPSBbcHJvcGVydGllcy5yZXNldFtyZXNldFByb3BlcnR5XSwgcHJvcGVydGllcy5yZXNldFtyZXNldFByb3BlcnR5XV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXHRcdFx0XHRcdFx0XHRcdH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFNvIHRoYXQgdGhlIHJlc2V0IHZhbHVlcyBhcmUgYXBwbGllZCBpbnN0YW50bHkgdXBvbiB0aGUgbmV4dCByQUYgdGljaywgdXNlIGEgemVybyBkdXJhdGlvbiBhbmQgcGFyYWxsZWwgcXVldWVpbmcuICovICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNldE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFNpbmNlIHRoZSByZXNldCBvcHRpb24gdXNlcyB1cCB0aGUgY29tcGxldGUgY2FsbGJhY2ssIHdlIHRyaWdnZXIgdGhlIHVzZXIncyBjb21wbGV0ZSBjYWxsYmFjayBhdCB0aGUgZW5kIG9mIG91cnMuICovICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRPcHRpb25zLmNvbXBsZXRlID0gaW5qZWN0RmluYWxDYWxsYmFja3NfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVsb2NpdHlGbihlbGVtZW50LCBwcm9wZXJ0aWVzLnJlc2V0LCByZXNldE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIE9ubHkgdHJpZ2dlciB0aGUgdXNlcidzIGNvbXBsZXRlIGNhbGxiYWNrIG9uIHRoZSBsYXN0IGVmZmVjdCBjYWxsIHdpdGggdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgc2V0LiAqLyAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmluYWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0RmluYWxDYWxsYmFja3NfMSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVkaXJlY3RPcHRpb25zLnZpc2liaWxpdHkgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMudmlzaWJpbGl0eSA9IHJlZGlyZWN0T3B0aW9ucy52aXNpYmlsaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFZlbG9jaXR5Rm4oZWxlbWVudCwgcHJvcGVydHlNYXAsIG9wdHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIGVmZmVjdCdzIGNhbGwgYXJyYXkuICovICAgICAgICAgICAgZm9yICh2YXIgY2FsbEluZGV4ID0gMDsgY2FsbEluZGV4IDwgcHJvcGVydGllcy5jYWxscy5sZW5ndGg7IGNhbGxJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgX2xvb3BfMShjYWxsSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBSZXR1cm4gdGhlIFZlbG9jaXR5IG9iamVjdCBzbyB0aGF0IFJlZ2lzdGVyVUkgY2FsbHMgY2FuIGJlIGNoYWluZWQuICovICAgICAgICByZXR1cm4gVmVsb2NpdHlGbjtcbiAgICB9XG4gICAgVmVsb2NpdHlTdGF0aWMuUmVnaXN0ZXJFZmZlY3QgPSBSZWdpc3RlckVmZmVjdDtcbn0pKFZlbG9jaXR5U3RhdGljIHx8IChWZWxvY2l0eVN0YXRpYyA9IHt9KSk7XG5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICpcbiAqIFNlcXVlbmNlIFJ1bm5pbmdcbiAqL1xuLyoqXG4gKiBQZXJmb3JtIGEgZGVlcCBjb3B5IG9mIGFuIG9iamVjdCAtIGFsc28gY29waWVzIGNoaWxkcmVuIHNvIHRoZXkncmUgbm90XG4gKiBnb2luZyB0byBiZSBhZmZlY3RlZCBieSBjaGFuZ2luZyBvcmlnaW5hbC5cbiAqL1xuZnVuY3Rpb24gX2RlZXBDb3B5T2JqZWN0KHRhcmdldCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3RcIik7XG4gICAgfVxuICAgIHZhciB0byA9IE9iamVjdCh0YXJnZXQpLCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gICAgdmFyIHNvdXJjZTtcbiAgICB3aGlsZSAoc291cmNlID0gc291cmNlcy5zaGlmdCgpKSB7XG4gICAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZGVlcENvcHlPYmplY3QodG9ba2V5XSA9IFtdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kZWVwQ29weU9iamVjdCh0b1trZXldID0ge30sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG87XG59XG5cbnZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgLyogTm90ZTogU2VxdWVuY2UgY2FsbHMgbXVzdCB1c2UgVmVsb2NpdHkncyBzaW5nbGUtb2JqZWN0IGFyZ3VtZW50cyBzeW50YXguICovXG4gICAgZnVuY3Rpb24gUnVuU2VxdWVuY2Uob3JpZ2luYWxTZXF1ZW5jZSkge1xuICAgICAgICB2YXIgc2VxdWVuY2UgPSBfZGVlcENvcHlPYmplY3QoW10sIG9yaWdpbmFsU2VxdWVuY2UpO1xuICAgICAgICBpZiAoc2VxdWVuY2UubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgc2VxdWVuY2UucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24oY3VycmVudENhbGwsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dENhbGwgPSBzZXF1ZW5jZVtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFBhcmFsbGVsIHNlcXVlbmNlIGNhbGxzIChpbmRpY2F0ZWQgdmlhIHNlcXVlbmNlUXVldWU6ZmFsc2UpIGFyZSB0cmlnZ2VyZWRcbiAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBwcmV2aW91cyBjYWxsJ3MgYmVnaW4gY2FsbGJhY2suIE90aGVyd2lzZSwgY2hhaW5lZCBjYWxscyBhcmUgbm9ybWFsbHkgdHJpZ2dlcmVkXG4gICAgICAgICAgICAgICAgICAgICBpbiB0aGUgcHJldmlvdXMgY2FsbCdzIGNvbXBsZXRlIGNhbGxiYWNrLiAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudENhbGxPcHRpb25zID0gY3VycmVudENhbGwubyB8fCBjdXJyZW50Q2FsbC5vcHRpb25zLCBuZXh0Q2FsbE9wdGlvbnMgPSBuZXh0Q2FsbC5vIHx8IG5leHRDYWxsLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1pbmcgPSBjdXJyZW50Q2FsbE9wdGlvbnMgJiYgY3VycmVudENhbGxPcHRpb25zLnNlcXVlbmNlUXVldWUgPT09IGZhbHNlID8gXCJiZWdpblwiIDogXCJjb21wbGV0ZVwiLCBjYWxsYmFja09yaWdpbmFsXzEgPSBuZXh0Q2FsbE9wdGlvbnMgJiYgbmV4dENhbGxPcHRpb25zW3RpbWluZ10sIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1t0aW1pbmddID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENhbGxFbGVtZW50cyA9IG5leHRDYWxsLmUgfHwgbmV4dENhbGwuZWxlbWVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBuZXh0Q2FsbEVsZW1lbnRzLm5vZGVUeXBlID8gWyBuZXh0Q2FsbEVsZW1lbnRzIF0gOiBuZXh0Q2FsbEVsZW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrT3JpZ2luYWxfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrT3JpZ2luYWxfMS5jYWxsKGVsZW1lbnRzLCBlbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBWZWxvY2l0eUZuKGN1cnJlbnRDYWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDYWxsLm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDYWxsLm8gPSBfX2Fzc2lnbih7fSwgbmV4dENhbGxPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDYWxsLm9wdGlvbnMgPSBfX2Fzc2lnbih7fSwgbmV4dENhbGxPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VxdWVuY2UucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIFZlbG9jaXR5Rm4oc2VxdWVuY2VbMF0pO1xuICAgIH1cbiAgICBWZWxvY2l0eVN0YXRpYy5SdW5TZXF1ZW5jZSA9IFJ1blNlcXVlbmNlO1xufSkoVmVsb2NpdHlTdGF0aWMgfHwgKFZlbG9jaXR5U3RhdGljID0ge30pKTtcblxuLy8vPHJlZmVyZW5jZSBwYXRoPVwic3RhdGUudHNcIiAvPlxuLypcbiAqIFZlbG9jaXR5SlMub3JnIChDKSAyMDE0LTIwMTcgSnVsaWFuIFNoYXBpcm8uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGRldGFpbHMuXG4gKlxuICogVGlja1xuICovXG52YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIGJlZ2luIG1ldGhvZCBvZiBhbiBhbmltYXRpb24gaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbiBzbyBpdCBjYW5cbiAgICAgKiBiZW5lZml0IGZyb20gSklUIGNvbXBpbGluZyB3aGlsZSBzdGlsbCBoYXZpbmcgYSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsbEJlZ2luKGFjdGl2ZUNhbGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IGFjdGl2ZUNhbGwuZWxlbWVudHM7XG4gICAgICAgICAgICBhY3RpdmVDYWxsLm9wdGlvbnMuYmVnaW4uY2FsbChlbGVtZW50cywgZWxlbWVudHMsIGFjdGl2ZUNhbGwpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFZlbG9jaXR5U3RhdGljLmNhbGxCZWdpbiA9IGNhbGxCZWdpbjtcbiAgICAvKipcbiAgICAgKiBDYWxsIHRoZSBwcm9ncmVzcyBtZXRob2Qgb2YgYW4gYW5pbWF0aW9uIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24gc28gaXQgY2FuXG4gICAgICogYmVuZWZpdCBmcm9tIEpJVCBjb21waWxpbmcgd2hpbGUgc3RpbGwgaGF2aW5nIGEgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAqLyAgICBmdW5jdGlvbiBjYWxsUHJvZ3Jlc3MoYWN0aXZlQ2FsbCwgdGltZUN1cnJlbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IGFjdGl2ZUNhbGwuZWxlbWVudHMsIHBlcmNlbnRDb21wbGV0ZSA9IGFjdGl2ZUNhbGwucGVyY2VudENvbXBsZXRlLCBvcHRpb25zID0gYWN0aXZlQ2FsbC5vcHRpb25zLCB0d2VlblZhbHVlID0gYWN0aXZlQ2FsbC50d2VlbjtcbiAgICAgICAgICAgIGFjdGl2ZUNhbGwub3B0aW9ucy5wcm9ncmVzcy5jYWxsKGVsZW1lbnRzLCBlbGVtZW50cywgcGVyY2VudENvbXBsZXRlLCBNYXRoLm1heCgwLCBhY3RpdmVDYWxsLnRpbWVTdGFydCArIChhY3RpdmVDYWxsLmR1cmF0aW9uICE9IG51bGwgPyBhY3RpdmVDYWxsLmR1cmF0aW9uIDogb3B0aW9ucy5kdXJhdGlvbiAhPSBudWxsID8gb3B0aW9ucy5kdXJhdGlvbiA6IFZlbG9jaXR5U3RhdGljLmRlZmF1bHRzLmR1cmF0aW9uKSAtIHRpbWVDdXJyZW50KSwgdHdlZW5WYWx1ZSAhPT0gdW5kZWZpbmVkID8gdHdlZW5WYWx1ZSA6IFN0cmluZyhwZXJjZW50Q29tcGxldGUgKiAxMDApLCBhY3RpdmVDYWxsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZmlyc3RQcm9ncmVzcywgZmlyc3RDb21wbGV0ZTtcbiAgICBmdW5jdGlvbiBhc3luY0NhbGxiYWNrcygpIHtcbiAgICAgICAgdmFyIGFjdGl2ZUNhbGwsIG5leHRDYWxsO1xuICAgICAgICAvLyBDYWxsYmFja3MgYW5kIGNvbXBsZXRlIHRoYXQgbWlnaHQgcmVhZCB0aGUgRE9NIGFnYWluLlxuICAgICAgICAvLyBQcm9ncmVzcyBjYWxsYmFja1xuICAgICAgICAgICAgICAgIGZvciAoYWN0aXZlQ2FsbCA9IGZpcnN0UHJvZ3Jlc3M7IGFjdGl2ZUNhbGw7IGFjdGl2ZUNhbGwgPSBuZXh0Q2FsbCkge1xuICAgICAgICAgICAgbmV4dENhbGwgPSBhY3RpdmVDYWxsLl9uZXh0UHJvZ3Jlc3M7XG4gICAgICAgICAgICAvLyBQYXNzIHRvIGFuIGV4dGVybmFsIGZuIHdpdGggYSB0cnkvY2F0Y2ggYmxvY2sgZm9yIG9wdGltaXNhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb2dyZXNzKGFjdGl2ZUNhbGwsIFZlbG9jaXR5U3RhdGljLmxhc3RUaWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wbGV0ZSBhbmltYXRpb25zLCBpbmNsdWRpbmcgY29tcGxldGUgY2FsbGJhY2sgb3IgbG9vcGluZ1xuICAgICAgICAgICAgICAgIGZvciAoYWN0aXZlQ2FsbCA9IGZpcnN0Q29tcGxldGU7IGFjdGl2ZUNhbGw7IGFjdGl2ZUNhbGwgPSBuZXh0Q2FsbCkge1xuICAgICAgICAgICAgbmV4dENhbGwgPSBhY3RpdmVDYWxsLl9uZXh0Q29tcGxldGU7XG4gICAgICAgICAgICAvKiBJZiB0aGlzIGNhbGwgaGFzIGZpbmlzaGVkIHR3ZWVuaW5nLCBwYXNzIGl0IHRvIGNvbXBsZXRlKCkgdG8gaGFuZGxlIGNhbGwgY2xlYW51cC4gKi8gICAgICAgICAgICBWZWxvY2l0eVN0YXRpYy5jb21wbGV0ZUNhbGwoYWN0aXZlQ2FsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqKioqKioqKioqKioqXG4gICAgIFRpbWluZ1xuICAgICAqKioqKioqKioqKioqKi8gICAgdmFyIEZSQU1FX1RJTUUgPSAxZTMgLyA2MCxcbiAgICAvKipcbiAgICAqIFNoaW0gZm9yIHdpbmRvdy5wZXJmb3JtYW5jZSBpbiBjYXNlIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAqL1xuICAgIHBlcmZvcm1hbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwZXJmID0gd2luZG93LnBlcmZvcm1hbmNlIHx8IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHBlcmYubm93ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBub3dPZmZzZXRfMSA9IHBlcmYudGltaW5nICYmIHBlcmYudGltaW5nLm5hdmlnYXRpb25TdGFydCA/IHBlcmYudGltaW5nLm5hdmlnYXRpb25TdGFydCA6IF9ub3coKTtcbiAgICAgICAgICAgIHBlcmYubm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ub3coKSAtIG5vd09mZnNldF8xO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGVyZjtcbiAgICB9KCksXG4gICAgLyoqXG4gICAgICogUHJveHkgZnVuY3Rpb24gZm9yIHdoZW4gckFGIGlzIG5vdCBhdmFpbGFibGUgLSB0cnkgdG8gYmUgYXMgYWNjdXJhdGVcbiAgICAgKiBhcyBwb3NzaWJsZSB3aXRoIHRoZSBzZXRUaW1lb3V0IGNhbGxzLCBob3dldmVyIHRoZXkgYXJlIGZhciBsZXNzXG4gICAgICogYWNjdXJhdGUgdGhhbiByQUYgY2FuIGJlIC0gc28gdHJ5IG5vdCB0byB1c2Ugbm9ybWFsbHkgKHVubGVzcyB0aGUgdGFiXG4gICAgICogaXMgaW4gdGhlIGJhY2tncm91bmQpLlxuICAgICAqL1xuICAgIHJBRlByb3h5ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJyQUZQcm94eVwiLCBNYXRoLm1heCgwLCBGUkFNRV9USU1FIC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gVmVsb2NpdHlTdGF0aWMubGFzdFRpY2spKSwgcGVyZm9ybWFuY2Uubm93KCksIFZlbG9jaXR5U3RhdGljLmxhc3RUaWNrLCBGUkFNRV9USU1FKTtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgIH0sIE1hdGgubWF4KDAsIEZSQU1FX1RJTUUgLSAocGVyZm9ybWFuY2Uubm93KCkgLSBWZWxvY2l0eVN0YXRpYy5sYXN0VGljaykpKTtcbiAgICB9LFxuICAgIC8qIHJBRiBzaGltLiBHaXN0OiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qdWxpYW5zaGFwaXJvLzk0OTc1MTMgKi9cbiAgICByQUZTaGltID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCByQUZQcm94eTtcbiAgICAvKipcbiAgICAgKiBUaGUgdGlja2VyIGZ1bmN0aW9uIGJlaW5nIHVzZWQsIGVpdGhlciByQUYsIG9yIGEgZnVuY3Rpb24gdGhhdFxuICAgICAqIGVtdWxhdGVzIGl0LlxuICAgICAqLyAgICB2YXIgdGlja2VyID0gZG9jdW1lbnQuaGlkZGVuID8gckFGUHJveHkgOiByQUZTaGltO1xuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lIHRoYXQgdGhlIGxhc3QgYW5pbWF0aW9uIGZyYW1lIHJhbiBhdC4gU2V0IGZyb20gdGljaygpLCBhbmQgdXNlZFxuICAgICAqIGZvciBtaXNzaW5nIHJBRiAoaWUsIHdoZW4gbm90IGluIGZvY3VzIGV0YykuXG4gICAgICovICAgIFZlbG9jaXR5U3RhdGljLmxhc3RUaWNrID0gMDtcbiAgICAvKiBJbmFjdGl2ZSBicm93c2VyIHRhYnMgcGF1c2UgckFGLCB3aGljaCByZXN1bHRzIGluIGFsbCBhY3RpdmUgYW5pbWF0aW9ucyBpbW1lZGlhdGVseSBzcHJpbnRpbmcgdG8gdGhlaXIgY29tcGxldGlvbiBzdGF0ZXMgd2hlbiB0aGUgdGFiIHJlZm9jdXNlcy5cbiAgICAgVG8gZ2V0IGFyb3VuZCB0aGlzLCB3ZSBkeW5hbWljYWxseSBzd2l0Y2ggckFGIHRvIHNldFRpbWVvdXQgKHdoaWNoIHRoZSBicm93c2VyICpkb2Vzbid0KiBwYXVzZSkgd2hlbiB0aGUgdGFiIGxvc2VzIGZvY3VzLiBXZSBza2lwIHRoaXMgZm9yIG1vYmlsZVxuICAgICBkZXZpY2VzIHRvIGF2b2lkIHdhc3RpbmcgYmF0dGVyeSBwb3dlciBvbiBpbmFjdGl2ZSB0YWJzLiAqL1xuICAgIC8qIE5vdGU6IFRhYiBmb2N1cyBkZXRlY3Rpb24gZG9lc24ndCB3b3JrIG9uIG9sZGVyIHZlcnNpb25zIG9mIElFLCBidXQgdGhhdCdzIG9rYXkgc2luY2UgdGhleSBkb24ndCBzdXBwb3J0IHJBRiB0byBiZWdpbiB3aXRoLiAqLyAgICBpZiAoIVZlbG9jaXR5U3RhdGljLlN0YXRlLmlzTW9iaWxlICYmIGRvY3VtZW50LmhpZGRlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIGZ1bmN0aW9uIHVwZGF0ZVRpY2tlcihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhpZGRlbiA9IGRvY3VtZW50LmhpZGRlbjtcbiAgICAgICAgICAgIHRpY2tlciA9IGhpZGRlbiA/IHJBRlByb3h5IDogckFGU2hpbTtcbiAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodGljaywgMmUzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciB0aWNraW5nO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCBvbiBldmVyeSB0aWNrLCBwcmVmZXJhYmx5IHRocm91Z2ggckFGLiBUaGlzIGlzIHJlcG9uc2libGUgZm9yXG4gICAgICogaW5pdGlhbGlzaW5nIGFueSBuZXcgYW5pbWF0aW9ucywgdGhlbiBzdGFydGluZyBhbnkgdGhhdCBuZWVkIHN0YXJ0aW5nLlxuICAgICAqIEZpbmFsbHkgaXQgd2lsbCBleHBhbmQgYW55IHR3ZWVucyBhbmQgc2V0IHRoZSBwcm9wZXJ0aWVzIHJlbGF0aW5nIHRvXG4gICAgICogdGhlbS4gSWYgdGhlcmUgYXJlIGFueSBjYWxsYmFja3MgcmVsYXRpbmcgdG8gdGhlIGFuaW1hdGlvbnMgdGhlbiB0aGV5XG4gICAgICogd2lsbCBhdHRlbXB0IHRvIGNhbGwgYXQgdGhlIGVuZCAod2l0aCB0aGUgZXhjZXB0aW9uIG9mIFwiYmVnaW5cIikuXG4gICAgICovICAgIGZ1bmN0aW9uIHRpY2sodGltZXN0YW1wKSB7XG4gICAgICAgIGlmICh0aWNraW5nKSB7XG4gICAgICAgICAgICAvLyBTaG91bGQgbmV2ZXIgaGFwcGVuIC0gYnV0IGlmIHdlJ3ZlIHN3YXBwZWQgYmFjayBmcm9tIGhpZGRlbiB0b1xuICAgICAgICAgICAgLy8gdmlzaWJpbGUgdGhlbiB3ZSB3YW50IHRvIG1ha2Ugc3VyZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpY2tpbmcgPSB0cnVlO1xuICAgICAgICAvKiBBbiBlbXB0eSB0aW1lc3RhbXAgYXJndW1lbnQgaW5kaWNhdGVzIHRoYXQgdGhpcyBpcyB0aGUgZmlyc3QgdGljayBvY2N1cmVuY2Ugc2luY2UgdGlja2luZyB3YXMgdHVybmVkIG9uLlxuICAgICAgICAgV2UgbGV2ZXJhZ2UgdGhpcyBtZXRhZGF0YSB0byBmdWxseSBpZ25vcmUgdGhlIGZpcnN0IHRpY2sgcGFzcyBzaW5jZSBSQUYncyBpbml0aWFsIHBhc3MgaXMgZmlyZWQgd2hlbmV2ZXJcbiAgICAgICAgIHRoZSBicm93c2VyJ3MgbmV4dCB0aWNrIHN5bmMgdGltZSBvY2N1cnMsIHdoaWNoIHJlc3VsdHMgaW4gdGhlIGZpcnN0IGVsZW1lbnRzIHN1YmplY3RlZCB0byBWZWxvY2l0eVxuICAgICAgICAgY2FsbHMgYmVpbmcgYW5pbWF0ZWQgb3V0IG9mIHN5bmMgd2l0aCBhbnkgZWxlbWVudHMgYW5pbWF0ZWQgaW1tZWRpYXRlbHkgdGhlcmVhZnRlci4gSW4gc2hvcnQsIHdlIGlnbm9yZVxuICAgICAgICAgdGhlIGZpcnN0IFJBRiB0aWNrIHBhc3Mgc28gdGhhdCBlbGVtZW50cyBiZWluZyBpbW1lZGlhdGVseSBjb25zZWN1dGl2ZWx5IGFuaW1hdGVkIC0tIGluc3RlYWQgb2Ygc2ltdWx0YW5lb3VzbHkgYW5pbWF0ZWRcbiAgICAgICAgIGJ5IHRoZSBzYW1lIFZlbG9jaXR5IGNhbGwgLS0gYXJlIHByb3Blcmx5IGJhdGNoZWQgaW50byB0aGUgc2FtZSBpbml0aWFsIFJBRiB0aWNrIGFuZCBjb25zZXF1ZW50bHkgcmVtYWluIGluIHN5bmMgdGhlcmVhZnRlci4gKi8gICAgICAgIGlmICh0aW1lc3RhbXApIHtcbiAgICAgICAgICAgIC8qIFdlIG5vcm1hbGx5IHVzZSBSQUYncyBoaWdoIHJlc29sdXRpb24gdGltZXN0YW1wIGJ1dCBhcyBpdCBjYW4gYmUgc2lnbmlmaWNhbnRseSBvZmZzZXQgd2hlbiB0aGUgYnJvd3NlciBpc1xuICAgICAgICAgICAgIHVuZGVyIGhpZ2ggc3RyZXNzIHdlIGdpdmUgdGhlIG9wdGlvbiBmb3IgY2hvcHBpbmVzcyBvdmVyIGFsbG93aW5nIHRoZSBicm93c2VyIHRvIGRyb3AgaHVnZSBjaHVua3Mgb2YgZnJhbWVzLlxuICAgICAgICAgICAgIFdlIHVzZSBwZXJmb3JtYW5jZS5ub3coKSBhbmQgc2hpbSBpdCBpZiBpdCBkb2Vzbid0IGV4aXN0IGZvciB3aGVuIHRoZSB0YWIgaXMgaGlkZGVuLiAqL1xuICAgICAgICAgICAgdmFyIHRpbWVDdXJyZW50ID0gdGltZXN0YW1wICYmIHRpbWVzdGFtcCAhPT0gdHJ1ZSA/IHRpbWVzdGFtcCA6IHBlcmZvcm1hbmNlLm5vdygpLCBkZWx0YVRpbWUgPSBWZWxvY2l0eVN0YXRpYy5sYXN0VGljayA/IHRpbWVDdXJyZW50IC0gVmVsb2NpdHlTdGF0aWMubGFzdFRpY2sgOiBGUkFNRV9USU1FLCBkZWZhdWx0U3BlZWQgPSBWZWxvY2l0eVN0YXRpYy5kZWZhdWx0cy5zcGVlZCwgZGVmYXVsdEVhc2luZyA9IFZlbG9jaXR5U3RhdGljLmRlZmF1bHRzLmVhc2luZywgZGVmYXVsdER1cmF0aW9uID0gVmVsb2NpdHlTdGF0aWMuZGVmYXVsdHMuZHVyYXRpb247XG4gICAgICAgICAgICB2YXIgYWN0aXZlQ2FsbCA9IHZvaWQgMCwgbmV4dENhbGwgPSB2b2lkIDAsIGxhc3RQcm9ncmVzcyA9IHZvaWQgMCwgbGFzdENvbXBsZXRlID0gdm9pZCAwO1xuICAgICAgICAgICAgZmlyc3RQcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICBmaXJzdENvbXBsZXRlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChkZWx0YVRpbWUgPj0gVmVsb2NpdHlTdGF0aWMuZGVmYXVsdHMubWluRnJhbWVUaW1lIHx8ICFWZWxvY2l0eVN0YXRpYy5sYXN0VGljaykge1xuICAgICAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLmxhc3RUaWNrID0gdGltZUN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAgICAgICAgIENhbGwgSXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgICoqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBhbnkgdHdlZW5zIHRoYXQgbWlnaHQgbmVlZCBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFjdGl2ZUNhbGwgPSBWZWxvY2l0eVN0YXRpYy5TdGF0ZS5maXJzdE5ldykge1xuICAgICAgICAgICAgICAgICAgICBWZWxvY2l0eVN0YXRpYy52YWxpZGF0ZVR3ZWVucyhhY3RpdmVDYWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggYWN0aXZlIGNhbGwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYWN0aXZlQ2FsbCA9IFZlbG9jaXR5U3RhdGljLlN0YXRlLmZpcnN0OyBhY3RpdmVDYWxsICYmIGFjdGl2ZUNhbGwgIT09IFZlbG9jaXR5U3RhdGljLlN0YXRlLmZpcnN0TmV3OyBhY3RpdmVDYWxsID0gYWN0aXZlQ2FsbC5fbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGFjdGl2ZUNhbGwuZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGlzIGVsZW1lbnQgaGFzIGJlZW4gZGVsZXRlZCBtaWR3YXlcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3VnaCB0aGUgYW5pbWF0aW9uLiBJZiBpdCdzIGdvbmUgdGhlbiBlbmQgdGhpc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbmltYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUgfHwgIShkYXRhID0gRGF0YShlbGVtZW50KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSBzYWZlbHkgLSBkZWNyZWFzZSBjb3VudCwgZGVsZXRlIGRhdGEsIHJlbW92ZSBmcm9tIGFycmF5c1xuICAgICAgICAgICAgICAgICAgICAgICAgVmVsb2NpdHlTdGF0aWMuZnJlZUFuaW1hdGlvbkNhbGwoYWN0aXZlQ2FsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBib3RoZXIgZ2V0dGluZyB1bnRpbCB3ZSBjYW4gdXNlIHRoZXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gYWN0aXZlQ2FsbC5vcHRpb25zLCBmbGFncyA9IGFjdGl2ZUNhbGwuX2ZsYWdzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZVN0YXJ0ID0gYWN0aXZlQ2FsbC50aW1lU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgdGhhdCB0aGlzIGNhbGwgaGFzIGJlZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2Vzc2VkIGJ5IHRpY2soKSB0aGVuIHdlIGFzc2lnbiB0aW1lU3RhcnQgbm93IHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyB2YWx1ZSBpcyBhcyBjbG9zZSB0byB0aGUgcmVhbCBhbmltYXRpb24gc3RhcnQgdGltZVxuICAgICAgICAgICAgICAgICAgICAvLyBhcyBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRpbWVTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXVlXzEgPSBhY3RpdmVDYWxsLnF1ZXVlICE9IG51bGwgPyBhY3RpdmVDYWxsLnF1ZXVlIDogb3B0aW9ucy5xdWV1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVTdGFydCA9IHRpbWVDdXJyZW50IC0gZGVsdGFUaW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXVlXzEgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZVN0YXJ0ID0gTWF0aC5tYXgodGltZVN0YXJ0LCBkYXRhLmxhc3RGaW5pc2hMaXN0W3F1ZXVlXzFdIHx8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlQ2FsbC50aW1lU3RhcnQgPSB0aW1lU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBhbmltYXRpb24gaXMgcGF1c2VkIHRoZW4gc2tpcCBwcm9jZXNzaW5nIHVubGVzc1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCBoYXMgYmVlbiBzZXQgdG8gcmVzdW1lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyAmIDE2IC8qIFBBVVNFRCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0aW1lIHN0YXJ0IHRvIGFjY29tb2RhdGUgdGhlIHBhdXNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcGxldGlvbiBhbW91bnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVDYWxsLnRpbWVTdGFydCArPSBkZWx0YVRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGFuaW1hdGlvbiBpcyByZWFkeSAtIGlmIGl0J3Mgc3luY2VkIHRoZW4gaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZHMgdG8gd2FpdCBmb3IgYWxsIG90aGVyIGFuaW1hdGlvbnMgaW4gdGhlIHN5bmNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShmbGFncyAmIDIgLyogUkVBRFkgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVDYWxsLl9mbGFncyB8PSAyIC8qIFJFQURZICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5fcmVhZHkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIHNwbGl0IHRoZSBsb29wLCBhcyByZWFkeSBzeW5jIGFuaW1hdGlvbnMgbXVzdCBhbGwgZ2V0XG4gICAgICAgICAgICAgICAgLy8gdGhlIHNhbWUgc3RhcnQgdGltZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChhY3RpdmVDYWxsID0gVmVsb2NpdHlTdGF0aWMuU3RhdGUuZmlyc3Q7IGFjdGl2ZUNhbGwgJiYgYWN0aXZlQ2FsbCAhPT0gVmVsb2NpdHlTdGF0aWMuU3RhdGUuZmlyc3ROZXc7IGFjdGl2ZUNhbGwgPSBuZXh0Q2FsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSBhY3RpdmVDYWxsLl9mbGFncztcbiAgICAgICAgICAgICAgICAgICAgbmV4dENhbGwgPSBhY3RpdmVDYWxsLl9uZXh0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShmbGFncyAmIDIgLyogUkVBRFkgKi8pIHx8IGZsYWdzICYgMTYgLyogUEFVU0VEICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFjdGl2ZUNhbGwub3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzICYgMzIgLyogU1lOQyAqLyAmJiBvcHRpb25zLl9yZWFkeSA8IG9wdGlvbnMuX3RvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVDYWxsLnRpbWVTdGFydCArPSBkZWx0YVRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BlZWQgPSBhY3RpdmVDYWxsLnNwZWVkICE9IG51bGwgPyBhY3RpdmVDYWxsLnNwZWVkIDogb3B0aW9ucy5zcGVlZCAhPSBudWxsID8gb3B0aW9ucy5zcGVlZCA6IGRlZmF1bHRTcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVTdGFydCA9IGFjdGl2ZUNhbGwudGltZVN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBib3RoZXIgZ2V0dGluZyB1bnRpbCB3ZSBjYW4gdXNlIHRoZXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGZsYWdzICYgNCAvKiBTVEFSVEVEICovKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGF5ID0gYWN0aXZlQ2FsbC5kZWxheSAhPSBudWxsID8gYWN0aXZlQ2FsbC5kZWxheSA6IG9wdGlvbnMuZGVsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgYW55dGhpbmcgd2UndmUgZGVsYXllZCBkb2Vzbid0IHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmltYXRpbmcgeWV0LCB0aGVyZSBtaWdodCBzdGlsbCBiZSBhbiBhY3RpdmUgZGVsYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIHNvbWV0aGluZyBoYXMgYmVlbiB1bi1wYXVzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lU3RhcnQgKyBkZWxheSAvIHNwZWVkID4gdGltZUN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNhbGwudGltZVN0YXJ0ID0gdGltZVN0YXJ0ICs9IGRlbGF5IC8gKGRlbGF5ID4gMCA/IHNwZWVkIDogMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVDYWxsLl9mbGFncyB8PSA0IC8qIFNUQVJURUQgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmVnaW4gY2FsbGJhY2sgaXMgZmlyZWQgb25jZSBwZXIgY2FsbCwgbm90IG9uY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBlciBlbGVtZW50LCBhbmQgaXMgcGFzc2VkIHRoZSBmdWxsIHJhdyBET00gZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGFzIGJvdGggaXRzIGNvbnRleHQgYW5kIGl0cyBmaXJzdCBhcmd1bWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLl9zdGFydGVkKysgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLl9maXJzdCA9IGFjdGl2ZUNhbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYmVnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyB0byBhbiBleHRlcm5hbCBmbiB3aXRoIGEgdHJ5L2NhdGNoIGJsb2NrIGZvciBvcHRpbWlzYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEJlZ2luKGFjdGl2ZUNhbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGNhbGxlZCBvbmNlLCBldmVuIGlmIHJldmVyc2VkIG9yIHJlcGVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5iZWdpbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWVkICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgZnJhbWUgd2UgbWF5IGhhdmUgYSBzaG9ydGVyIGRlbHRhXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBNYXRoLm1pbihkZWx0YVRpbWUsIHRpbWVDdXJyZW50IC0gdGltZVN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNhbGwudGltZVN0YXJ0ID0gdGltZVN0YXJ0ICs9IGRlbHRhICogKDEgLSBzcGVlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuX2ZpcnN0ID09PSBhY3RpdmVDYWxsICYmIG9wdGlvbnMucHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNhbGwuX25leHRQcm9ncmVzcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0UHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvZ3Jlc3MuX25leHRQcm9ncmVzcyA9IGxhc3RQcm9ncmVzcyA9IGFjdGl2ZUNhbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UHJvZ3Jlc3MgPSBsYXN0UHJvZ3Jlc3MgPSBhY3RpdmVDYWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmVFYXNpbmcgPSBhY3RpdmVDYWxsLmVhc2luZyAhPSBudWxsID8gYWN0aXZlQ2FsbC5lYXNpbmcgOiBvcHRpb25zLmVhc2luZyAhPSBudWxsID8gb3B0aW9ucy5lYXNpbmcgOiBkZWZhdWx0RWFzaW5nLCBtaWxsaXNlY29uZHNFbGxhcHNlZCA9IGFjdGl2ZUNhbGwuZWxsYXBzZWRUaW1lID0gdGltZUN1cnJlbnQgLSB0aW1lU3RhcnQsIGR1cmF0aW9uID0gYWN0aXZlQ2FsbC5kdXJhdGlvbiAhPSBudWxsID8gYWN0aXZlQ2FsbC5kdXJhdGlvbiA6IG9wdGlvbnMuZHVyYXRpb24gIT0gbnVsbCA/IG9wdGlvbnMuZHVyYXRpb24gOiBkZWZhdWx0RHVyYXRpb24sIHBlcmNlbnRDb21wbGV0ZSA9IGFjdGl2ZUNhbGwucGVyY2VudENvbXBsZXRlID0gVmVsb2NpdHlTdGF0aWMubW9jayA/IDEgOiBNYXRoLm1pbihtaWxsaXNlY29uZHNFbGxhcHNlZCAvIGR1cmF0aW9uLCAxKSwgdHdlZW5zID0gYWN0aXZlQ2FsbC50d2VlbnMsIHJldmVyc2UgPSBmbGFncyAmIDY0IC8qIFJFVkVSU0UgKi87XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJjZW50Q29tcGxldGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNhbGwuX25leHRDb21wbGV0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0Q29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q29tcGxldGUuX25leHRDb21wbGV0ZSA9IGxhc3RDb21wbGV0ZSA9IGFjdGl2ZUNhbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Q29tcGxldGUgPSBsYXN0Q29tcGxldGUgPSBhY3RpdmVDYWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHR3ZWVucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV2ZXJ5IGVsZW1lbnQsIGl0ZXJhdGUgdGhyb3VnaCBlYWNoIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR3ZWVuXzMgPSB0d2VlbnNbcHJvcGVydHldLCBlYXNpbmcgPSB0d2Vlbl8zLmVhc2luZyB8fCBhY3RpdmVFYXNpbmcsIHBhdHRlcm4gPSB0d2Vlbl8zLnBhdHRlcm47XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gXCJcIiwgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoO2kgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydFZhbHVlID0gdHdlZW5fMy5zdGFydFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlICs9IHBhdHRlcm5baV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgZWFzaW5ncyBtdXN0IGRlYWwgd2l0aCBudW1iZXJzIGV4Y2VwdCBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG91ciBpbnRlcm5hbCBvbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZWFzaW5nKHJldmVyc2UgPyAxIC0gcGVyY2VudENvbXBsZXRlIDogcGVyY2VudENvbXBsZXRlLCBzdGFydFZhbHVlLCB0d2Vlbl8zLmVuZFtpXSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlICs9IHBhdHRlcm5baV0gPT09IHRydWUgPyBNYXRoLnJvdW5kKHJlc3VsdCkgOiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9PSBcInR3ZWVuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogVG8gc29sdmUgYW4gSUU8PTggcG9zaXRpb25pbmcgYnVnLCB0aGUgdW5pdCB0eXBlIG11c3QgYmUgZHJvcHBlZCB3aGVuIHNldHRpbmcgYSBwcm9wZXJ0eSB2YWx1ZSBvZiAwIC0gYWRkIG5vcm1hbGlzYXRpb25zIHRvIGxlZ2FjeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWxvY2l0eVN0YXRpYy5DU1Muc2V0UHJvcGVydHlWYWx1ZShhY3RpdmVDYWxsLmVsZW1lbnQsIHByb3BlcnR5LCBjdXJyZW50VmFsdWUsIHR3ZWVuXzMuZm4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgdGhlIGZha2UgJ3R3ZWVuJyBwcm9wZXJ0eSBhcyB0aGF0IGlzIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFzc2VkIGludG8gdGhlIHByb2dyZXNzIGNhbGxiYWNrLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVDYWxsLnR3ZWVuID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVmVsb2NpdHlKUzogTWlzc2luZyBwYXR0ZXJuOlwiLCBwcm9wZXJ0eSwgSlNPTi5zdHJpbmdpZnkodHdlZW5fM1twcm9wZXJ0eV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHdlZW5zW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RQcm9ncmVzcyB8fCBmaXJzdENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoYXN5bmNDYWxsYmFja3MsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoVmVsb2NpdHlTdGF0aWMuU3RhdGUuZmlyc3QpIHtcbiAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLlN0YXRlLmlzVGlja2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aWNrZXIodGljayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBWZWxvY2l0eVN0YXRpYy5TdGF0ZS5pc1RpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLmxhc3RUaWNrID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aWNraW5nID0gZmFsc2U7XG4gICAgfVxuICAgIFZlbG9jaXR5U3RhdGljLnRpY2sgPSB0aWNrO1xufSkoVmVsb2NpdHlTdGF0aWMgfHwgKFZlbG9jaXR5U3RhdGljID0ge30pKTtcblxuLypcbiAqIFZlbG9jaXR5SlMub3JnIChDKSAyMDE0LTIwMTcgSnVsaWFuIFNoYXBpcm8uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGRldGFpbHMuXG4gKlxuICogVXNlIHJBRiBoaWdoIHJlc29sdXRpb24gdGltZXN0YW1wIHdoZW4gYXZhaWxhYmxlLlxuICovIHZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgVmVsb2NpdHlTdGF0aWMudGltZXN0YW1wID0gdHJ1ZTtcbn0pKFZlbG9jaXR5U3RhdGljIHx8IChWZWxvY2l0eVN0YXRpYyA9IHt9KSk7XG5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICpcbiAqIFR3ZWVuc1xuICovXG52YXIgVmVsb2NpdHlTdGF0aWM7XG5cbihmdW5jdGlvbihWZWxvY2l0eVN0YXRpYykge1xuICAgIHZhciByeEhleCA9IC9eIyhbQS1mXFxkXXszfSl7MSwyfSQvaTtcbiAgICB2YXIgY29tbWFuZHMgPSBuZXcgTWFwKCk7XG4gICAgY29tbWFuZHMuc2V0KFwiZnVuY3Rpb25cIiwgZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQsIGVsZW1lbnRzLCBlbGVtZW50QXJyYXlJbmRleCwgcHJvcGVydHlOYW1lLCB0d2Vlbikge1xuICAgICAgICByZXR1cm4gdmFsdWUuY2FsbChlbGVtZW50LCBlbGVtZW50QXJyYXlJbmRleCwgZWxlbWVudHMubGVuZ3RoKTtcbiAgICB9KTtcbiAgICBjb21tYW5kcy5zZXQoXCJudW1iZXJcIiwgZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQsIGVsZW1lbnRzLCBlbGVtZW50QXJyYXlJbmRleCwgcHJvcGVydHlOYW1lLCB0d2Vlbikge1xuICAgICAgICByZXR1cm4gdmFsdWUgKyBWZWxvY2l0eVN0YXRpYy5nZXROb3JtYWxpemF0aW9uVW5pdCh0d2Vlbi5mbik7XG4gICAgfSk7XG4gICAgY29tbWFuZHMuc2V0KFwic3RyaW5nXCIsIGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50LCBlbGVtZW50cywgZWxlbWVudEFycmF5SW5kZXgsIHByb3BlcnR5TmFtZSwgdHdlZW4pIHtcbiAgICAgICAgcmV0dXJuIFZlbG9jaXR5U3RhdGljLkNTUy5maXhDb2xvcnModmFsdWUpO1xuICAgIH0pO1xuICAgIGNvbW1hbmRzLnNldChcInVuZGVmaW5lZFwiLCBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCwgZWxlbWVudHMsIGVsZW1lbnRBcnJheUluZGV4LCBwcm9wZXJ0eU5hbWUsIHR3ZWVuKSB7XG4gICAgICAgIHJldHVybiBWZWxvY2l0eVN0YXRpYy5DU1MuZml4Q29sb3JzKFZlbG9jaXR5U3RhdGljLkNTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5TmFtZSwgdHdlZW4uZm4pIHx8IFwiXCIpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEV4cGFuZCBhIFZlbG9jaXR5UHJvcGVydHkgYXJndW1lbnQgaW50byBhIHZhbGlkIHNwYXJzZSBUd2VlbiBhcnJheS4gVGhpc1xuICAgICAqIHByZS1hbGxvY2F0ZXMgdGhlIGFycmF5IGFzIGl0IGlzIHRoZW4gdGhlIGNvcnJlY3Qgc2l6ZSBhbmQgc2xpZ2h0bHlcbiAgICAgKiBmYXN0ZXIgdG8gYWNjZXNzLlxuICAgICAqLyAgICBmdW5jdGlvbiBleHBhbmRQcm9wZXJ0aWVzKGFuaW1hdGlvbiwgcHJvcGVydGllcykge1xuICAgICAgICB2YXIgdHdlZW5zID0gYW5pbWF0aW9uLnR3ZWVucyA9IGNyZWF0ZUVtcHR5T2JqZWN0KCksIGVsZW1lbnRzID0gYW5pbWF0aW9uLmVsZW1lbnRzLCBlbGVtZW50ID0gYW5pbWF0aW9uLmVsZW1lbnQsIGVsZW1lbnRBcnJheUluZGV4ID0gZWxlbWVudHMuaW5kZXhPZihlbGVtZW50KSwgZGF0YSA9IERhdGEoZWxlbWVudCksIHF1ZXVlID0gZ2V0VmFsdWUoYW5pbWF0aW9uLnF1ZXVlLCBhbmltYXRpb24ub3B0aW9ucy5xdWV1ZSksIGR1cmF0aW9uID0gZ2V0VmFsdWUoYW5pbWF0aW9uLm9wdGlvbnMuZHVyYXRpb24sIFZlbG9jaXR5U3RhdGljLmRlZmF1bHRzLmR1cmF0aW9uKTtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IFZlbG9jaXR5U3RhdGljLkNTUy5jYW1lbENhc2UocHJvcGVydHkpO1xuICAgICAgICAgICAgdmFyIHZhbHVlRGF0YSA9IHByb3BlcnRpZXNbcHJvcGVydHldLCBmbiA9IFZlbG9jaXR5U3RhdGljLmdldE5vcm1hbGl6YXRpb24oZWxlbWVudCwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIGlmICghZm4gJiYgcHJvcGVydHlOYW1lICE9PSBcInR3ZWVuXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoVmVsb2NpdHlTdGF0aWMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTa2lwcGluZyBbXCIgKyBwcm9wZXJ0eSArIFwiXSBkdWUgdG8gYSBsYWNrIG9mIGJyb3dzZXIgc3VwcG9ydC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlRGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKFZlbG9jaXR5U3RhdGljLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2tpcHBpbmcgW1wiICsgcHJvcGVydHkgKyBcIl0gZHVlIHRvIG5vIHZhbHVlIHN1cHBsaWVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHdlZW5fNCA9IHR3ZWVuc1twcm9wZXJ0eU5hbWVdID0gY3JlYXRlRW1wdHlPYmplY3QoKTtcbiAgICAgICAgICAgIHZhciBlbmRWYWx1ZSA9IHZvaWQgMCwgc3RhcnRWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHR3ZWVuXzQuZm4gPSBmbjtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgZnVuY3Rpb24gYXMgdGhlIG1haW4gYXJndW1lbnQgdGhlbiByZXNvbHZlXG4gICAgICAgICAgICAgICAgLy8gaXQgZmlyc3QsIGluIGNhc2UgaXQgcmV0dXJucyBhbiBhcnJheSB0aGF0IG5lZWRzIHRvIGJlXG4gICAgICAgICAgICAgICAgLy8gc3BsaXQuXG4gICAgICAgICAgICAgICAgdmFsdWVEYXRhID0gdmFsdWVEYXRhLmNhbGwoZWxlbWVudCwgZWxlbWVudEFycmF5SW5kZXgsIGVsZW1lbnRzLmxlbmd0aCwgZWxlbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVEYXRhKSkge1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlRGF0YSBpcyBhbiBhcnJheSBpbiB0aGUgZm9ybSBvZlxuICAgICAgICAgICAgICAgIC8vIFsgZW5kVmFsdWUsIFssIGVhc2luZ10gWywgc3RhcnRWYWx1ZV0gXVxuICAgICAgICAgICAgICAgIHZhciBhcnIxID0gdmFsdWVEYXRhWzFdLCBhcnIyID0gdmFsdWVEYXRhWzJdO1xuICAgICAgICAgICAgICAgIGVuZFZhbHVlID0gdmFsdWVEYXRhWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhhcnIxKSAmJiAoL15bXFxkLV0vLnRlc3QoYXJyMSkgfHwgcnhIZXgudGVzdChhcnIxKSkgfHwgaXNGdW5jdGlvbihhcnIxKSB8fCBpc051bWJlcihhcnIxKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlID0gYXJyMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGFycjEpICYmIFZlbG9jaXR5U3RhdGljLkVhc2luZy5FYXNpbmdzW2FycjFdIHx8IEFycmF5LmlzQXJyYXkoYXJyMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHdlZW5fNC5lYXNpbmcgPSBhcnIxO1xuICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlID0gYXJyMjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlID0gYXJyMSB8fCBhcnIyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kVmFsdWUgPSB2YWx1ZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0d2Vlbl80LmVuZCA9IGNvbW1hbmRzLmdldCh0eXBlb2YgZW5kVmFsdWUpKGVuZFZhbHVlLCBlbGVtZW50LCBlbGVtZW50cywgZWxlbWVudEFycmF5SW5kZXgsIHByb3BlcnR5TmFtZSwgdHdlZW5fNCk7XG4gICAgICAgICAgICBpZiAoc3RhcnRWYWx1ZSAhPSBudWxsIHx8IChxdWV1ZSA9PT0gZmFsc2UgfHwgZGF0YS5xdWV1ZUxpc3RbcXVldWVdID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgdHdlZW5fNC5zdGFydCA9IGNvbW1hbmRzLmdldCh0eXBlb2Ygc3RhcnRWYWx1ZSkoc3RhcnRWYWx1ZSwgZWxlbWVudCwgZWxlbWVudHMsIGVsZW1lbnRBcnJheUluZGV4LCBwcm9wZXJ0eU5hbWUsIHR3ZWVuXzQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwbG9kZVR3ZWVuKHByb3BlcnR5TmFtZSwgdHdlZW5fNCwgZHVyYXRpb24sICEhc3RhcnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVmVsb2NpdHlTdGF0aWMuZXhwYW5kUHJvcGVydGllcyA9IGV4cGFuZFByb3BlcnRpZXM7XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHN0cmluZy1iYXNlZCB0d2VlbiB3aXRoIHN0YXJ0IGFuZCBlbmQgc3RyaW5ncywgaW50byBhIHBhdHRlcm5cbiAgICAgKiBiYXNlZCB0d2VlbiB3aXRoIGFycmF5cy5cbiAgICAgKi8gICAgZnVuY3Rpb24gZXhwbG9kZVR3ZWVuKHByb3BlcnR5TmFtZSwgdHdlZW4sIGR1cmF0aW9uLCBpc0ZvcmNlZmVlZCkge1xuICAgICAgICB2YXIgZW5kVmFsdWUgPSB0d2Vlbi5lbmQ7XG4gICAgICAgIHZhciBzdGFydFZhbHVlID0gdHdlZW4uc3RhcnQ7XG4gICAgICAgIGlmICghaXNTdHJpbmcoZW5kVmFsdWUpIHx8ICFpc1N0cmluZyhzdGFydFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBydW5BZ2FpbiA9IGZhbHNlO1xuIC8vIENhbiBvbmx5IGJlIHNldCBvbmNlIGlmIHRoZSBTdGFydCB2YWx1ZSBkb2Vzbid0IG1hdGNoIHRoZSBFbmQgdmFsdWUgYW5kIGl0J3Mgbm90IGZvcmNlZmVkXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgcnVuQWdhaW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBhcnJheVN0YXJ0ID0gdHdlZW4uc3RhcnQgPSBbIG51bGwgXSwgYXJyYXlFbmQgPSB0d2Vlbi5lbmQgPSBbIG51bGwgXSwgcGF0dGVybiA9IHR3ZWVuLnBhdHRlcm4gPSBbIFwiXCIgXTtcbiAgICAgICAgICAgIHZhciBlYXNpbmcgPSB0d2Vlbi5lYXNpbmcsIGluZGV4U3RhcnQgPSAwLCAvLyBpbmRleCBpbiBzdGFydFZhbHVlXG4gICAgICAgICAgICBpbmRleEVuZCA9IDAsIC8vIGluZGV4IGluIGVuZFZhbHVlXG4gICAgICAgICAgICBpbkNhbGMgPSAwLCAvLyBLZWVwIHRyYWNrIG9mIGJlaW5nIGluc2lkZSBhIFwiY2FsYygpXCIgc28gd2UgZG9uJ3QgZHVwbGljYXRlIGl0XG4gICAgICAgICAgICBpblJHQiA9IDAsIC8vIEtlZXAgdHJhY2sgb2YgYmVpbmcgaW5zaWRlIGFuIFJHQiBhcyB3ZSBjYW4ndCB1c2UgZnJhY3Rpb25hbCB2YWx1ZXNcbiAgICAgICAgICAgIGluUkdCQSA9IDAsIC8vIEtlZXAgdHJhY2sgb2YgYmVpbmcgaW5zaWRlIGFuIFJHQkEgYXMgd2UgbXVzdCBwYXNzIGZyYWN0aW9uYWwgZm9yIHRoZSBhbHBoYSBjaGFubmVsXG4gICAgICAgICAgICBpc1N0cmluZ1ZhbHVlID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhclN0YXJ0ID0gc3RhcnRWYWx1ZVtpbmRleFN0YXJ0XSwgY2hhckVuZCA9IGVuZFZhbHVlW2luZGV4RW5kXTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGV5J3JlIGJvdGggbnVtYmVycywgdGhlbiBwYXJzZSB0aGVtIGFzIGEgd2hvbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFRXRUVOX05VTUJFUl9SRUdFWC50ZXN0KGNoYXJTdGFydCkgJiYgVFdFRU5fTlVNQkVSX1JFR0VYLnRlc3QoY2hhckVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBTdGFydCA9IGNoYXJTdGFydCwgLy8gdGVtcG9yYXJ5IGNoYXJhY3RlciBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgdGVtcEVuZCA9IGNoYXJFbmQsIC8vIHRlbXBvcmFyeSBjaGFyYWN0ZXIgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgIGRvdFN0YXJ0ID0gXCIuXCIsIC8vIE1ha2Ugc3VyZSB3ZSBjYW4gb25seSBldmVyIG1hdGNoIGEgc2luZ2xlIGRvdCBpbiBhIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgZG90RW5kID0gXCIuXCI7XG4gLy8gTWFrZSBzdXJlIHdlIGNhbiBvbmx5IGV2ZXIgbWF0Y2ggYSBzaW5nbGUgZG90IGluIGEgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgrK2luZGV4U3RhcnQgPCBzdGFydFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhclN0YXJ0ID0gc3RhcnRWYWx1ZVtpbmRleFN0YXJ0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyU3RhcnQgPT09IGRvdFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90U3RhcnQgPSBcIi4uXCI7XG4gLy8gQ2FuIG5ldmVyIG1hdGNoIHR3byBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc051bWJlcldoZW5QYXJzZWQoY2hhclN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFN0YXJ0ICs9IGNoYXJTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKytpbmRleEVuZCA8IGVuZFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckVuZCA9IGVuZFZhbHVlW2luZGV4RW5kXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyRW5kID09PSBkb3RFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RFbmQgPSBcIi4uXCI7XG4gLy8gQ2FuIG5ldmVyIG1hdGNoIHR3byBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc051bWJlcldoZW5QYXJzZWQoY2hhckVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBFbmQgKz0gY2hhckVuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdW5pdFN0YXJ0ID0gVmVsb2NpdHlTdGF0aWMuQ1NTLmdldFVuaXQoc3RhcnRWYWx1ZSwgaW5kZXhTdGFydCksIC8vIHRlbXBvcmFyeSB1bml0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgdW5pdEVuZCA9IFZlbG9jaXR5U3RhdGljLkNTUy5nZXRVbml0KGVuZFZhbHVlLCBpbmRleEVuZCk7XG4gLy8gdGVtcG9yYXJ5IHVuaXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4U3RhcnQgKz0gdW5pdFN0YXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhFbmQgKz0gdW5pdEVuZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bml0RW5kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBvcmRlciBhcyBpdCdzIG1vc3QgY29tbW9uIGZvciB0aGUgdXNlciBzdXBwbGllZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgdG8gYmUgYSBudW1iZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB1bml0RW5kID0gdW5pdFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHVuaXRTdGFydC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXRTdGFydCA9IHVuaXRFbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuaXRTdGFydCA9PT0gdW5pdEVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2FtZSB1bml0c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBTdGFydCA9PT0gdGVtcEVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhbWUgbnVtYmVycywgc28ganVzdCBjb3B5IG92ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoIC0gMV0gKz0gdGVtcFN0YXJ0ICsgdW5pdFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLnB1c2goaW5SR0IgPyB0cnVlIDogZmFsc2UsIHVuaXRTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlTdGFydC5wdXNoKHBhcnNlRmxvYXQodGVtcFN0YXJ0KSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlFbmQucHVzaChwYXJzZUZsb2F0KHRlbXBFbmQpLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpZmZlcmVudCB1bml0cywgc28gcHV0IGludG8gYSBcImNhbGMoZnJvbSArIHRvKVwiIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5pbWF0ZSBlYWNoIHNpZGUgdG8vZnJvbSB6ZXJvLiBzZXRQcm9wZXJ0eVZhbHVlIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvb2sgb3V0IGZvciB0aGUgZmluYWwgXCJjYWxjKDAgKyBcIiBwcmVmaXggYW5kIHJlbW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgdmFsdWUgd2hlbiBpdCBmaW5kcyBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm5bcGF0dGVybi5sZW5ndGggLSAxXSArPSBpbkNhbGMgPyBcIisgKFwiIDogXCJjYWxjKFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybi5wdXNoKGZhbHNlLCB1bml0U3RhcnQgKyBcIiArIFwiLCBmYWxzZSwgdW5pdEVuZCArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5U3RhcnQucHVzaChwYXJzZUZsb2F0KHRlbXBTdGFydCkgfHwgMCwgbnVsbCwgMCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheUVuZC5wdXNoKDAsIG51bGwsIHBhcnNlRmxvYXQodGVtcEVuZCkgfHwgMCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJTdGFydCA9PT0gY2hhckVuZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoIC0gMV0gKz0gY2hhclN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBpbmRleFN0YXJ0Kys7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4RW5kKys7XG4gICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgYmVpbmcgaW5zaWRlIGEgY2FsYygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluQ2FsYyA9PT0gMCAmJiBjaGFyU3RhcnQgPT09IFwiY1wiIHx8IGluQ2FsYyA9PT0gMSAmJiBjaGFyU3RhcnQgPT09IFwiYVwiIHx8IGluQ2FsYyA9PT0gMiAmJiBjaGFyU3RhcnQgPT09IFwibFwiIHx8IGluQ2FsYyA9PT0gMyAmJiBjaGFyU3RhcnQgPT09IFwiY1wiIHx8IGluQ2FsYyA+PSA0ICYmIGNoYXJTdGFydCA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQ2FsYysrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluQ2FsYyAmJiBpbkNhbGMgPCA1IHx8IGluQ2FsYyA+PSA0ICYmIGNoYXJTdGFydCA9PT0gXCIpXCIgJiYgLS1pbkNhbGMgPCA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkNhbGMgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgYmVpbmcgaW5zaWRlIGFuIHJnYigpIC8gcmdiYSgpXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvcGFjaXR5IG11c3Qgbm90IGJlIHJvdW5kZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluUkdCID09PSAwICYmIGNoYXJTdGFydCA9PT0gXCJyXCIgfHwgaW5SR0IgPT09IDEgJiYgY2hhclN0YXJ0ID09PSBcImdcIiB8fCBpblJHQiA9PT0gMiAmJiBjaGFyU3RhcnQgPT09IFwiYlwiIHx8IGluUkdCID09PSAzICYmIGNoYXJTdGFydCA9PT0gXCJhXCIgfHwgaW5SR0IgPj0gMyAmJiBjaGFyU3RhcnQgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5SR0IgPT09IDMgJiYgY2hhclN0YXJ0ID09PSBcImFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluUkdCQSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpblJHQisrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluUkdCQSAmJiBjaGFyU3RhcnQgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytpblJHQkEgPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5SR0IgPSBpblJHQkEgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluUkdCQSAmJiBpblJHQiA8IChpblJHQkEgPyA1IDogNCkgfHwgaW5SR0IgPj0gKGluUkdCQSA/IDQgOiAzKSAmJiBjaGFyU3RhcnQgPT09IFwiKVwiICYmIC0taW5SR0IgPCAoaW5SR0JBID8gNSA6IDQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpblJHQiA9IGluUkdCQSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJTdGFydCB8fCBjaGFyRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERpZmZlcmVudCBsZXR0ZXJzLCBzbyB3ZSdyZSBnb2luZyB0byBwdXNoIHRoZW0gaW50byBzdGFydFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZW5kIHVudGlsIHRoZSBuZXh0IHdvcmRcbiAgICAgICAgICAgICAgICAgICAgaXNTdHJpbmdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcoYXJyYXlTdGFydFthcnJheVN0YXJ0Lmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4ubGVuZ3RoID09PSAxICYmICFwYXR0ZXJuWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlTdGFydFswXSA9IGFycmF5RW5kWzBdID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybi5wdXNoKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5U3RhcnQucHVzaChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheUVuZC5wdXNoKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleFN0YXJ0IDwgc3RhcnRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJTdGFydCA9IHN0YXJ0VmFsdWVbaW5kZXhTdGFydCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyU3RhcnQgPT09IFwiIFwiIHx8IFRXRUVOX05VTUJFUl9SRUdFWC50ZXN0KGNoYXJTdGFydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlTdGFydFthcnJheVN0YXJ0Lmxlbmd0aCAtIDFdICs9IGNoYXJTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXhFbmQgPCBlbmRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJFbmQgPSBlbmRWYWx1ZVtpbmRleEVuZCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyRW5kID09PSBcIiBcIiB8fCBUV0VFTl9OVU1CRVJfUkVHRVgudGVzdChjaGFyRW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheUVuZFthcnJheUVuZC5sZW5ndGggLSAxXSArPSBjaGFyRW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNGb3JjZWZlZWQgJiYgaW5kZXhTdGFydCA9PT0gc3RhcnRWYWx1ZS5sZW5ndGggIT09IChpbmRleEVuZCA9PT0gZW5kVmFsdWUubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGxpdHRsZSBwaWVjZSB3aWxsIHRha2UgYSBzdGFydFZhbHVlLCBzcGxpdCBvdXQgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhcmlvdXMgbnVtYmVycyBpbiBpdCwgdGhlbiBjb3B5IHRoZSBlbmRWYWx1ZSBpbnRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdGFydFZhbHVlIHdoaWxlIHJlcGxhY2luZyB0aGUgbnVtYmVycyBpbiBpdCB0byBtYXRjaCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgc3RhcnQgbnVtYmVycyBhcyBhIHJlcGVhdGluZyBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmluYWxseSB0aGlzIGZ1bmN0aW9uIHdpbGwgcnVuIGFnYWluIHdpdGggdGhlIG5ld1xuICAgICAgICAgICAgICAgICAgICAvLyBzdGFydFZhbHVlIGFuZCBhIG5vdyBtYXRjaGluZyBwYXR0ZXJuLlxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnROdW1iZXJzXzEgPSBzdGFydFZhbHVlLm1hdGNoKC9cXGRcXC4/XFxkKi9nKSB8fCBbIFwiMFwiIF0sIGNvdW50XzEgPSBzdGFydE51bWJlcnNfMS5sZW5ndGgsIGluZGV4XzEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlID0gZW5kVmFsdWUucmVwbGFjZSgvXFxkK1xcLj9cXGQqL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0TnVtYmVyc18xW2luZGV4XzErKyAlIGNvdW50XzFdO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcnVuQWdhaW4gPSBpc0ZvcmNlZmVlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlbGF0aXZlIFZhbHVlc1xuICAgICAgICAgICAgLyogT3BlcmF0b3IgbG9naWMgbXVzdCBiZSBwZXJmb3JtZWQgbGFzdCBzaW5jZSBpdCByZXF1aXJlcyB1bml0LW5vcm1hbGl6ZWQgc3RhcnQgYW5kIGVuZCB2YWx1ZXMuICovXG4gICAgICAgICAgICAvKiBOb3RlOiBSZWxhdGl2ZSAqcGVyY2VudCB2YWx1ZXMqIGRvIG5vdCBiZWhhdmUgaG93IG1vc3QgcGVvcGxlIHRoaW5rOyB3aGlsZSBvbmUgd291bGQgZXhwZWN0IFwiKz01MCVcIlxuICAgICAgICAgICAgIHRvIGluY3JlYXNlIHRoZSBwcm9wZXJ0eSAxLjV4IGl0cyBjdXJyZW50IHZhbHVlLCBpdCBpbiBmYWN0IGluY3JlYXNlcyB0aGUgcGVyY2VudCB1bml0cyBpbiBhYnNvbHV0ZSB0ZXJtczpcbiAgICAgICAgICAgICA1MCBwb2ludHMgaXMgYWRkZWQgb24gdG9wIG9mIHRoZSBjdXJyZW50ICUgdmFsdWUuICovXG4gICAgICAgICAgICAvL1x0XHRcdFx0XHRzd2l0Y2ggKG9wZXJhdG9yIGFzIGFueSBhcyBzdHJpbmcpIHtcbiAgICAgICAgICAgIC8vXHRcdFx0XHRcdFx0Y2FzZSBcIitcIjpcbiAgICAgICAgICAgIC8vXHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IHN0YXJ0VmFsdWUgKyBlbmRWYWx1ZTtcbiAgICAgICAgICAgIC8vXHRcdFx0XHRcdFx0XHRicmVhaztcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvL1x0XHRcdFx0XHRcdGNhc2UgXCItXCI6XG4gICAgICAgICAgICAvL1x0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBzdGFydFZhbHVlIC0gZW5kVmFsdWU7XG4gICAgICAgICAgICAvL1x0XHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy9cdFx0XHRcdFx0XHRjYXNlIFwiKlwiOlxuICAgICAgICAgICAgLy9cdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gc3RhcnRWYWx1ZSAqIGVuZFZhbHVlO1xuICAgICAgICAgICAgLy9cdFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vXHRcdFx0XHRcdFx0Y2FzZSBcIi9cIjpcbiAgICAgICAgICAgIC8vXHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IHN0YXJ0VmFsdWUgLyBlbmRWYWx1ZTtcbiAgICAgICAgICAgIC8vXHRcdFx0XHRcdFx0XHRicmVhaztcbiAgICAgICAgICAgIC8vXHRcdFx0XHRcdH1cbiAgICAgICAgICAgIC8vIFRPRE86IExlYWRpbmcgZnJvbSBhIGNhbGMgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleFN0YXJ0IDwgc3RhcnRWYWx1ZS5sZW5ndGggJiYgaW5kZXhFbmQgPCBlbmRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzIoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcnVuQWdhaW4pIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGVzZSB0d28gd291bGQgYmUgc2xpZ2h0bHkgYmV0dGVyIHRvIG5vdCBhZGQgdGhlIGFycmF5IGluZGljZXMgaW4gdGhlIGZpcnN0IHBsYWNlXG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5bMF0gPT09IFwiXCIgJiYgYXJyYXlFbmRbMF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5U3RhcnQuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlFbmQuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5bcGF0dGVybi5sZW5ndGhdID09PSBcIlwiICYmIGFycmF5RW5kW2FycmF5RW5kLmxlbmd0aF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBhcnJheVN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBhcnJheUVuZC5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4U3RhcnQgPCBzdGFydFZhbHVlLmxlbmd0aCB8fCBpbmRleEVuZCA8IGVuZFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBXZSBzaG91bGQgbmV2ZXIgYmUgYWJsZSB0byByZWFjaCB0aGlzIGNvZGUgdW5sZXNzIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFkIGZvcmNlZmVkIHZhbHVlIGlzIHN1cHBsaWVkLlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVmVsb2NpdHk6IFRyeWluZyB0byBwYXR0ZXJuIG1hdGNoIG1pcy1tYXRjaGVkIHN0cmluZ3MgXCIgKyBwcm9wZXJ0eU5hbWUgKyAnOltcIicgKyBlbmRWYWx1ZSArICdcIiwgXCInICsgc3RhcnRWYWx1ZSArICdcIl0nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFZlbG9jaXR5U3RhdGljLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVmVsb2NpdHk6IFBhdHRlcm4gZm91bmQ6XCIsIHBhdHRlcm4sIFwiIC0+IFwiLCBhcnJheVN0YXJ0LCBhcnJheUVuZCwgXCJbXCIgKyBzdGFydFZhbHVlICsgXCIsXCIgKyBlbmRWYWx1ZSArIFwiXVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5TmFtZSA9PT0gXCJkaXNwbGF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEvXihhdC1zdGFydHxhdC1lbmR8ZHVyaW5nKSQvLnRlc3QoZWFzaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nID0gZW5kVmFsdWUgPT09IFwibm9uZVwiID8gXCJhdC1lbmRcIiA6IFwiYXQtc3RhcnRcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlOYW1lID09PSBcInZpc2liaWxpdHlcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIS9eKGF0LXN0YXJ0fGF0LWVuZHxkdXJpbmcpJC8udGVzdChlYXNpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlYXNpbmcgPSBlbmRWYWx1ZSA9PT0gXCJoaWRkZW5cIiA/IFwiYXQtZW5kXCIgOiBcImF0LXN0YXJ0XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nVmFsdWUgJiYgZWFzaW5nICE9PSBcImF0LXN0YXJ0XCIgJiYgZWFzaW5nICE9PSBcImR1cmluZ1wiICYmIGVhc2luZyAhPT0gXCJhdC1lbmRcIiAmJiBlYXNpbmcgIT09IFZlbG9jaXR5U3RhdGljLkVhc2luZy5FYXNpbmdzW1wiYXQtU3RhcnRcIl0gJiYgZWFzaW5nICE9PSBWZWxvY2l0eVN0YXRpYy5FYXNpbmcuRWFzaW5nc1tcImR1cmluZ1wiXSAmJiBlYXNpbmcgIT09IFZlbG9jaXR5U3RhdGljLkVhc2luZy5FYXNpbmdzW1wiYXQtZW5kXCJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlZlbG9jaXR5OiBTdHJpbmcgZWFzaW5ncyBtdXN0IHVzZSBvbmUgb2YgJ2F0LXN0YXJ0JywgJ2R1cmluZycgb3IgJ2F0LWVuZCc6IHtcIiArIHByb3BlcnR5TmFtZSArICc6IFtcIicgKyBlbmRWYWx1ZSArICdcIiwgJyArIGVhc2luZyArICcsIFwiJyArIHN0YXJ0VmFsdWUgKyAnXCJdfScpO1xuICAgICAgICAgICAgICAgICAgICBlYXNpbmcgPSBcImF0LXN0YXJ0XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR3ZWVuLmVhc2luZyA9IHZhbGlkYXRlRWFzaW5nKGVhc2luZywgZHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBjYW4gb25seSBydW4gYSBzZWNvbmQgdGltZSBvbmNlIC0gaWYgZ29pbmcgZnJvbSBhdXRvbWF0aWMgc3RhcnRWYWx1ZSB0byBcImZpeGVkXCIgcGF0dGVybiBmcm9tIGVuZFZhbHVlIHdpdGggc3RhcnRWYWx1ZSBudW1iZXJzXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocnVuQWdhaW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBhbmQgYWxsIHF1ZXVlZCBhbmltYXRpb25zIHRoYXQgaGF2ZW4ndCBnb25lIHlldFxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgZXhwYW5kIHRoZSBwcm9wZXJ0aWVzIG1hcCBmb3IgYW55IHJlY2VudGx5IGFkZGVkXG4gICAgICogYW5pbWF0aW9ucyBzbyB0aGF0IHRoZSBzdGFydCBhbmQgZW5kIHZhbHVlcyBhcmUgY29ycmVjdC5cbiAgICAgKi8gICAgZnVuY3Rpb24gdmFsaWRhdGVUd2VlbnMoYWN0aXZlQ2FsbCkge1xuICAgICAgICAvLyBUaGlzIG1pZ2h0IGJlIGNhbGxlZCBvbiBhbiBhbHJlYWR5LXJlYWR5IGFuaW1hdGlvblxuICAgICAgICBpZiAoVmVsb2NpdHlTdGF0aWMuU3RhdGUuZmlyc3ROZXcgPT09IGFjdGl2ZUNhbGwpIHtcbiAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLlN0YXRlLmZpcnN0TmV3ID0gYWN0aXZlQ2FsbC5fbmV4dDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSBhbHJlYWR5IHJlYWR5XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUNhbGwuX2ZsYWdzICYgMSAvKiBFWFBBTkRFRCAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gYWN0aXZlQ2FsbC5lbGVtZW50LCB0d2VlbnMgPSBhY3RpdmVDYWxsLnR3ZWVucywgZHVyYXRpb24gPSBnZXRWYWx1ZShhY3RpdmVDYWxsLm9wdGlvbnMuZHVyYXRpb24sIFZlbG9jaXR5U3RhdGljLmRlZmF1bHRzLmR1cmF0aW9uKTtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHR3ZWVucykge1xuICAgICAgICAgICAgdmFyIHR3ZWVuXzUgPSB0d2VlbnNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIGlmICh0d2Vlbl81LnN0YXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHN0YXJ0IHZhbHVlIGFzIGl0J3Mgbm90IGJlZW4gcGFzc2VkIGluXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBWZWxvY2l0eVN0YXRpYy5DU1MuZ2V0UHJvcGVydHlWYWx1ZShhY3RpdmVDYWxsLmVsZW1lbnQsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHN0YXJ0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHR3ZWVuXzUuc3RhcnQgPSBWZWxvY2l0eVN0YXRpYy5DU1MuZml4Q29sb3JzKHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBleHBsb2RlVHdlZW4ocHJvcGVydHlOYW1lLCB0d2Vlbl81LCBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShzdGFydFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJiYWQgdHlwZVwiLCB0d2Vlbl81LCBwcm9wZXJ0eU5hbWUsIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChWZWxvY2l0eVN0YXRpYy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidHdlZW5zQ29udGFpbmVyIChcIiArIHByb3BlcnR5TmFtZSArIFwiKTogXCIgKyBKU09OLnN0cmluZ2lmeSh0d2Vlbl81KSwgZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlQ2FsbC5fZmxhZ3MgfD0gMSAvKiBFWFBBTkRFRCAqLztcbiAgICB9XG4gICAgVmVsb2NpdHlTdGF0aWMudmFsaWRhdGVUd2VlbnMgPSB2YWxpZGF0ZVR3ZWVucztcbn0pKFZlbG9jaXR5U3RhdGljIHx8IChWZWxvY2l0eVN0YXRpYyA9IHt9KSk7XG5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICpcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb25zIHVzZWQgZm9yIHZhcmlvdXMgdHlwZXMgb2YgZGF0YSB0aGF0IGNhbiBiZSBzdXBwbGllZC5cbiAqIEFsbCBlcnJvcnMgYXJlIHJlcG9ydGVkIGluIHRoZSBub24tbWluaWZpZWQgdmVyc2lvbiBmb3IgZGV2ZWxvcG1lbnQuIElmIGFcbiAqIHZhbGlkYXRpb24gZmFpbHMgdGhlbiBpdCBzaG91bGQgcmV0dXJuIDxjb2RlPnVuZGVmaW5lZDwvY29kZT4uXG4gKi9cbi8qKlxuICogUGFyc2UgYSBkdXJhdGlvbiB2YWx1ZSBhbmQgcmV0dXJuIGFuIG1zIG51bWJlci4gT3B0aW9uYWxseSByZXR1cm4gYVxuICogZGVmYXVsdCB2YWx1ZSBpZiB0aGUgbnVtYmVyIGlzIG5vdCB2YWxpZC5cbiAqLyBmdW5jdGlvbiBwYXJzZUR1cmF0aW9uKGR1cmF0aW9uLCBkZWYpIHtcbiAgICBpZiAoaXNOdW1iZXIoZHVyYXRpb24pKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKGR1cmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gRHVyYXRpb25bZHVyYXRpb24udG9Mb3dlckNhc2UoKV0gfHwgcGFyc2VGbG9hdChkdXJhdGlvbi5yZXBsYWNlKFwibXNcIiwgXCJcIikucmVwbGFjZShcInNcIiwgXCIwMDBcIikpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmID09IG51bGwgPyB1bmRlZmluZWQgOiBwYXJzZUR1cmF0aW9uKGRlZik7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgYSA8Y29kZT5jYWNoZTwvY29kZT4gb3B0aW9uLlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiB2YWxpZGF0ZUNhY2hlKHZhbHVlKSB7XG4gICAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJWZWxvY2l0eUpTOiBUcnlpbmcgdG8gc2V0ICdjYWNoZScgdG8gYW4gaW52YWxpZCB2YWx1ZTpcIiwgdmFsdWUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIDxjb2RlPmJlZ2luPC9jb2RlPiBvcHRpb24uXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIHZhbGlkYXRlQmVnaW4odmFsdWUpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJWZWxvY2l0eUpTOiBUcnlpbmcgdG8gc2V0ICdiZWdpbicgdG8gYW4gaW52YWxpZCB2YWx1ZTpcIiwgdmFsdWUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIDxjb2RlPmNvbXBsZXRlPC9jb2RlPiBvcHRpb24uXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIHZhbGlkYXRlQ29tcGxldGUodmFsdWUsIG5vRXJyb3IpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAhbm9FcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJWZWxvY2l0eUpTOiBUcnlpbmcgdG8gc2V0ICdjb21wbGV0ZScgdG8gYW4gaW52YWxpZCB2YWx1ZTpcIiwgdmFsdWUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIDxjb2RlPmRlbGF5PC9jb2RlPiBvcHRpb24uXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIHZhbGlkYXRlRGVsYXkodmFsdWUpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gICAgaWYgKCFpc05hTihwYXJzZWQpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJWZWxvY2l0eUpTOiBUcnlpbmcgdG8gc2V0ICdkZWxheScgdG8gYW4gaW52YWxpZCB2YWx1ZTpcIiwgdmFsdWUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIDxjb2RlPmR1cmF0aW9uPC9jb2RlPiBvcHRpb24uXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIHZhbGlkYXRlRHVyYXRpb24odmFsdWUsIG5vRXJyb3IpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gICAgaWYgKCFpc05hTihwYXJzZWQpICYmIHBhcnNlZCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICFub0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJWZWxvY2l0eUpTOiBUcnlpbmcgdG8gc2V0ICdkdXJhdGlvbicgdG8gYW4gaW52YWxpZCB2YWx1ZTpcIiwgdmFsdWUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIDxjb2RlPmVhc2luZzwvY29kZT4gb3B0aW9uLlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiB2YWxpZGF0ZUVhc2luZyh2YWx1ZSwgZHVyYXRpb24sIG5vRXJyb3IpIHtcbiAgICB2YXIgRWFzaW5nID0gVmVsb2NpdHlTdGF0aWMuRWFzaW5nO1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgLy8gTmFtZWQgZWFzaW5nXG4gICAgICAgIHJldHVybiBFYXNpbmcuRWFzaW5nc1t2YWx1ZV07XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBTdGVwc1xuICAgICAgICAgICAgcmV0dXJuIEVhc2luZy5nZW5lcmF0ZVN0ZXAodmFsdWVbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIC8vIHNwcmluZ1JLNCBtdXN0IGJlIHBhc3NlZCB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24uXG4gICAgICAgICAgICAvLyBOb3RlOiBJZiB0aGUgc3ByaW5nUks0IGFycmF5IGNvbnRhaW5zIG5vbi1udW1iZXJzLFxuICAgICAgICAgICAgLy8gZ2VuZXJhdGVTcHJpbmdSSzQoKSByZXR1cm5zIGFuIGVhc2luZyBmdW5jdGlvbiBnZW5lcmF0ZWQgd2l0aFxuICAgICAgICAgICAgLy8gZGVmYXVsdCB0ZW5zaW9uIGFuZCBmcmljdGlvbiB2YWx1ZXMuXG4gICAgICAgICAgICByZXR1cm4gRWFzaW5nLmdlbmVyYXRlU3ByaW5nUks0KHZhbHVlWzBdLCB2YWx1ZVsxXSwgZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IElmIHRoZSBiZXppZXIgYXJyYXkgY29udGFpbnMgbm9uLW51bWJlcnMsIGdlbmVyYXRlQmV6aWVyKClcbiAgICAgICAgICAgIC8vIHJldHVybnMgdW5kZWZpbmVkLlxuICAgICAgICAgICAgcmV0dXJuIEVhc2luZy5nZW5lcmF0ZUJlemllci5hcHBseShudWxsLCB2YWx1ZSkgfHwgZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgIW5vRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlZlbG9jaXR5SlM6IFRyeWluZyB0byBzZXQgJ2Vhc2luZycgdG8gYW4gaW52YWxpZCB2YWx1ZTpcIiwgdmFsdWUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIDxjb2RlPmZwc0xpbWl0PC9jb2RlPiBvcHRpb24uXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIHZhbGlkYXRlRnBzTGltaXQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZCkgJiYgcGFyc2VkID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihwYXJzZWQsIDYwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJWZWxvY2l0eUpTOiBUcnlpbmcgdG8gc2V0ICdmcHNMaW1pdCcgdG8gYW4gaW52YWxpZCB2YWx1ZTpcIiwgdmFsdWUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIDxjb2RlPmxvb3A8L2NvZGU+IG9wdGlvbi5cbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gdmFsaWRhdGVMb29wKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZCkgJiYgcGFyc2VkID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVmVsb2NpdHlKUzogVHJ5aW5nIHRvIHNldCAnbG9vcCcgdG8gYW4gaW52YWxpZCB2YWx1ZTpcIiwgdmFsdWUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIDxjb2RlPnByb2dyZXNzPC9jb2RlPiBvcHRpb24uXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIHZhbGlkYXRlUHJvZ3Jlc3ModmFsdWUpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJWZWxvY2l0eUpTOiBUcnlpbmcgdG8gc2V0ICdwcm9ncmVzcycgdG8gYW4gaW52YWxpZCB2YWx1ZTpcIiwgdmFsdWUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIDxjb2RlPnByb21pc2U8L2NvZGU+IG9wdGlvbi5cbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gdmFsaWRhdGVQcm9taXNlKHZhbHVlKSB7XG4gICAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJWZWxvY2l0eUpTOiBUcnlpbmcgdG8gc2V0ICdwcm9taXNlJyB0byBhbiBpbnZhbGlkIHZhbHVlOlwiLCB2YWx1ZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGEgPGNvZGU+cHJvbWlzZVJlamVjdEVtcHR5PC9jb2RlPiBvcHRpb24uXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIHZhbGlkYXRlUHJvbWlzZVJlamVjdEVtcHR5KHZhbHVlKSB7XG4gICAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJWZWxvY2l0eUpTOiBUcnlpbmcgdG8gc2V0ICdwcm9taXNlUmVqZWN0RW1wdHknIHRvIGFuIGludmFsaWQgdmFsdWU6XCIsIHZhbHVlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGUgYSA8Y29kZT5xdWV1ZTwvY29kZT4gb3B0aW9uLlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiB2YWxpZGF0ZVF1ZXVlKHZhbHVlLCBub0Vycm9yKSB7XG4gICAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCBpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAhbm9FcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJWZWxvY2l0eUpTOiBUcnlpbmcgdG8gc2V0ICdxdWV1ZScgdG8gYW4gaW52YWxpZCB2YWx1ZTpcIiwgdmFsdWUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIDxjb2RlPnJlcGVhdDwvY29kZT4gb3B0aW9uLlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiB2YWxpZGF0ZVJlcGVhdCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgaWYgKCFpc05hTihwYXJzZWQpICYmIHBhcnNlZCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlZlbG9jaXR5SlM6IFRyeWluZyB0byBzZXQgJ3JlcGVhdCcgdG8gYW4gaW52YWxpZCB2YWx1ZTpcIiwgdmFsdWUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIDxjb2RlPnNwZWVkPC9jb2RlPiBvcHRpb24uXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIHZhbGlkYXRlU3BlZWQodmFsdWUpIHtcbiAgICBpZiAoaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlZlbG9jaXR5SlM6IFRyeWluZyB0byBzZXQgJ3NwZWVkJyB0byBhbiBpbnZhbGlkIHZhbHVlOlwiLCB2YWx1ZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGEgPGNvZGU+c3luYzwvY29kZT4gb3B0aW9uLlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiB2YWxpZGF0ZVN5bmModmFsdWUpIHtcbiAgICBpZiAoaXNCb29sZWFuKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJWZWxvY2l0eUpTOiBUcnlpbmcgdG8gc2V0ICdzeW5jJyB0byBhbiBpbnZhbGlkIHZhbHVlOlwiLCB2YWx1ZSk7XG4gICAgfVxufVxuXG4vKlxuICogVmVsb2NpdHlKUy5vcmcgKEMpIDIwMTQtMjAxNyBKdWxpYW4gU2hhcGlyby5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cbiAqXG4gKiBWZWxvY2l0eSB2ZXJzaW9uIChzaG91bGQgZ3JhYiBmcm9tIHBhY2thZ2UuanNvbiBkdXJpbmcgYnVpbGQpLlxuICovIHZhciBWZWxvY2l0eVN0YXRpYztcblxuKGZ1bmN0aW9uKFZlbG9jaXR5U3RhdGljKSB7XG4gICAgVmVsb2NpdHlTdGF0aWMudmVyc2lvbiA9IFwiMi4wLjJcIjtcbn0pKFZlbG9jaXR5U3RhdGljIHx8IChWZWxvY2l0eVN0YXRpYyA9IHt9KSk7XG5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICpcbiAqIENvcmUgXCJWZWxvY2l0eVwiIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBWZWxvY2l0eUZuKCkge1xuICAgIHZhciBfX2FyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBfX2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyXG4gICAgLyoqXG4gICAgICogQSBzaG9ydGN1dCB0byB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICAgICAqL1xuICAgIGRlZmF1bHRzID0gVmVsb2NpdHlTdGF0aWMuZGVmYXVsdHMsXG4gICAgLyoqXG4gICAgICogU2hvcnRjdXQgdG8gYXJndW1lbnRzIGZvciBmaWxlIHNpemUuXG4gICAgICovXG4gICAgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cyxcbiAgICAvKipcbiAgICAgKiBDYWNoZSBvZiB0aGUgZmlyc3QgYXJndW1lbnQgLSB0aGlzIGlzIHVzZWQgb2Z0ZW4gZW5vdWdoIHRvIGJlIHNhdmVkLlxuICAgICAqL1xuICAgIGFyZ3MwID0gX2FyZ3VtZW50c1swXSxcbiAgICAvKipcbiAgICAgKiBUbyBhbGxvdyBmb3IgZXhwcmVzc2l2ZSBDb2ZmZWVTY3JpcHQgY29kZSwgVmVsb2NpdHkgc3VwcG9ydHMgYW5cbiAgICAgKiBhbHRlcm5hdGl2ZSBzeW50YXggaW4gd2hpY2ggXCJlbGVtZW50c1wiIChvciBcImVcIiksIFwicHJvcGVydGllc1wiIChvclxuICAgICAqIFwicFwiKSwgYW5kIFwib3B0aW9uc1wiIChvciBcIm9cIikgb2JqZWN0cyBhcmUgZGVmaW5lZCBvbiBhIGNvbnRhaW5lclxuICAgICAqIG9iamVjdCB0aGF0J3MgcGFzc2VkIGluIGFzIFZlbG9jaXR5J3Mgc29sZSBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFNvbWUgYnJvd3NlcnMgYXV0b21hdGljYWxseSBwb3B1bGF0ZSBhcmd1bWVudHMgd2l0aCBhXG4gICAgICogXCJwcm9wZXJ0aWVzXCIgb2JqZWN0LiBXZSBkZXRlY3QgaXQgYnkgY2hlY2tpbmcgZm9yIGl0cyBkZWZhdWx0XG4gICAgICogXCJuYW1lc1wiIHByb3BlcnR5LlxuICAgICAqL1xuICAgIC8vIFRPRE86IENvbmZpcm0gd2hpY2ggYnJvd3NlcnMgLSBpZiA8PUlFOCB0aGUgd2UgY2FuIGRyb3AgY29tcGxldGVseVxuICAgIHN5bnRhY3RpY1N1Z2FyID0gaXNQbGFpbk9iamVjdChhcmdzMCkgJiYgKGFyZ3MwLnAgfHwgKGlzUGxhaW5PYmplY3QoYXJnczAucHJvcGVydGllcykgJiYgIWFyZ3MwLnByb3BlcnRpZXMubmFtZXMgfHwgaXNTdHJpbmcoYXJnczAucHJvcGVydGllcykpKTtcbiAgICB2YXJcbiAgICAvKipcbiAgICAgKiAgV2hlbiBWZWxvY2l0eSBpcyBjYWxsZWQgdmlhIHRoZSB1dGlsaXR5IGZ1bmN0aW9uIChWZWxvY2l0eSgpKSxcbiAgICAgKiBlbGVtZW50cyBhcmUgZXhwbGljaXRseSBwYXNzZWQgaW4gYXMgdGhlIGZpcnN0IHBhcmFtZXRlci4gVGh1cyxcbiAgICAgKiBhcmd1bWVudCBwb3NpdGlvbmluZyB2YXJpZXMuXG4gICAgICovXG4gICAgYXJndW1lbnRJbmRleCA9IDAsXG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgZWxlbWVudHMsIGV4dGVuZGVkIHdpdGggUHJvbWlzZSBhbmQgVmVsb2NpdHkuXG4gICAgICovXG4gICAgZWxlbWVudHMsXG4gICAgLyoqXG4gICAgICogVGhlIHByb3BlcnRpZXMgYmVpbmcgYW5pbWF0ZWQuIFRoaXMgY2FuIGJlIGEgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGl0XG4gICAgICogaXMgZWl0aGVyIGEgZnVuY3Rpb24gZm9yIHRoZXNlIGVsZW1lbnRzLCBvciBpdCBpcyBhIFwibmFtZWRcIiBhbmltYXRpb25cbiAgICAgKiBzZXF1ZW5jZSB0byB1c2UgaW5zdGVhZC4gTmFtZWQgc2VxdWVuY2VzIHN0YXJ0IHdpdGggZWl0aGVyIFwiY2FsbG91dC5cIlxuICAgICAqIG9yIFwidHJhbnNpdGlvbi5cIi4gV2hlbiB1c2VkIGFzIGEgY2FsbG91dCB0aGUgdmFsdWVzIHdpbGwgYmUgcmVzZXRcbiAgICAgKiBhZnRlciBmaW5pc2hpbmcuIFdoZW4gdXNlZCBhcyBhIHRyYW5zdGl0aW9uIHRoZW4gdGhlcmUgaXMgbm8gc3BlY2lhbFxuICAgICAqIGhhbmRsaW5nIGFmdGVyIGZpbmlzaGluZy5cbiAgICAgKi9cbiAgICBwcm9wZXJ0aWVzTWFwLFxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMgc3VwcGxpZWQsIHRoaXMgd2lsbCBiZSBtYXBwZWQgYW5kIHZhbGlkYXRlZCBpbnRvXG4gICAgICogPGNvZGU+b3B0aW9uczwvY29kZT4uXG4gICAgICovXG4gICAgb3B0aW9uc01hcCxcbiAgICAvKipcbiAgICAgKiBJZiBjYWxsZWQgdmlhIGEgY2hhaW4gdGhlbiB0aGlzIGNvbnRhaW5zIHRoZSA8Yj5sYXN0PC9iPiBjYWxsc1xuICAgICAqIGFuaW1hdGlvbnMuIElmIHRoaXMgZG9lcyBub3QgaGF2ZSBhIHZhbHVlIHRoZW4gYW55IGFjY2VzcyB0byB0aGVcbiAgICAgKiBlbGVtZW50J3MgYW5pbWF0aW9ucyBuZWVkcyB0byBiZSB0byB0aGUgY3VycmVudGx5LXJ1bm5pbmcgb25lcy5cbiAgICAgKi9cbiAgICBhbmltYXRpb25zLFxuICAgIC8qKlxuICAgICAqIFRoZSBwcm9taXNlIHRoYXQgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgcHJvbWlzZSxcbiAgICAvLyBVc2VkIHdoZW4gdGhlIGFuaW1hdGlvbiBpcyBmaW5pc2hlZFxuICAgIHJlc29sdmVyLFxuICAgIC8vIFVzZWQgd2hlbiB0aGVyZSB3YXMgYW4gaXNzdWUgd2l0aCBvbmUgb3IgbW9yZSBvZiB0aGUgVmVsb2NpdHkgYXJndW1lbnRzXG4gICAgcmVqZWN0ZXI7XG4gICAgLy9jb25zb2xlLmxvZyhcIlZlbG9jaXR5XCIsIF9hcmd1bWVudHMpXG4gICAgLy8gRmlyc3QgZ2V0IHRoZSBlbGVtZW50cywgYW5kIHRoZSBhbmltYXRpb25zIGNvbm5lY3RlZCB0byB0aGUgbGFzdCBjYWxsIGlmXG4gICAgLy8gdGhpcyBpcyBjaGFpbmVkLlxuICAgIC8vIFRPRE86IENsZWFuIHRoaXMgdXAgYSBiaXRcbiAgICAvLyBUT0RPOiBUaHJvdyBlcnJvciBpZiB0aGUgY2hhaW4gaXMgY2FsbGVkIHdpdGggZWxlbWVudHMgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LiBpc1ZlbG9jaXR5UmVzdWx0KHRoaXMpICYmICggKGlzTm9kZShhcmcwKSB8fCBpc1dyYXBwZWQoYXJnMCkpICYmIGFyZzAgPT0gdGhpcylcbiAgICAgICAgaWYgKGlzTm9kZSh0aGlzKSkge1xuICAgICAgICAvLyBUaGlzIGlzIGZyb20gYSBjaGFpbiBzdWNoIGFzIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiXCIpLnZlbG9jaXR5KC4uLilcbiAgICAgICAgZWxlbWVudHMgPSBbIHRoaXMgXTtcbiAgICB9IGVsc2UgaWYgKGlzV3JhcHBlZCh0aGlzKSkge1xuICAgICAgICAvLyBUaGlzIG1pZ2h0IGJlIGEgY2hhaW4gZnJvbSBzb21ldGhpbmcgZWxzZSwgYnV0IGlmIGNoYWluZWQgZnJvbSBhXG4gICAgICAgIC8vIHByZXZpb3VzIFZlbG9jaXR5KCkgY2FsbCB0aGVuIGdyYWIgdGhlIGFuaW1hdGlvbnMgaXQncyByZWxhdGVkIHRvLlxuICAgICAgICBlbGVtZW50cyA9IE9iamVjdC5hc3NpZ24oW10sIHRoaXMpO1xuICAgICAgICBpZiAoaXNWZWxvY2l0eVJlc3VsdCh0aGlzKSkge1xuICAgICAgICAgICAgYW5pbWF0aW9ucyA9IHRoaXMudmVsb2NpdHkuYW5pbWF0aW9ucztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3ludGFjdGljU3VnYXIpIHtcbiAgICAgICAgZWxlbWVudHMgPSBPYmplY3QuYXNzaWduKFtdLCBhcmdzMC5lbGVtZW50cyB8fCBhcmdzMC5lKTtcbiAgICAgICAgYXJndW1lbnRJbmRleCsrO1xuICAgIH0gZWxzZSBpZiAoaXNOb2RlKGFyZ3MwKSkge1xuICAgICAgICBlbGVtZW50cyA9IE9iamVjdC5hc3NpZ24oW10sIFsgYXJnczAgXSk7XG4gICAgICAgIGFyZ3VtZW50SW5kZXgrKztcbiAgICB9IGVsc2UgaWYgKGlzV3JhcHBlZChhcmdzMCkpIHtcbiAgICAgICAgZWxlbWVudHMgPSBPYmplY3QuYXNzaWduKFtdLCBhcmdzMCk7XG4gICAgICAgIGFyZ3VtZW50SW5kZXgrKztcbiAgICB9XG4gICAgLy8gQWxsb3cgZWxlbWVudHMgdG8gYmUgY2hhaW5lZC5cbiAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KGVsZW1lbnRzLCBcInZlbG9jaXR5XCIsIFZlbG9jaXR5Rm4uYmluZChlbGVtZW50cykpO1xuICAgICAgICBpZiAoYW5pbWF0aW9ucykge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkoZWxlbWVudHMudmVsb2NpdHksIFwiYW5pbWF0aW9uc1wiLCBhbmltYXRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBOZXh0IGdldCB0aGUgcHJvcGVydGllc01hcCBhbmQgb3B0aW9ucy5cbiAgICAgICAgaWYgKHN5bnRhY3RpY1N1Z2FyKSB7XG4gICAgICAgIHByb3BlcnRpZXNNYXAgPSBnZXRWYWx1ZShhcmdzMC5wcm9wZXJ0aWVzLCBhcmdzMC5wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBTaG91bGQgYmUgcG9zc2libGUgdG8gY2FsbCBWZWxvY2l0eShcInBhdXNlQWxsXCIpIC0gY3VycmVudGx5IG5vdCBwb3NzaWJsZVxuICAgICAgICBwcm9wZXJ0aWVzTWFwID0gX2FyZ3VtZW50c1thcmd1bWVudEluZGV4KytdO1xuICAgIH1cbiAgICAvLyBHZXQgYW55IG9wdGlvbnMgbWFwIHBhc3NlZCBpbiBhcyBhcmd1bWVudHMgZmlyc3QsIGV4cGFuZCBhbnkgZGlyZWN0XG4gICAgLy8gb3B0aW9ucyBpZiBwb3NzaWJsZS5cbiAgICAgICAgdmFyIGlzUmV2ZXJzZSA9IHByb3BlcnRpZXNNYXAgPT09IFwicmV2ZXJzZVwiLCBpc0FjdGlvbiA9ICFpc1JldmVyc2UgJiYgaXNTdHJpbmcocHJvcGVydGllc01hcCksIG9wdHMgPSBzeW50YWN0aWNTdWdhciA/IGdldFZhbHVlKGFyZ3MwLm9wdGlvbnMsIGFyZ3MwLm8pIDogX2FyZ3VtZW50c1thcmd1bWVudEluZGV4XTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChvcHRzKSkge1xuICAgICAgICBvcHRpb25zTWFwID0gb3B0cztcbiAgICB9XG4gICAgLy8gQ3JlYXRlIHRoZSBwcm9taXNlIGlmIHN1cHBvcnRlZCBhbmQgd2FudGVkLlxuICAgICAgICBpZiAoUHJvbWlzZSAmJiBnZXRWYWx1ZShvcHRpb25zTWFwICYmIG9wdGlvbnNNYXAucHJvbWlzZSwgZGVmYXVsdHMucHJvbWlzZSkpIHtcbiAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKF9yZXNvbHZlLCBfcmVqZWN0KSB7XG4gICAgICAgICAgICByZWplY3RlciA9IF9yZWplY3Q7XG4gICAgICAgICAgICAvLyBJTVBPUlRBTlQ6XG4gICAgICAgICAgICAvLyBJZiBhIHJlc29sdmVyIHRyaWVzIHRvIHJ1biBvbiBhIFByb21pc2UgdGhlbiBpdCB3aWxsIHdhaXQgdW50aWxcbiAgICAgICAgICAgIC8vIHRoYXQgUHJvbWlzZSByZXNvbHZlcyAtIGJ1dCBpbiB0aGlzIGNhc2Ugd2UncmUgcnVubmluZyBvbiBvdXIgb3duXG4gICAgICAgICAgICAvLyBQcm9taXNlLCBzbyBuZWVkIHRvIG1ha2Ugc3VyZSBpdCdzIG5vdCBzZWVuIGFzIG9uZS4gU2V0dGluZyB0aGVzZVxuICAgICAgICAgICAgLy8gdmFsdWVzIHRvIDxjb2RlPnVuZGVmaW5lZDwvY29kZT4gZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgcmVzb2x2ZS5cbiAgICAgICAgICAgIC8vIER1ZSB0byBiZWluZyBhbiBhc3luYyBjYWxsLCB0aGV5IHNob3VsZCBiZSBiYWNrIHRvIFwibm9ybWFsXCJcbiAgICAgICAgICAgIC8vIGJlZm9yZSB0aGUgPGNvZGU+LnRoZW4oKTwvY29kZT4gZnVuY3Rpb24gZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWZWxvY2l0eVJlc3VsdChhcmdzKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoZW4gPSBhcmdzICYmIGFyZ3MudGhlbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnRoZW4gPSB1bmRlZmluZWQ7XG4gLy8gUHJlc2VydmluZyBlbnVtZXJhdGlvbiBldGNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9yZXNvbHZlKGFyZ3MsIF90aGVuKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblx0XHRwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGFyZ3MsIF90aGVuKSB7XG5cdFx0XHRpZiAoX3RoZW4pIHtcblx0XHRcdFx0YXJncy50aGVuID0gX3RoZW5cblx0XHRcdH1cblx0XHRcdHJldHVybiBhcmdzXG5cdFx0fSlcbiAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShlbGVtZW50cywgXCJ0aGVuXCIsIHByb21pc2UudGhlbi5iaW5kKHByb21pc2UpKTtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KGVsZW1lbnRzLCBcImNhdGNoXCIsIHByb21pc2UuY2F0Y2guYmluZChwcm9taXNlKSk7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5maW5hbGx5KSB7XG4gICAgICAgICAgICAgICAgLy8gU2VtaS1zdGFuZGFyZFxuICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KGVsZW1lbnRzLCBcImZpbmFsbHlcIiwgcHJvbWlzZS5maW5hbGx5LmJpbmQocHJvbWlzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBwcm9taXNlUmVqZWN0RW1wdHkgPSBnZXRWYWx1ZShvcHRpb25zTWFwICYmIG9wdGlvbnNNYXAucHJvbWlzZVJlamVjdEVtcHR5LCBkZWZhdWx0cy5wcm9taXNlUmVqZWN0RW1wdHkpO1xuICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgIGlmICghZWxlbWVudHMgJiYgIWlzQWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZVJlamVjdEVtcHR5KSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0ZXIoXCJWZWxvY2l0eTogTm8gZWxlbWVudHMgc3VwcGxpZWQsIGlmIHRoYXQgaXMgZGVsaWJlcmF0ZSB0aGVuIHBhc3MgYHByb21pc2VSZWplY3RFbXB0eTpmYWxzZWAgYXMgYW4gb3B0aW9uLiBBYm9ydGluZy5cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXByb3BlcnRpZXNNYXApIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlUmVqZWN0RW1wdHkpIHtcbiAgICAgICAgICAgICAgICByZWplY3RlcihcIlZlbG9jaXR5OiBObyBwcm9wZXJ0aWVzIHN1cHBsaWVkLCBpZiB0aGF0IGlzIGRlbGliZXJhdGUgdGhlbiBwYXNzIGBwcm9taXNlUmVqZWN0RW1wdHk6ZmFsc2VgIGFzIGFuIG9wdGlvbi4gQWJvcnRpbmcuXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghZWxlbWVudHMgJiYgIWlzQWN0aW9uIHx8ICFwcm9wZXJ0aWVzTWFwKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvLyBOT1RFOiBDYW4ndCB1c2UgaXNBY3Rpb24gaGVyZSBkdWUgdG8gdHlwZSBpbmZlcmVuY2UgLSB0aGVyZSBhcmUgY2FsbGJhY2tzXG4gICAgLy8gYmV0d2VlbiBzbyB0aGUgdHlwZSBpc24ndCBjb25zaWRlcmVkIHNhZmUuXG4gICAgICAgIGlmIChpc0FjdGlvbikge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBwcm9taXNlSGFuZGxlciA9IHByb21pc2UgJiYge1xuICAgICAgICAgICAgX3Byb21pc2U6IHByb21pc2UsXG4gICAgICAgICAgICBfcmVzb2x2ZXI6IHJlc29sdmVyLFxuICAgICAgICAgICAgX3JlamVjdGVyOiByZWplY3RlclxuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAoYXJndW1lbnRJbmRleCA8IF9hcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goX2FyZ3VtZW50c1thcmd1bWVudEluZGV4KytdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWZWxvY2l0eSdzIGJlaGF2aW9yIGlzIGNhdGVnb3JpemVkIGludG8gXCJhY3Rpb25zXCIuIElmIGEgc3RyaW5nIGlzXG4gICAgICAgIC8vIHBhc3NlZCBpbiBpbnN0ZWFkIG9mIGEgcHJvcGVydGllc01hcCB0aGVuIHRoYXQgd2lsbCBjYWxsIGEgZnVuY3Rpb25cbiAgICAgICAgLy8gdG8gZG8gc29tZXRoaW5nIHNwZWNpYWwgdG8gdGhlIGFuaW1hdGlvbiBsaW5rZWQuXG4gICAgICAgIC8vIFRoZXJlIGlzIG9uZSBzcGVjaWFsIGNhc2UgLSBcInJldmVyc2VcIiAtIHdoaWNoIGlzIGhhbmRsZWQgZGlmZmVyZW50bHksXG4gICAgICAgIC8vIGJ5IGJlaW5nIHN0b3JlZCBvbiB0aGUgYW5pbWF0aW9uIGFuZCB0aGVuIGV4cGFuZGVkIHdoZW4gdGhlIGFuaW1hdGlvblxuICAgICAgICAvLyBzdGFydHMuXG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHByb3BlcnRpZXNNYXAucmVwbGFjZSgvXFwuLiokLywgXCJcIiksIGNhbGxiYWNrID0gVmVsb2NpdHlTdGF0aWMuQWN0aW9uc1thY3Rpb25dIHx8IFZlbG9jaXR5U3RhdGljLkFjdGlvbnNbXCJkZWZhdWx0XCJdO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayhhcmdzLCBlbGVtZW50cywgcHJvbWlzZUhhbmRsZXIsIHByb3BlcnRpZXNNYXApO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlZlbG9jaXR5SlM6IFVua25vd24gYWN0aW9uOlwiLCBwcm9wZXJ0aWVzTWFwKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wZXJ0aWVzTWFwKSB8fCBpc1JldmVyc2UpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvcHRpb25zIGZvciB0aGlzIHNldCBvZiBhbmltYXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIGlzU3luYyA9IGRlZmF1bHRzLnN5bmM7XG4gICAgICAgIC8vIFByaXZhdGUgb3B0aW9ucyBmaXJzdCAtIHNldCBhcyBub24tZW51bWVyYWJsZSwgYW5kIHN0YXJ0aW5nIHdpdGggYW5cbiAgICAgICAgLy8gdW5kZXJzY29yZSBzbyB3ZSBjYW4gZmlsdGVyIHRoZW0gb3V0LlxuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShvcHRpb25zLCBcIl9wcm9taXNlXCIsIHByb21pc2UpO1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkob3B0aW9ucywgXCJfcmVqZWN0ZXJcIiwgcmVqZWN0ZXIpO1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkob3B0aW9ucywgXCJfcmVzb2x2ZXJcIiwgcmVzb2x2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVByb3BlcnR5KG9wdGlvbnMsIFwiX3JlYWR5XCIsIDApO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShvcHRpb25zLCBcIl9zdGFydGVkXCIsIDApO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShvcHRpb25zLCBcIl9jb21wbGV0ZWRcIiwgMCk7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KG9wdGlvbnMsIFwiX3RvdGFsXCIsIDApO1xuICAgICAgICAvLyBOb3cgY2hlY2sgdGhlIG9wdGlvbnNNYXBcbiAgICAgICAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChvcHRpb25zTWFwKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IGdldFZhbHVlKHZhbGlkYXRlRHVyYXRpb24ob3B0aW9uc01hcC5kdXJhdGlvbiksIGRlZmF1bHRzLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVsYXkgPSBnZXRWYWx1ZSh2YWxpZGF0ZURlbGF5KG9wdGlvbnNNYXAuZGVsYXkpLCBkZWZhdWx0cy5kZWxheSk7XG4gICAgICAgICAgICAvLyBOZWVkIHRoZSBleHRyYSBmYWxsYmFjayBoZXJlIGluIGNhc2UgaXQgc3VwcGxpZXMgYW4gaW52YWxpZFxuICAgICAgICAgICAgLy8gZWFzaW5nIHRoYXQgd2UgbmVlZCB0byBvdmVycnJpZGUgd2l0aCB0aGUgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZWFzaW5nID0gdmFsaWRhdGVFYXNpbmcoZ2V0VmFsdWUob3B0aW9uc01hcC5lYXNpbmcsIGRlZmF1bHRzLmVhc2luZyksIG9wdGlvbnMuZHVyYXRpb24pIHx8IHZhbGlkYXRlRWFzaW5nKGRlZmF1bHRzLmVhc2luZywgb3B0aW9ucy5kdXJhdGlvbik7XG4gICAgICAgICAgICBvcHRpb25zLmxvb3AgPSBnZXRWYWx1ZSh2YWxpZGF0ZUxvb3Aob3B0aW9uc01hcC5sb29wKSwgZGVmYXVsdHMubG9vcCk7XG4gICAgICAgICAgICBvcHRpb25zLnJlcGVhdCA9IG9wdGlvbnMucmVwZWF0QWdhaW4gPSBnZXRWYWx1ZSh2YWxpZGF0ZVJlcGVhdChvcHRpb25zTWFwLnJlcGVhdCksIGRlZmF1bHRzLnJlcGVhdCk7XG4gICAgICAgICAgICBpZiAob3B0aW9uc01hcC5zcGVlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zcGVlZCA9IGdldFZhbHVlKHZhbGlkYXRlU3BlZWQob3B0aW9uc01hcC5zcGVlZCksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQm9vbGVhbihvcHRpb25zTWFwLnByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9taXNlID0gb3B0aW9uc01hcC5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5xdWV1ZSA9IGdldFZhbHVlKHZhbGlkYXRlUXVldWUob3B0aW9uc01hcC5xdWV1ZSksIGRlZmF1bHRzLnF1ZXVlKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zTWFwLm1vYmlsZUhBICYmICFWZWxvY2l0eVN0YXRpYy5TdGF0ZS5pc0dpbmdlcmJyZWFkKSB7XG4gICAgICAgICAgICAgICAgLyogV2hlbiBzZXQgdG8gdHJ1ZSwgYW5kIGlmIHRoaXMgaXMgYSBtb2JpbGUgZGV2aWNlLCBtb2JpbGVIQSBhdXRvbWF0aWNhbGx5IGVuYWJsZXMgaGFyZHdhcmUgYWNjZWxlcmF0aW9uICh2aWEgYSBudWxsIHRyYW5zZm9ybSBoYWNrKVxuICAgICAgICAgICAgICAgICBvbiBhbmltYXRpbmcgZWxlbWVudHMuIEhBIGlzIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudCBhdCB0aGUgY29tcGxldGlvbiBvZiBpdHMgYW5pbWF0aW9uLiAqL1xuICAgICAgICAgICAgICAgIC8qIE5vdGU6IEFuZHJvaWQgR2luZ2VyYnJlYWQgZG9lc24ndCBzdXBwb3J0IEhBLiBJZiBhIG51bGwgdHJhbnNmb3JtIGhhY2sgKG1vYmlsZUhBKSBpcyBpbiBmYWN0IHNldCwgaXQgd2lsbCBwcmV2ZW50IG90aGVyIHRyYW5mb3JtIHN1YnByb3BlcnRpZXMgZnJvbSB0YWtpbmcgZWZmZWN0LiAqL1xuICAgICAgICAgICAgICAgIC8qIE5vdGU6IFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IHRoZSB1c2Ugb2YgbW9iaWxlSEEgaW4gVmVsb2NpdHkncyBkb2N1bWVudGF0aW9uOiBWZWxvY2l0eUpTLm9yZy8jbW9iaWxlSEEuICovXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tb2JpbGVIQSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zTWFwLmRpc3BsYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzTWFwLmRpc3BsYXkgPSBvcHRpb25zTWFwLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEZXByZWNhdGVkICdvcHRpb25zLmRpc3BsYXknIHVzZWQsIHRoaXMgaXMgbm93IGEgcHJvcGVydHk6XCIsIG9wdGlvbnNNYXAuZGlzcGxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zTWFwLnZpc2liaWxpdHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzTWFwLnZpc2liaWxpdHkgPSBvcHRpb25zTWFwLnZpc2liaWxpdHk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEZXByZWNhdGVkICdvcHRpb25zLnZpc2liaWxpdHknIHVzZWQsIHRoaXMgaXMgbm93IGEgcHJvcGVydHk6XCIsIG9wdGlvbnNNYXAudmlzaWJpbGl0eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogQWxsb3cgZnVuY3Rpb25hbCBvcHRpb25zIGZvciBkaWZmZXJlbnQgb3B0aW9ucyBwZXIgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnNCZWdpbiA9IHZhbGlkYXRlQmVnaW4ob3B0aW9uc01hcC5iZWdpbiksIG9wdGlvbnNDb21wbGV0ZSA9IHZhbGlkYXRlQ29tcGxldGUob3B0aW9uc01hcC5jb21wbGV0ZSksIG9wdGlvbnNQcm9ncmVzcyA9IHZhbGlkYXRlUHJvZ3Jlc3Mob3B0aW9uc01hcC5wcm9ncmVzcyksIG9wdGlvbnNTeW5jID0gdmFsaWRhdGVTeW5jKG9wdGlvbnNNYXAuc3luYyk7XG4gICAgICAgICAgICBpZiAob3B0aW9uc0JlZ2luICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJlZ2luID0gb3B0aW9uc0JlZ2luO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnNDb21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb21wbGV0ZSA9IG9wdGlvbnNDb21wbGV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zUHJvZ3Jlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvZ3Jlc3MgPSBvcHRpb25zUHJvZ3Jlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9uc1N5bmMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlzU3luYyA9IG9wdGlvbnNTeW5jO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFzeW50YWN0aWNTdWdhcikge1xuICAgICAgICAgICAgLy8gRXhwYW5kIGFueSBkaXJlY3Qgb3B0aW9ucyBpZiBwb3NzaWJsZS5cbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHZhbGlkYXRlRHVyYXRpb24oX2FyZ3VtZW50c1thcmd1bWVudEluZGV4XSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKF9hcmd1bWVudHNbYXJndW1lbnRJbmRleCArIG9mZnNldF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVzcGl0ZSBjb21pbmcgYmVmb3JlIENvbXBsZXRlLCB3ZSBjYW4ndCBwYXNzIGEgZm4gZWFzaW5nXG4gICAgICAgICAgICAgICAgdmFyIGVhc2luZyA9IHZhbGlkYXRlRWFzaW5nKF9hcmd1bWVudHNbYXJndW1lbnRJbmRleCArIG9mZnNldF0sIGdldFZhbHVlKG9wdGlvbnMgJiYgdmFsaWRhdGVEdXJhdGlvbihvcHRpb25zLmR1cmF0aW9uKSwgZGVmYXVsdHMuZHVyYXRpb24pLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZWFzaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZWFzaW5nID0gZWFzaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IHZhbGlkYXRlQ29tcGxldGUoX2FyZ3VtZW50c1thcmd1bWVudEluZGV4ICsgb2Zmc2V0XSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoY29tcGxldGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29tcGxldGUgPSBjb21wbGV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMubG9vcCA9IGRlZmF1bHRzLmxvb3A7XG4gICAgICAgICAgICBvcHRpb25zLnJlcGVhdCA9IG9wdGlvbnMucmVwZWF0QWdhaW4gPSBkZWZhdWx0cy5yZXBlYXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUmV2ZXJzZSAmJiBvcHRpb25zLnF1ZXVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVsb2NpdHlKUzogQ2Fubm90IHJldmVyc2UgYSBxdWV1ZTpmYWxzZSBhbmltYXRpb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIFdoZW4gYSBzZXQgb2YgZWxlbWVudHMgaXMgdGFyZ2V0ZWQgYnkgYSBWZWxvY2l0eSBjYWxsLCB0aGUgc2V0IGlzIGJyb2tlbiB1cCBhbmQgZWFjaCBlbGVtZW50IGhhcyB0aGUgY3VycmVudCBWZWxvY2l0eSBjYWxsIGluZGl2aWR1YWxseSBxdWV1ZWQgb250byBpdC5cbiAgICAgICAgIEluIHRoaXMgd2F5LCBlYWNoIGVsZW1lbnQncyBleGlzdGluZyBxdWV1ZSBpcyByZXNwZWN0ZWQ7IHNvbWUgZWxlbWVudHMgbWF5IGFscmVhZHkgYmUgYW5pbWF0aW5nIGFuZCBhY2NvcmRpbmdseSBzaG91bGQgbm90IGhhdmUgdGhpcyBjdXJyZW50IFZlbG9jaXR5IGNhbGwgdHJpZ2dlcmVkIGltbWVkaWF0ZWx5LiAqL1xuICAgICAgICAvKiBJbiBlYWNoIHF1ZXVlLCB0d2VlbiBkYXRhIGlzIHByb2Nlc3NlZCBmb3IgZWFjaCBhbmltYXRpbmcgcHJvcGVydHkgdGhlbiBwdXNoZWQgb250byB0aGUgY2FsbC13aWRlIGNhbGxzIGFycmF5LiBXaGVuIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIHNldCBoYXMgaGFkIGl0cyB0d2VlbnMgcHJvY2Vzc2VkLFxuICAgICAgICAgdGhlIGNhbGwgYXJyYXkgaXMgcHVzaGVkIHRvIFZlbG9jaXR5U3RhdGljLlN0YXRlLmNhbGxzIGZvciBsaXZlIHByb2Nlc3NpbmcgYnkgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSB0aWNrLiAqLyAgICAgICAgdmFyIHJvb3RBbmltYXRpb24gPSB7XG4gICAgICAgICAgICBfcHJldjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX25leHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9mbGFnczogaXNTeW5jID8gMzIgLyogU1lOQyAqLyA6IDAsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgcGVyY2VudENvbXBsZXRlOiAwLFxuICAgICAgICAgICAgLy9lbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgZWxsYXBzZWRUaW1lOiAwLFxuICAgICAgICAgICAgdGltZVN0YXJ0OiAwXG4gICAgICAgIH07XG4gICAgICAgIGFuaW1hdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGVsZW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleF07XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSAwO1xuICAgICAgICAgICAgaWYgKGlzTm9kZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1JldmVyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RBbmltYXRpb24gPSBEYXRhKGVsZW1lbnQpLmxhc3RBbmltYXRpb25MaXN0W29wdGlvbnMucXVldWVdO1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzTWFwID0gbGFzdEFuaW1hdGlvbiAmJiBsYXN0QW5pbWF0aW9uLnR3ZWVucztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0aWVzTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVmVsb2NpdHlKUzogQXR0ZW1wdGluZyB0byByZXZlcnNlIGFuIGFuaW1hdGlvbiBvbiBhbiBlbGVtZW50IHdpdGggbm8gcHJldmlvdXMgYW5pbWF0aW9uOlwiLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzIHw9IDY0IC8qIFJFVkVSU0UgKi8gJiB+KGxhc3RBbmltYXRpb24uX2ZsYWdzICYgNjQgLyogUkVWRVJTRSAqLyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0d2VlbnMgPSBjcmVhdGVFbXB0eU9iamVjdCgpLCBhbmltYXRpb24gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdHdlZW5zOiB0d2VlbnNcbiAgICAgICAgICAgICAgICB9LCByb290QW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLl90b3RhbCsrO1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5fZmxhZ3MgfD0gZmxhZ3M7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2Ugd2UncmUgdXNpbmcgdGhlIHByZXZpb3VzIGFuaW1hdGlvbiwgc29cbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgd2lsbCBiZSBleHBhbmRlZCBjb3JyZWN0bHkgd2hlbiB0aGF0IG9uZSBydW5zLlxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24udHdlZW5zID0gcHJvcGVydGllc01hcDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBWZWxvY2l0eVN0YXRpYy5leHBhbmRQcm9wZXJ0aWVzKGFuaW1hdGlvbiwgcHJvcGVydGllc01hcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFZlbG9jaXR5U3RhdGljLnF1ZXVlKGVsZW1lbnQsIGFuaW1hdGlvbiwgb3B0aW9ucy5xdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFZlbG9jaXR5U3RhdGljLlN0YXRlLmlzVGlja2luZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBhbmltYXRpb24gdGljayBpc24ndCBydW5uaW5nLCBzdGFydCBpdC4gKFZlbG9jaXR5IHNodXRzIGl0XG4gICAgICAgICAgICAvLyBvZmYgd2hlbiB0aGVyZSBhcmUgbm8gYWN0aXZlIGNhbGxzIHRvIHByb2Nlc3MuKVxuICAgICAgICAgICAgVmVsb2NpdHlTdGF0aWMudGljaygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRpb25zKSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShlbGVtZW50cy52ZWxvY2l0eSwgXCJhbmltYXRpb25zXCIsIGFuaW1hdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKioqKioqKioqKioqKipcbiAgICAgQ2hhaW5pbmdcbiAgICAgKioqKioqKioqKioqKioqL1xuICAgIC8qIFJldHVybiB0aGUgZWxlbWVudHMgYmFjayB0byB0aGUgY2FsbCBjaGFpbiwgd2l0aCB3cmFwcGVkIGVsZW1lbnRzIHRha2luZyBwcmVjZWRlbmNlIGluIGNhc2UgVmVsb2NpdHkgd2FzIGNhbGxlZCB2aWEgdGhlICQuZm4uIGV4dGVuc2lvbi4gKi8gICAgcmV0dXJuIGVsZW1lbnRzIHx8IHByb21pc2U7XG59XG5cbi8qKioqKioqKioqKioqKipcbiBTdW1tYXJ5XG4gKioqKioqKioqKioqKioqL1xuLypcbiAtIENTUzogQ1NTIHN0YWNrIHRoYXQgd29ya3MgaW5kZXBlbmRlbnRseSBmcm9tIHRoZSByZXN0IG9mIFZlbG9jaXR5LlxuIC0gYW5pbWF0ZSgpOiBDb3JlIGFuaW1hdGlvbiBtZXRob2QgdGhhdCBpdGVyYXRlcyBvdmVyIHRoZSB0YXJnZXRlZCBlbGVtZW50cyBhbmQgcXVldWVzIHRoZSBpbmNvbWluZyBjYWxsIG9udG8gZWFjaCBlbGVtZW50IGluZGl2aWR1YWxseS5cbiAtIFByZS1RdWV1ZWluZzogUHJlcGFyZSB0aGUgZWxlbWVudCBmb3IgYW5pbWF0aW9uIGJ5IGluc3RhbnRpYXRpbmcgaXRzIGRhdGEgY2FjaGUgYW5kIHByb2Nlc3NpbmcgdGhlIGNhbGwncyBvcHRpb25zLlxuIC0gUXVldWVpbmc6IFRoZSBsb2dpYyB0aGF0IHJ1bnMgb25jZSB0aGUgY2FsbCBoYXMgcmVhY2hlZCBpdHMgcG9pbnQgb2YgZXhlY3V0aW9uIGluIHRoZSBlbGVtZW50J3MgcXVldWUgc3RhY2suXG4gTW9zdCBsb2dpYyBpcyBwbGFjZWQgaGVyZSB0byBhdm9pZCByaXNraW5nIGl0IGJlY29taW5nIHN0YWxlIChpZiB0aGUgZWxlbWVudCdzIHByb3BlcnRpZXMgaGF2ZSBjaGFuZ2VkKS5cbiAtIFB1c2hpbmc6IENvbnNvbGlkYXRpb24gb2YgdGhlIHR3ZWVuIGRhdGEgZm9sbG93ZWQgYnkgaXRzIHB1c2ggb250byB0aGUgZ2xvYmFsIGluLXByb2dyZXNzIGNhbGxzIGNvbnRhaW5lci5cbiAtIHRpY2soKTogVGhlIHNpbmdsZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbG9vcCByZXNwb25zaWJsZSBmb3IgdHdlZW5pbmcgYWxsIGluLXByb2dyZXNzIGNhbGxzLlxuIC0gY29tcGxldGVDYWxsKCk6IEhhbmRsZXMgdGhlIGNsZWFudXAgcHJvY2VzcyBmb3IgZWFjaCBWZWxvY2l0eSBjYWxsLlxuICovXG4vKioqKioqKioqKioqKioqKioqKioqXG4gSGVscGVyIEZ1bmN0aW9uc1xuICoqKioqKioqKioqKioqKioqKioqKi9cbi8qIElFIGRldGVjdGlvbi4gR2lzdDogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vanVsaWFuc2hhcGlyby85MDk4NjA5ICovXG52YXIgSUUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDc7IGkgPiA0OyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiXFx4M2MhLS1baWYgSUUgXCIgKyBpICsgXCJdPjxzcGFuPjwvc3Bhbj48IVtlbmRpZl0tLVxceDNlXCI7XG4gICAgICAgICAgICBpZiAoZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3BhblwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkaXYgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKipcbiBVbnN1cHBvcnRlZFxuICoqKioqKioqKioqKioqKioqKi8gaWYgKElFIDw9IDgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJWZWxvY2l0eUpTIGNhbm5vdCBydW4gb24gSW50ZXJuZXQgRXhwbG9yZXIgOCBvciBlYXJsaWVyXCIpO1xufVxuXG5pZiAod2luZG93ID09PSB0aGlzKSB7XG4gICAgLypcbiAgICAgKiBCb3RoIGpRdWVyeSBhbmQgWmVwdG8gYWxsb3cgdGhlaXIgJC5mbiBvYmplY3QgdG8gYmUgZXh0ZW5kZWQgdG8gYWxsb3dcbiAgICAgKiB3cmFwcGVkIGVsZW1lbnRzIHRvIGJlIHN1YmplY3RlZCB0byBwbHVnaW4gY2FsbHMuIElmIGVpdGhlciBmcmFtZXdvcmsgaXNcbiAgICAgKiBsb2FkZWQsIHJlZ2lzdGVyIGEgXCJ2ZWxvY2l0eVwiIGV4dGVuc2lvbiBwb2ludGluZyB0byBWZWxvY2l0eSdzIGNvcmVcbiAgICAgKiBhbmltYXRlKCkgbWV0aG9kLiBWZWxvY2l0eSBhbHNvIHJlZ2lzdGVycyBpdHNlbGYgb250byBhIGdsb2JhbCBjb250YWluZXJcbiAgICAgKiAod2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG8gfHwgd2luZG93KSBzbyB0aGF0IGNlcnRhaW4gZmVhdHVyZXMgYXJlXG4gICAgICogYWNjZXNzaWJsZSBiZXlvbmQganVzdCBhIHBlci1lbGVtZW50IHNjb3BlLiBBY2NvcmRpbmdseSwgVmVsb2NpdHkgY2FuXG4gICAgICogYm90aCBhY3Qgb24gd3JhcHBlZCBET00gZWxlbWVudHMgYW5kIHN0YW5kIGFsb25lIGZvciB0YXJnZXRpbmcgcmF3IERPTVxuICAgICAqIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIHZhciBwYXRjaCA9IFZlbG9jaXR5U3RhdGljLnBhdGNoLCBqUXVlcnkgPSB3aW5kb3cualF1ZXJ5LCBaZXB0byA9IHdpbmRvdy5aZXB0bztcbiAgICBwYXRjaCh3aW5kb3csIHRydWUpO1xuICAgIHBhdGNoKEVsZW1lbnQgJiYgRWxlbWVudC5wcm90b3R5cGUpO1xuICAgIHBhdGNoKE5vZGVMaXN0ICYmIE5vZGVMaXN0LnByb3RvdHlwZSk7XG4gICAgcGF0Y2goSFRNTENvbGxlY3Rpb24gJiYgSFRNTENvbGxlY3Rpb24ucHJvdG90eXBlKTtcbiAgICBwYXRjaChqUXVlcnksIHRydWUpO1xuICAgIHBhdGNoKGpRdWVyeSAmJiBqUXVlcnkuZm4pO1xuICAgIHBhdGNoKFplcHRvLCB0cnVlKTtcbiAgICBwYXRjaChaZXB0byAmJiBaZXB0by5mbik7XG59XG5cbi8qKioqKioqKioqKioqKioqKipcbiBLbm93biBJc3N1ZXNcbiAqKioqKioqKioqKioqKioqKiovXG4vKiBUaGUgQ1NTIHNwZWMgbWFuZGF0ZXMgdGhhdCB0aGUgdHJhbnNsYXRlWC9ZL1ogdHJhbnNmb3JtcyBhcmUgJS1yZWxhdGl2ZSB0byB0aGUgZWxlbWVudCBpdHNlbGYgLS0gbm90IGl0cyBwYXJlbnQuXG4gVmVsb2NpdHksIGhvd2V2ZXIsIGRvZXNuJ3QgbWFrZSB0aGlzIGRpc3RpbmN0aW9uLiBUaHVzLCBjb252ZXJ0aW5nIHRvIG9yIGZyb20gdGhlICUgdW5pdCB3aXRoIHRoZXNlIHN1YnByb3BlcnRpZXNcbiB3aWxsIHByb2R1Y2UgYW4gaW5hY2N1cmF0ZSBjb252ZXJzaW9uIHZhbHVlLiBUaGUgc2FtZSBpc3N1ZSBleGlzdHMgd2l0aCB0aGUgY3gvY3kgYXR0cmlidXRlcyBvZiBTVkcgY2lyY2xlcyBhbmQgZWxsaXBzZXMuICovIHZhciBfbG9vcF8zID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIHZhbHVlID0gVmVsb2NpdHlTdGF0aWNba2V5XTtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IGlzTnVtYmVyKHZhbHVlKSB8fCBpc0Jvb2xlYW4odmFsdWUpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZWxvY2l0eUZuLCBrZXksIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IFBVQkxJQ19NRU1CRVJTLmluZGV4T2Yoa2V5KSA+PSAwLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVsb2NpdHlTdGF0aWNba2V5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgVmVsb2NpdHlTdGF0aWNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmVsb2NpdHlGbiwga2V5LCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBQVUJMSUNfTUVNQkVSUy5pbmRleE9mKGtleSkgPj0gMCxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlbG9jaXR5U3RhdGljW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qXG4gKiBWZWxvY2l0eUpTLm9yZyAoQykgMjAxNC0yMDE3IEp1bGlhbiBTaGFwaXJvLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxuICpcbiAqIE1lcmdlIHRoZSBWZWxvY2l0eVN0YXRpYyBuYW1lc3BhY2Ugb250byB0aGUgVmVsb2NpdHkgZnVuY3Rpb24gZm9yIGV4dGVybmFsXG4gKiB1c2UuIFRoaXMgaXMgZG9uZSBhcyBhIHJlYWQtb25seSB3YXkuIEFueSBhdHRlbXB0IHRvIGNoYW5nZSB0aGVzZSB2YWx1ZXMgd2lsbFxuICogYmUgYWxsb3dlZC5cbiAqLyBmb3IgKHZhciBrZXkgaW4gVmVsb2NpdHlTdGF0aWMpIHtcbiAgICBfbG9vcF8zKGtleSk7XG59XG5cdHJldHVybiBWZWxvY2l0eUZuO1xufSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFVBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/velocity-animate/velocity.js\n");

/***/ }),

/***/ 0:
/*!***********************************************************!*\
  !*** multi ./client/js/index.js ./client/scss/index.scss ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./client/js/index.js */"./client/js/index.js");
module.exports = __webpack_require__(/*! ./client/scss/index.scss */"./client/scss/index.scss");


/***/ })

/******/ });